\documentclass[a4paperpaper,]{article}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\usepackage{fixltx2e} % provides \textsubscript
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
\else % if luatex or xelatex
  \ifxetex
    \usepackage{mathspec}
  \else
    \usepackage{fontspec}
  \fi
  \defaultfontfeatures{Ligatures=TeX,Scale=MatchLowercase}
    \setmonofont[Mapping=tex-ansi]{FreeMono}
\fi
% use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
% use microtype if available
\IfFileExists{microtype.sty}{%
\usepackage{microtype}
\UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\usepackage[margin=1in]{geometry}
\usepackage{hyperref}
\hypersetup{unicode=true,
            pdfborder={0 0 0},
            breaklinks=true}
\urlstyle{same}  % don't use monospace font for urls
\IfFileExists{parskip.sty}{%
\usepackage{parskip}
}{% else
\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}
}
\setlength{\emergencystretch}{3em}  % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{0}
% Redefines (sub)paragraphs to behave more like sections
\ifx\paragraph\undefined\else
\let\oldparagraph\paragraph
\renewcommand{\paragraph}[1]{\oldparagraph{#1}\mbox{}}
\fi
\ifx\subparagraph\undefined\else
\let\oldsubparagraph\subparagraph
\renewcommand{\subparagraph}[1]{\oldsubparagraph{#1}\mbox{}}
\fi
\usepackage{bussproofs}
\usepackage{amsthm}
\usepackage{minted}
\hypersetup{ colorlinks=true, linkcolor=blue, filecolor=magenta, urlcolor=cyan}
\urlstyle{same}
\let\OldTexttt\texttt
\renewcommand{\texttt}[1]{\small\OldTexttt{#1}}
\newcommand{\concat}{\ensuremath{+\!\!\!\!+\,}}
\newcommand{\wf}{\textsf{Wf-ICtxt}\ }
\newcommand{\tocap}{\leadsto\kern-.5ex\cap}
\newcommand{\conR}{\concat_{\kern-1ex R}}
\newcommand{\conL}{\concat_{\kern-1ex L}}

\date{}

\begin{document}

\section{Intersection types}\label{intersection-types}

In this section, we will work with both the simple types introduced
earlier (definition given again below), as well as intersection types,
defined in the following way: \(\\\)

\textbf{Definition} (Types) - Note that \(\mathsf{o}\) and \(\phi\) are
constants. \(\omega\) is used to denote an empty list of strict
intersection types. The following sugar notation will also occasionally
be used: \(\bigcap \tau \equiv [ \tau ]\) and
\(\tau \cap \tau' \equiv \bigcap \tau \concat \bigcap \tau' \equiv [ \tau, \tau' ]\).

\begin{enumerate}
\def\labelenumi{\roman{enumi})}
\tightlist
\item
  Simple types: \[\sigma ::= \mathsf{o}\ |\ \sigma \to \sigma\]
\item
  Intersection types:
  \[\mathcal{T}_s ::= \phi\ |\ \mathcal{T} \leadsto \mathcal{T}\]
  \[\mathcal{T} ::= \mathsf{List}\ \mathcal{T}_s\]
\end{enumerate}

The reason why \(\mathcal{T}\) is defined as a list of strict types
\(\mathcal{T}_s\) is due to the requirement that the types in
\(\mathcal{T}\) be finite. The decision to use lists was taken because
the Agda standard library includes a definition of lists along with
definitions of list membership \(\in\) for lists and other associated
lemmas.

Next, we redefine the \(\lambda\)-terms slightly, by annotating the
terms with simple types. The reason for this will be clear later on.

\textbf{Definition} (Terms) - Let \(\sigma\) range over simple types in
the following definition:

\begin{enumerate}
\def\labelenumi{\roman{enumi})}
\tightlist
\item
  Simply-typed terms:
  \[M::= x_\sigma\ |\ MM\ |\ \lambda x_\sigma.M\ |\ Y_\sigma \text{ where }x \in Var\]
\item
  Simply-typed pre-terms:
  \[M'::= x_\sigma\ |\ i\ |\ M'M'\ |\ \lambda_\sigma.M'\ |\ Y_\sigma \text{ where }x \in Var\text{ and }i \in \mathbb{N}\]
\end{enumerate}

Note that both definitions implicitly assume that in the case of
application, a well formed simply-typed term will be of the form \(st\),
where \(s\) has some simple type \(A \to B\) and \(t\) is typed with the
simple type \(A\). Sometimes the same subscript notation will be used to
indicate the simple type of a given pre-/term, for example:
\(m_{A \to B}\). Also, rather confusingly, the simple type of \(Y_A\) is
\((A \to A) \to A\), and thus \(Y_A\) should not be confused with a
constant \(Y\) having a simple type \(A\). \textbf{Maybe use something
like this instead?:} \(m_{:A \to B}\) i.e. \(Y_{A:(A \to A) \to A}\).\\
The typed versions of substitution and the open and close operations are
virtually identical to the untyped versions.

\subsection{Type refinement}\label{type-refinement}

Next, we introduce the notion of type refinement by defining the
refinement relation \(::\), between simple types and intersection types.

\textbf{Definition} (\(::\)) - Since intersection types are defined in
terms of strict (\(\mathcal{T}_s\)) and non-strict (\(\mathcal{T}\))
intersection types, for correct typing, the definition of \(::\) is
split into two versions, one for strict and another for non-strict
types. In the definition below, \(\tau\) ranges over strict intersection
types \(\mathcal{T}_s\), with \(\tau_i, \tau_j\) ranging over non-strict
intersection types \(\mathcal{T}\), and \(A, B\) range over simple types
\(\sigma\):

\begin{center}
  \AxiomC{}
  \LeftLabel{$(base)$}
  \UnaryInfC{$\phi ::_s \mathsf{o}$}
  \DisplayProof
  \hskip 1.5em
  \AxiomC{$\tau_i :: A$}
  \AxiomC{$\tau_j :: B$}
  \LeftLabel{$(arr)$}
  \BinaryInfC{$\tau_i \leadsto \tau_j ::_s A \to B$}
  \DisplayProof
  \vskip 1.5em
  \AxiomC{}
  \LeftLabel{$(nil)$}
  \UnaryInfC{$\omega :: A$}
  \DisplayProof
  \hskip 1.5em
  \AxiomC{$\tau ::_s A$}
  \AxiomC{$\tau_i :: A$}
  \LeftLabel{$(cons)$}
  \BinaryInfC{$\tau , \tau_i :: A$}
  \DisplayProof
\end{center}

Having a notion of refinement, we define a restricted version of a
subset relation on intersection types, which is defined only for pairs
of intersection types, which refine the same simple type.

\textbf{Definition} (\(\subseteq^A\)) - In the definition below,
\(\tau, \tau'\) range over \(\mathcal{T}_s\), \(\tau_i, \hdots, \tau_n\)
range over \(\mathcal{T}\) and \(A, B\) range over \(\sigma\):

\begin{center}
  \AxiomC{}
  \LeftLabel{$(base)$}
  \UnaryInfC{$\phi \subseteq^\mathsf{o}_s \phi$}
  \DisplayProof
  \hskip 1.5em
  \AxiomC{$\tau_i \subseteq^A \tau_j$}
  \AxiomC{$\tau_m \subseteq^B \tau_n$}
  \LeftLabel{$(arr)$}
  \BinaryInfC{$\tau_j \leadsto \tau_m \subseteq^{A \to B}_s \tau_i \leadsto \tau_n$}
  \DisplayProof
  \vskip 1.5em
  \AxiomC{$\tau_i :: A$}
  \LeftLabel{$(nil)$}
  \UnaryInfC{$\omega \subseteq^A \tau_i$}
  \DisplayProof
  \hskip 1.5em
  \AxiomC{$\exists \tau' \in \tau_j.\ \tau \subseteq^A_s \tau'$}
  \AxiomC{$\tau_i \subseteq^A \tau_j$}
  \LeftLabel{$(cons)$}
  \BinaryInfC{$\tau , \tau_i \subseteq^A \tau_j$}
  \DisplayProof
  \vskip 1.5em
  \AxiomC{$(\tau_i \leadsto (\tau_j \concat \tau_k) ,\ \tau_m) :: A \to B$}
  \LeftLabel{$(\tocap)$}
  \UnaryInfC{$(\tau_i \leadsto (\tau_j \concat \tau_k) ,\ \tau_m) \subseteq^{A \to B} (\tau_i \leadsto \tau_j ,\ \tau_i \leadsto \tau_k ,\ \tau_m)$}
  \DisplayProof
  \hskip 1.5em
  \AxiomC{$\tau_i \subseteq^A \tau_j$}
  \AxiomC{$\tau_j \subseteq^A \tau_k$}
  \LeftLabel{$(trans)$}
  \BinaryInfC{$\tau_i \subseteq^A \tau_k$}
  \DisplayProof
  \vskip 1.5em
\end{center}

It's easy to show the following properties hold for the \(\subseteq^A\)
and \(::\) relations:

\textbf{Lemma} (\(\subseteq\implies::\))

\begin{enumerate}
\def\labelenumi{\roman{enumi})}
\tightlist
\item
  \(\tau \subseteq^A_s \delta \implies \tau ::_s A \land \delta ::_s A\)
\item
  \(\tau_i \subseteq^A \delta_i \implies \tau_i :: A \land \delta_i :: A\)
\end{enumerate}

\emph{Proof:} By \textbf{?mutual?} induction on the relations
\(\subseteq^A_s\) and \(\subseteq^A\).

\textbf{Lemma} (\(\subseteq\) admissible) The following rules are
admissible in \(\subseteq^A_s/\subseteq^A\):

\begin{enumerate}
\def\labelenumi{\roman{enumi})}
\item
  \AxiomC{$\tau ::_s A$} \LeftLabel{$(refl_s)$}
  \UnaryInfC{$\tau \subseteq^A_s \tau$} \DisplayProof
   \hskip 1.5em \AxiomC{$\tau_i :: A$} \LeftLabel{$(refl)$}
  \UnaryInfC{$\tau_i \subseteq^A \tau_i$} \DisplayProof
   \hskip 1.5em \AxiomC{$\tau \subseteq^A_s \tau'$}
  \AxiomC{$\tau' \subseteq^A_s \tau''$} \LeftLabel{$(trans_s)$}
  \BinaryInfC{$\tau \subseteq^A_s \tau''$} \DisplayProof
   \hskip 1.5em \AxiomC{$\tau_i \subseteq \tau_j$}
  \LeftLabel{$(\subseteq)$} \RightLabel{$(\tau_j :: A)$}
  \UnaryInfC{$\tau_i \subseteq^A \tau_j$} \DisplayProof
\item
  \AxiomC{$\tau_i :: A$} \AxiomC{$\tau_j \subseteq^A \tau_{j'}$}
  \LeftLabel{$(\conL)$}
  \BinaryInfC{$\tau_i \concat \tau_j \subseteq^A \tau_i \concat \tau_{j'}$}
  \DisplayProof
   \hskip 1.5em \AxiomC{$\tau_i \subseteq^A \tau_{i'}$}
  \AxiomC{$\tau_j :: A$} \LeftLabel{$(\conR)$}
  \BinaryInfC{$\tau_i \concat \tau_j \subseteq^A \tau_{i'} \concat \tau_j$}
  \DisplayProof
   \hskip 1.5em \AxiomC{$\tau_i \subseteq^A \tau_{k}$}
  \AxiomC{$\tau_j \subseteq^A \tau_{k}$} \LeftLabel{$(glb)$}
  \BinaryInfC{$\tau_i \concat \tau_j \subseteq^A \tau_k$} \DisplayProof
\item
  \AxiomC{$\tau_i \subseteq^A \tau_j$}
  \AxiomC{$\tau_{i'} \subseteq^A \tau_{j'}$} \LeftLabel{$(mon)$}
  \BinaryInfC{$\tau_i \concat \tau_{i'} \subseteq^A \tau_j \concat \tau_{j'}$}
  \DisplayProof
\item
  \AxiomC{$\tau_i :: A$} \AxiomC{$\tau_j :: A$} \LeftLabel{$(\tocap')$}
  \BinaryInfC{$\bigcap ((\tau_i \concat \tau_j) \leadsto (\tau_i \concat \tau_j)) \subseteq^{A \to B} \tau_i \leadsto \tau_i \cap \tau_j \leadsto \tau_j$}
  \DisplayProof
\end{enumerate}

\emph{Proof:}

\begin{enumerate}
\def\labelenumi{\roman{enumi})}
\item
  By induction on \(\tau\) and \(\tau_i\).
\item
  By induction on \(\tau_i \subseteq^A \tau_{i'}\).
\item
  \vskip 1em \AxiomC{$\tau_i \subseteq^A \tau_j$} \AxiomC{}
  \UnaryInfC{$\tau_j \subseteq \tau_j \concat \tau_{j'}$}
  \LeftLabel{$(\subseteq)$}
  \UnaryInfC{$\tau_j \subseteq^A \tau_j \concat \tau_{j'}$}
  \LeftLabel{$(trans)$}
  \BinaryInfC{$\tau_i \subseteq^A \tau_j \concat \tau_{j'}$}
  \AxiomC{$\tau_{i'} \subseteq^A \tau_{j'}$} \AxiomC{}
  \UnaryInfC{$\tau_{j'} \subseteq \tau_j \concat \tau_{j'}$}
  \LeftLabel{$(\subseteq)$}
  \UnaryInfC{$\tau_{j'} \subseteq^A \tau_j \concat \tau_{j'}$}
  \LeftLabel{$(trans)$}
  \BinaryInfC{$\tau_{i'} \subseteq^A \tau_j \concat \tau_{j'}$}
  \LeftLabel{$(glb)$}
  \BinaryInfC{$\tau_i \concat \tau_{i'} \subseteq^A \tau_j \concat \tau_{j'}$}
  \DisplayProof
\item
  Follows from \((\tocap)\), \((cons)\) and \((trans)\).
\end{enumerate}

\subsection{Intersection-type
assignment}\label{intersection-type-assignment}

Having annotated the \(\lambda\)-terms with simple types, the following
type assignment only permits the typing of simply-typed
\(\lambda\)-terms with an intersection type, which refines the simple
type of the \(\lambda\)-term:

\textbf{Definition} (Intersection-type assignment)

\begin{center}
  \AxiomC{$\exists (x, \tau_i, A) \in \Gamma.\ \bigcap \tau \subseteq^A \tau_i$}
  \LeftLabel{$(var)$}
  \UnaryInfC{$\Gamma \Vdash_s x_A : \tau$}
  \DisplayProof
  %------------------------------------
  \hskip 1.5em
  \AxiomC{$\Gamma \Vdash_s u_{A \to B} : \tau_i \leadsto \tau_j$}
  \AxiomC{$\Gamma \Vdash v_A : \tau_i$}
  \LeftLabel{$(app)$}
  \RightLabel{$(\bigcap \tau \subseteq^B \tau_j)$}
  \BinaryInfC{$\Gamma \Vdash_s uv_B : \tau$}
  \DisplayProof
  %------------------------------------
  \vskip 1.5em
  \AxiomC{$\forall x \not\in L.\ (x, \tau_i, A),\Gamma \Vdash m^x : \tau_j$}
  \LeftLabel{$(abs)$}
  \UnaryInfC{$\Gamma \Vdash_s \lambda_A.m : \tau_i \leadsto \tau_j$}
  \DisplayProof
  %------------------------------------
  \hskip 1.5em
  \AxiomC{$\exists \tau_x.\ \bigcap (\tau_x \leadsto \tau_x) \subseteq^{A \to A} \tau_i \land \tau_j \subseteq^A \tau_x$}
  \LeftLabel{$(Y)$}
  \UnaryInfC{$\Gamma \Vdash_s Y_{A} : \tau_i \leadsto \tau_j$}
  \DisplayProof
  %------------------------------------
  \vskip 1.5em
  \AxiomC{$\Gamma \Vdash_s m_{A \to B} : \tau_i \leadsto \tau_j$}
  \AxiomC{$\Gamma \Vdash_s m_{A \to B} : \tau_i \leadsto \tau_k$}
  \LeftLabel{$(\tocap)$}
  \RightLabel{$(\tau_{jk} \subseteq^B \tau_j \concat \tau_k)$}
  \BinaryInfC{$\Gamma \Vdash_s m_{A \to B} : \tau_i \leadsto \tau_{jk}$}
  \DisplayProof
  %------------------------------------
  \vskip 1.5em
  \AxiomC{}
  \LeftLabel{$(nil)$}
  \UnaryInfC{$\Gamma \Vdash m : \omega$}
  \DisplayProof
  %------------------------------------
  \hskip 1.5em
  \AxiomC{$\Gamma \Vdash_s m : \tau$}
  \AxiomC{$\Gamma \Vdash m : \tau_i$}
  \LeftLabel{$(cons)$}
  \BinaryInfC{$\Gamma \Vdash m : \tau , \tau_i$}
  \DisplayProof
  \vskip 1.5em
\end{center}

In the definition above, \(\Gamma\) is the typing context, consisting of
triples of the variable name and the corresponding intersection and
simple types. \(\Gamma\) is defined as a list of these triples in the
Agda implementation. It is assumed in the typing system, that \(\Gamma\)
is well-formed. Formally, this can be expressed in the following way:

\textbf{Definition} (Well-formed intersection-type context)

\begin{center}
  \AxiomC{}
  \LeftLabel{$(nil)$}
  \UnaryInfC{$\wf [\ ]$}
  \DisplayProof
  %------------------------------------
  \hskip 1.5em
  \AxiomC{$x \not\in \mathsf{dom}\ \Gamma$}
  \AxiomC{$\tau_i :: A$}
  \AxiomC{$\wf \Gamma$}
  \LeftLabel{$(cons)$}
  \TrinaryInfC{$\wf (x,\tau_i,A),\Gamma$}
  \DisplayProof
  \vskip 1.5em
\end{center}

\subsubsection{Subtyping}\label{subtyping}

In the typing system, the rules \((Y)\) and \((\tocap)\) are defined in
a slightly more complicated way than might be necessary. For example,
one might assume, the \((Y)\) rule could simply be:

\begin{center}
  \vskip 1em
  \AxiomC{}
  \LeftLabel{$(Y)$}
  \UnaryInfC{$\Gamma \Vdash_s Y_{A} : \bigcap (\tau_x \leadsto \tau_x) \leadsto \tau_x$}
  \DisplayProof
  \vskip 1.5em
\end{center}

The reason why the more complicated forms of both rules were introduced
was purely an engineering one, namely to make the proof of
sub-typing/weakening possible, as the sub-typing rule is required in
multiple further proofs:

\textbf{Lemma} (Sub-typing) The following rule(s) are admissible in
\(\Vdash_s\)/\(\Vdash\):

\begin{center}
  \AxiomC{$\Gamma \Vdash_s m_A : \tau$}
  \LeftLabel{$(\supseteq_s)$}
  \RightLabel{$(\Gamma' \subseteq_\Gamma \Gamma, \tau \supseteq^A_s \tau')$}
  \UnaryInfC{$\Gamma' \Vdash_s m_A : \tau'$}
  \DisplayProof
  \hskip 1.5em
  \AxiomC{$\Gamma \Vdash m_A : \tau_i$}
  \LeftLabel{$(\supseteq)$}
  \RightLabel{$(\Gamma' \subseteq_\Gamma \Gamma, \tau_i \supseteq^A_s \tau_j)$}
  \UnaryInfC{$\Gamma' \Vdash m_A : \tau_j$}
  \DisplayProof
\end{center}

\emph{Proof:} Ommited.

The relation \(\Gamma \subseteq_\Gamma \Gamma'\) is defined for any
well-formed contexts \(\Gamma, \Gamma'\), where for each triple
\((x ,\tau_i, A) \in \Gamma\), there is a corresponding triple
\((x ,\tau_j, A) \in \Gamma'\) s.t. \(\tau_i \subseteq^A \tau_j\).

\subsubsection{Inversion lemmas}\label{inversion-lemmas}

The shape of the derivation tree is not always unique for arbitrary
typed term \(\Gamma \Vdash_s m :\tau\). For example, given a typed term
\(\Gamma \Vdash_s \lambda_A.m :\tau_i \leadsto \tau_j\), either of the
following two derivation trees, could be valid:

\begin{center}\hskip 1.5em
  \AxiomC{$\vdots$}
  \UnaryInfC{$\forall x \not\in L.\ (x, \tau_i, A),\Gamma \Vdash m^x : \tau_j$}
  \LeftLabel{$(abs)$}
  \UnaryInfC{$\Gamma \Vdash_s \lambda_A.m : \tau_i \leadsto \tau_j$}
  \DisplayProof
  %------------------------------------
  \vskip 1.5em
  \AxiomC{$\vdots$}
  \UnaryInfC{$\Gamma \Vdash_s \lambda_A.m_B : \tau_i \leadsto \tau_p$}

  \AxiomC{$\vdots$}
  \UnaryInfC{$\Gamma \Vdash_s \lambda_A.m_B : \tau_i \leadsto \tau_q$}
  \LeftLabel{$(\tocap)$}
  \RightLabel{$(\tau_j \subseteq^B \tau_p \concat \tau_q)$}
  \BinaryInfC{$\Gamma \Vdash_s \lambda_A.m_B : \tau_i \leadsto \tau_j$}
  \DisplayProof
\end{center}

However, it is obvious that the second tree will always necessarily have
to have an application of \((abs)\) in all its branches. Because it will
be necessary to reason about the shape of the typing derivation trees,
it is useful to prove the following inversion lemmas:

\textbf{Lemma} (\(Y\)-inv, \(abs\)-inv)

\begin{enumerate}
\def\labelenumi{\roman{enumi})}
\tightlist
\item
  \(\Gamma \Vdash_s Y_{A} : \tau_i \leadsto \tau_j \implies \exists \tau_x.\ \bigcap (\tau_x \leadsto \tau_x) \subseteq^{A \to A} \tau_i \land \tau_j \subseteq^A \tau_x\)
\item
  \(\Gamma \Vdash_s \lambda_A.m : \tau_i \leadsto \tau_j \implies \exists L.\ \forall x \not\in L.\ (x, \tau_i, A),\Gamma \Vdash m^x : \tau_j\)
\end{enumerate}

\emph{Proof}:

\begin{enumerate}
\def\labelenumi{\roman{enumi})}
\item
  There are two cases to consider, one, where the last rule in the
  derivation tree of \(\Gamma \Vdash_s Y_{A} : \tau_i \leadsto \tau_j\)
  was \((Y)\). Otherwise, the last rule was \((\tocap)\):

  \((Y)\): Follows immediately.\\
  \((\tocap)\): We must have a derivation tree of the shape:

  \begin{center}
    \AxiomC{$\vdots$}
    \UnaryInfC{$\Gamma \Vdash_s Y_A : \tau_i \leadsto \tau_p$}

    \AxiomC{$\vdots$}
    \UnaryInfC{$\Gamma \Vdash_s Y_A : \tau_i \leadsto \tau_q$}
    \LeftLabel{$(\tocap)$}
    \RightLabel{$(\tau_j \subseteq^B \tau_p \concat \tau_q)$}
    \BinaryInfC{$\Gamma \Vdash_s Y_A : \tau_i \leadsto \tau_j$}
    \DisplayProof
  \end{center}

  Then by IH, we have:

  \begin{itemize}
  \item
    \(\exists \tau_{xp}.\ \bigcap (\tau_{xp} \leadsto \tau_{xp}) \subseteq^{A \to A} \tau_i \land \tau_p \subseteq^A \tau_{xp}\)
    and
  \item
    \(\exists \tau_{xq}.\ \bigcap (\tau_{xq} \leadsto \tau_{xq}) \subseteq^{A \to A} \tau_i \land \tau_q \subseteq^A \tau_{xq}\)
  \end{itemize}

  We then take \(\tau_x \equiv \tau_{xp} \concat \tau_{xq}\):
\end{enumerate}

\begin{center}
  \tiny
  \AxiomC{}
  \LeftLabel{$(\tocap')$}
  \UnaryInfC{$\bigcap (\tau_{x} \leadsto \tau_{x}) \subseteq^{A \to A} \tau_{xp}\leadsto \tau_{xp} \cap \tau_{xq} \leadsto \tau_{xq}$}

  \AxiomC{}
  \LeftLabel{$(IH)$}
  \UnaryInfC{$\tau_{xp} \leadsto \tau_{xp} \subseteq^{A \to A} \tau_i$}
  \AxiomC{}
  \LeftLabel{$(IH)$}
  \UnaryInfC{$\tau_{xq} \leadsto \tau_{xq} \subseteq^{A \to A} \tau_i$}
  \LeftLabel{$(mon)$}
  \BinaryInfC{$\tau_{xp}\leadsto \tau_{xp} \cap \tau_{xq} \leadsto \tau_{xq} \subseteq^{A \to A} \tau_i \concat \tau_i$}
  \LeftLabel{$(trans)$}
  \BinaryInfC{$\bigcap (\tau_{x} \leadsto \tau_{x}) \subseteq^{A \to A} \tau_i \concat \tau_i$}

  \AxiomC{}
  \UnaryInfC{$\tau_i \concat \tau_i \subseteq \tau_i$}
  \LeftLabel{$(\subseteq)$}
  \UnaryInfC{$\tau_i \concat \tau_i \subseteq^{A \to A} \tau_i$}
  \LeftLabel{$(trans)$}
  \BinaryInfC{$\bigcap (\tau_{x} \leadsto \tau_{x}) \subseteq^{A \to A} \tau_i$}
  \DisplayProof
\end{center}

\begin{center}
  \vskip 1.5em
  \AxiomC{}
  \UnaryInfC{$\tau_j \subseteq^A \tau_p \concat \tau_q$}

  \AxiomC{}
  \LeftLabel{$(IH)$}
  \UnaryInfC{$\tau_p \concat \subseteq^A \tau_{xp}$}
  \AxiomC{}
  \LeftLabel{$(IH)$}
  \UnaryInfC{$\tau_q \concat \subseteq^A \tau_{xq}$}
  \LeftLabel{$(mon)$}
  \BinaryInfC{$\tau_p \concat \tau_q \subseteq^A \tau_x$}
  \LeftLabel{$(trans)$}
  \BinaryInfC{$\tau_j \subseteq^A \tau_x$}
  \DisplayProof
  \vskip 1.5em
\end{center}

\begin{enumerate}
\def\labelenumi{\roman{enumi})}
\setcounter{enumi}{1}
\tightlist
\item
  Follows in a similar fashion.
\end{enumerate}

\subsection{Proofs of subject expansion and
reduction}\label{proofs-of-subject-expansion-and-reduction}

An interesting property of the intersection types, is the fact that they
admit both subject expansion and subject reduction, namely \(\Vdash\) is
closed under \(\beta\)-equality. Subject expansion and reduction are
proved in two separate lemmas:

\textbf{Theorem} (\(\Vdash\) closed under \(=_\beta\))

\begin{enumerate}
\def\labelenumi{\roman{enumi})}
\tightlist
\item
  \(\Gamma \Vdash_s m : \tau \implies m \Rightarrow_\beta m' \implies \Gamma \Vdash_s m' : \tau\)
\item
  \(\Gamma \Vdash m : \tau_i \implies m \Rightarrow_\beta m' \implies \Gamma \Vdash m' : \tau_i\)
\item
  \(\Gamma \Vdash_s m' : \tau \implies m \Rightarrow_\beta m' \implies \Gamma \Vdash_s m : \tau\)
\item
  \(\Gamma \Vdash m' : \tau_i \implies m \Rightarrow_\beta m' \implies \Gamma \Vdash m : \tau_i\)
\end{enumerate}

\emph{Proof:} By induction on \(\Rightarrow_\beta\). The proofs in both
directions follow by straightforward induction for all the rules except
for \((Y)\) and \((beta)\). Note that the \((Y)\) rule here is not the
typing rule, but rather the reduction rule
\(Y_A m \Rightarrow_\beta m(Y_A m)\).

\begin{enumerate}
\def\labelenumi{\roman{enumi})}
\tightlist
\item
  \((Y)\): By assumption, we have \(Y_A m \Rightarrow_\beta m(Y_A m)\)
  and \(\Gamma \Vdash_s Y_A m : \tau\). By case analysis of the last
  rule applied in the derivation tree of
  \(\Gamma \Vdash_s Y_A m : \tau\), we have two cases:

  \begin{itemize}
  \item
    \((app)\) We have:

    \begin{center}
      \vskip 1em
      \AxiomC{$\vdots$}
      \UnaryInfC{$\Gamma \Vdash_s Y_A : \tau_i \leadsto \tau_j$}
      \AxiomC{$\vdots$}
      \UnaryInfC{$\Gamma \Vdash m_{A \to A} : \tau_i$}
      \LeftLabel{$(app)$}
      \RightLabel{$(\bigcap \tau \subseteq^A \tau_j)$}
      \BinaryInfC{$\Gamma \Vdash_s Y_{A} m : \tau$}
      \DisplayProof
      \vskip 1em
    \end{center}

    Then, by (\(Y\)-inv) we have some \(\tau_x\) s.t
    \(\bigcap (\tau_x \leadsto \tau_x) \subseteq^{A \to A} \tau_i \land \tau_j \subseteq^A \tau_x\).
  \item
    \((\tocap)\) Then we have:

    \begin{center}
      \vskip 1em
      \AxiomC{$\vdots$}
      \UnaryInfC{$\Gamma \Vdash_s Y_{B \to C} m : \tau_i \leadsto \tau_j$}
      \AxiomC{$\vdots$}
      \UnaryInfC{$\Gamma \Vdash_s Y_{B \to C} m : \tau_i \leadsto \tau_k$}
      \LeftLabel{$(\tocap)$}
      \RightLabel{$(\tau_{jk} \subseteq^C \tau_j \concat \tau_k)$}
      \BinaryInfC{$\Gamma \Vdash_s Y_{B \to C} m : \tau_i \leadsto \tau_{jk}$}
      \DisplayProof
      \vskip 1em
    \end{center}

    Where \(A \equiv B \to C\).

    By IH, we get
    \(\Gamma \Vdash_s m (Y_{B \to C} m) : \tau_i \leadsto \tau_j\) and
    \(\Gamma \Vdash_s m (Y_{B \to C} m) : \tau_i \leadsto \tau_k\), thus
    from \((\tocap)\) it follows that
    \(\Gamma \Vdash_s m (Y_{B \to C} m) : \tau_i \leadsto \tau_{jk}\)
  \end{itemize}
\end{enumerate}

\hypertarget{refs}{}

\end{document}
