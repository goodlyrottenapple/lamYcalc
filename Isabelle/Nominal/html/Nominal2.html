<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>Theory Nominal2 (Isabelle2016: February 2016)</title>
<link media="all" rel="stylesheet" type="text/css" href="isabelle.css"/>
</head>

<body>
<div class="head"><h1>Theory Nominal2</h1>

<span class="command">theory</span> <span class="name">Nominal2</span><br/>
<span class="keyword">imports</span> <a href="Nominal2_FCB.html"><span class="name">Nominal2_FCB</span></a><br/>

</div>
<div class="source">
<pre class="source"><span class="keyword1">theory</span><span class=""> </span><span class="">Nominal2</span><span class="">
</span><span class="keyword2">imports</span><span class=""> 
</span><span class="">  </span><span class="">Nominal2_Base</span><span class=""> </span><span class="">Nominal2_Abs</span><span class=""> </span><span class="">Nominal2_FCB</span><span class="">
</span><span class="keyword2">keywords</span><span class="">
</span><span class="">  </span><span class="string">&quot;nominal_datatype&quot;</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="">thy_decl</span><span class=""> </span><span class="keyword2">and</span><span class="">
</span><span class="">  </span><span class="string">&quot;nominal_function&quot;</span><span class=""> </span><span class="string">&quot;nominal_inductive&quot;</span><span class=""> </span><span class="string">&quot;nominal_termination&quot;</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="">thy_goal</span><span class=""> </span><span class="keyword2">and</span><span class="">
</span><span class="">  </span><span class="string">&quot;avoids&quot;</span><span class=""> </span><span class="string">&quot;binds&quot;</span><span class="">
</span><span class="keyword2">begin</span><span class="">
</span><span class="">
</span><span class="keyword1">ML_file</span><span class=""> </span><span class="string">&quot;nominal_dt_data.ML&quot;</span><span class="">
</span><span class="keyword1">ML</span><span class=""> </span><span class="verbatim">{* open Nominal_Dt_Data *}</span><span class="">
</span><span class="">
</span><span class="keyword1">ML_file</span><span class=""> </span><span class="string">&quot;nominal_dt_rawfuns.ML&quot;</span><span class="">
</span><span class="keyword1">ML</span><span class=""> </span><span class="verbatim">{* open Nominal_Dt_RawFuns *}</span><span class="">
</span><span class="">
</span><span class="keyword1">ML_file</span><span class=""> </span><span class="string">&quot;nominal_dt_alpha.ML&quot;</span><span class="">
</span><span class="keyword1">ML</span><span class=""> </span><span class="verbatim">{* open Nominal_Dt_Alpha *}</span><span class="">
</span><span class="">
</span><span class="keyword1">ML_file</span><span class=""> </span><span class="string">&quot;nominal_dt_quot.ML&quot;</span><span class="">
</span><span class="keyword1">ML</span><span class=""> </span><span class="verbatim">{* open Nominal_Dt_Quot *}</span><span class="">
</span><span class="">
</span><span class="comment">(*****************************************)</span><span class="">
</span><span class="comment">(* setup for induction principles method *)</span><span class="">
</span><span class="keyword1">ML_file</span><span class=""> </span><span class="string">&quot;nominal_induct.ML&quot;</span><span class="">
</span><span class="keyword1">method_setup</span><span class=""> </span><span class="">nominal_induct</span><span class=""> </span><span class="delimiter">=</span><span class="">
</span><span class="">  </span><span class="verbatim">{* NominalInduct.nominal_induct_method *}</span><span class="">
</span><span class="">  </span><span class="verbatim">{* nominal induction *}</span><span class="">
</span><span class="">
</span><span class="comment">(****************************************************)</span><span class="">
</span><span class="comment">(* inductive definition involving nominal datatypes *)</span><span class="">
</span><span class="keyword1">ML_file</span><span class=""> </span><span class="string">&quot;nominal_inductive.ML&quot;</span><span class="">
</span><span class="">
</span><span class="">
</span><span class="comment">(***************************************)</span><span class="">
</span><span class="comment">(* forked code of the function package *)</span><span class="">
</span><span class="comment">(* for defining nominal functions      *)</span><span class="">
</span><span class="keyword1">ML_file</span><span class=""> </span><span class="string">&quot;nominal_function_common.ML&quot;</span><span class="">
</span><span class="keyword1">ML_file</span><span class=""> </span><span class="string">&quot;nominal_function_core.ML&quot;</span><span class="">
</span><span class="keyword1">ML_file</span><span class=""> </span><span class="string">&quot;nominal_mutual.ML&quot;</span><span class="">
</span><span class="keyword1">ML_file</span><span class=""> </span><span class="string">&quot;nominal_function.ML&quot;</span><span class="">
</span><span class="keyword1">ML_file</span><span class=""> </span><span class="string">&quot;nominal_termination.ML&quot;</span><span class="">
</span><span class="">
</span><span class="keyword1">ML</span><span class=""> </span><span class="verbatim">{*
val eqvt_attr = Attrib.internal (K Nominal_ThmDecls.eqvt_add)
val simp_attr = Attrib.internal (K Simplifier.simp_add)
val induct_attr = Attrib.internal (K Induct.induct_simp_add)
*}</span><span class="">
</span><span class="">
</span><span class="keyword1">section</span><span class="verbatim">{* Interface for nominal_datatype *}</span><span class="">
</span><span class="">
</span><span class="keyword1">ML</span><span class=""> </span><span class="verbatim">{*
fun get_cnstrs dts =
  map snd dts

fun get_typed_cnstrs dts =
  flat (map (fn ((bn, _, _), constrs) =&gt; 
   (map (fn (bn&#39;, _, _) =&gt; (Binding.name_of bn, Binding.name_of bn&#39;)) constrs)) dts)

fun get_cnstr_strs dts =
  map (fn (bn, _, _) =&gt; Binding.name_of bn) (flat (get_cnstrs dts))

fun get_bn_fun_strs bn_funs =
  map (fn (bn_fun, _, _) =&gt; Binding.name_of bn_fun) bn_funs
*}</span><span class="">
</span><span class="">
</span><span class="">
</span><span class="keyword1">text</span><span class=""> </span><span class="verbatim">{* Infrastructure for adding &quot;_raw&quot; to types and terms *}</span><span class="">
</span><span class="">
</span><span class="keyword1">ML</span><span class=""> </span><span class="verbatim">{*
fun add_raw s = s ^ &quot;_raw&quot;
fun add_raws ss = map add_raw ss
fun raw_bind bn = Binding.suffix_name &quot;_raw&quot; bn

fun replace_str ss s = 
  case (AList.lookup (op=) ss s) of 
     SOME s&#39; =&gt; s&#39;
   | NONE =&gt; s

fun replace_typ ty_ss (Type (a, Ts)) = Type (replace_str ty_ss a, map (replace_typ ty_ss) Ts)
  | replace_typ ty_ss T = T  

fun raw_dts ty_ss dts =
let
  fun raw_dts_aux1 (bind, tys, _) =
    (raw_bind bind, map (replace_typ ty_ss) tys, NoSyn)

  fun raw_dts_aux2 ((bind, ty_args, _), constrs) =
    ((raw_bind bind, ty_args, NoSyn), map raw_dts_aux1 constrs)
in
  map raw_dts_aux2 dts
end

fun replace_aterm trm_ss (Const (a, T)) = Const (replace_str trm_ss a, T)
  | replace_aterm trm_ss (Free (a, T)) = Free (replace_str trm_ss a, T)
  | replace_aterm trm_ss trm = trm

fun replace_term trm_ss ty_ss trm =
  trm |&gt; Term.map_aterms (replace_aterm trm_ss) |&gt; map_types (replace_typ ty_ss) 
*}</span><span class="">
</span><span class="">
</span><span class="keyword1">ML</span><span class=""> </span><span class="verbatim">{*
fun rawify_dts dts dts_env = raw_dts dts_env dts
*}</span><span class="">
</span><span class="">
</span><span class="keyword1">ML</span><span class=""> </span><span class="verbatim">{*
fun rawify_bn_funs dts_env cnstrs_env bn_fun_env bn_funs bn_eqs =
let
  val bn_funs&#39; = map (fn (bn, ty, _) =&gt; 
    (raw_bind bn, SOME (replace_typ dts_env ty), NoSyn)) bn_funs
  
  val bn_eqs&#39; = map (fn (attr, trm) =&gt; 
    (attr, replace_term (cnstrs_env @ bn_fun_env) dts_env trm)) bn_eqs
in
  (bn_funs&#39;, bn_eqs&#39;) 
end 
*}</span><span class="">
</span><span class="">
</span><span class="keyword1">ML</span><span class=""> </span><span class="verbatim">{* 
fun rawify_bclauses dts_env cnstrs_env bn_fun_env bclauses =
let
  fun rawify_bnds bnds = 
    map (apfst (Option.map (replace_term (cnstrs_env @ bn_fun_env) dts_env))) bnds

  fun rawify_bclause (BC (mode, bnds, bdys)) = BC (mode, rawify_bnds bnds, bdys)
in
  (map o map o map) rawify_bclause bclauses
end
*}</span><span class="">
</span><span class="">
</span><span class="">
</span><span class="keyword1">ML</span><span class=""> </span><span class="verbatim">{*
(* definition of the raw datatype *)

fun define_raw_dts dts cnstr_names cnstr_tys bn_funs bn_eqs bclauses lthy =
let
  val thy = Local_Theory.exit_global lthy
  val thy_name = Context.theory_name thy

  val dt_names = map (fn ((s, _, _), _) =&gt; Binding.name_of s) dts
  val dt_full_names = map (Long_Name.qualify thy_name) dt_names 
  val dt_full_names&#39; = add_raws dt_full_names
  val dts_env = dt_full_names ~~ dt_full_names&#39;

  val cnstr_full_names = map (Long_Name.qualify thy_name) cnstr_names
  val cnstr_full_names&#39; = map (fn (x, y) =&gt; Long_Name.qualify thy_name 
    (Long_Name.qualify (add_raw x) (add_raw y))) cnstr_tys
  val cnstrs_env = cnstr_full_names ~~ cnstr_full_names&#39;

  val bn_fun_strs = get_bn_fun_strs bn_funs
  val bn_fun_strs&#39; = add_raws bn_fun_strs
  val bn_fun_env = bn_fun_strs ~~ bn_fun_strs&#39;
  val bn_fun_full_env = map (apply2 (Long_Name.qualify thy_name)) 
    (bn_fun_strs ~~ bn_fun_strs&#39;)
  
  val raw_dts = rawify_dts dts dts_env
  val (raw_bn_funs, raw_bn_eqs) = rawify_bn_funs dts_env cnstrs_env bn_fun_env bn_funs bn_eqs 
  val raw_bclauses = rawify_bclauses dts_env cnstrs_env bn_fun_full_env bclauses 

  val (raw_full_dt_names&#39;, thy1) = 
    Old_Datatype.add_datatype Old_Datatype_Aux.default_config raw_dts thy

  val lthy1 = Named_Target.theory_init thy1

  val dtinfos = map (Old_Datatype_Data.the_info (Proof_Context.theory_of lthy1)) raw_full_dt_names&#39; 
  val {descr, ...} = hd dtinfos

  val raw_tys = Old_Datatype_Aux.get_rec_types descr
  val raw_ty_args = hd raw_tys
    |&gt; snd o dest_Type
    |&gt; map dest_TFree 

  val raw_cns_info = all_dtyp_constrs_types descr
  val raw_all_cns = (map o map) (fn (c, _, _, _) =&gt; c) raw_cns_info

  val raw_inject_thms = flat (map #inject dtinfos)
  val raw_distinct_thms = flat (map #distinct dtinfos)
  val raw_induct_thm = #induct (hd dtinfos)
  val raw_induct_thms = #inducts (hd dtinfos)
  val raw_exhaust_thms = map #exhaust dtinfos
  val raw_size_trms = map HOLogic.size_const raw_tys
  val raw_size_thms = these (Option.map ((fn ths =&gt; drop (length ths div 2) ths) o #2 o #2)
    (BNF_LFP_Size.size_of lthy1 (hd raw_full_dt_names&#39;)))

  val raw_result = RawDtInfo 
    {raw_dt_names = raw_full_dt_names&#39;,
     raw_dts = raw_dts,
     raw_tys = raw_tys,
     raw_ty_args = raw_ty_args,
     raw_cns_info = raw_cns_info,
     raw_all_cns = raw_all_cns,
     raw_inject_thms = raw_inject_thms,
     raw_distinct_thms = raw_distinct_thms,
     raw_induct_thm = raw_induct_thm,
     raw_induct_thms = raw_induct_thms,
     raw_exhaust_thms = raw_exhaust_thms,
     raw_size_trms = raw_size_trms,
     raw_size_thms = raw_size_thms}
in
  (raw_bclauses, raw_bn_funs, raw_bn_eqs, raw_result, lthy1)
end
*}</span><span class="">
</span><span class="">
</span><span class="">
</span><span class="keyword1">ML</span><span class=""> </span><span class="verbatim">{*
fun nominal_datatype2 opt_thms_name dts bn_funs bn_eqs bclauses lthy =
let
  val cnstr_names = get_cnstr_strs dts
  val cnstr_tys = get_typed_cnstrs dts

  val _ = trace_msg (K &quot;Defining raw datatypes...&quot;)
  val (raw_bclauses, raw_bn_funs, raw_bn_eqs, raw_dt_info, lthy0) =
    define_raw_dts dts cnstr_names cnstr_tys bn_funs bn_eqs bclauses lthy   

  val RawDtInfo 
    {raw_dt_names,
     raw_tys,
     raw_ty_args,
     raw_all_cns,
     raw_inject_thms,
     raw_distinct_thms,
     raw_induct_thm,
     raw_induct_thms,
     raw_exhaust_thms,
     raw_size_trms,
     raw_size_thms, ...} = raw_dt_info
  
  val _ = trace_msg (K &quot;Defining raw permutations...&quot;)
  val ((raw_perm_funs, raw_perm_simps, raw_perm_laws), lthy2a) = define_raw_perms raw_dt_info lthy0
 
  (* noting the raw permutations as eqvt theorems *)
  val lthy3 = snd (Local_Theory.note ((Binding.empty, [eqvt_attr]), raw_perm_simps) lthy2a)

  val _ = trace_msg (K &quot;Defining raw fv- and bn-functions...&quot;)
  val (raw_bns, raw_bn_defs, raw_bn_info, raw_bn_inducts, lthy3a) =
    define_raw_bns raw_dt_info raw_bn_funs raw_bn_eqs lthy3
    
  (* defining the permute_bn functions *)
  val (raw_perm_bns, raw_perm_bn_simps, lthy3b) = 
    define_raw_bn_perms raw_dt_info raw_bn_info lthy3a
    
  val (raw_fvs, raw_fv_bns, raw_fv_defs, raw_fv_bns_induct, lthy3c) = 
    define_raw_fvs raw_dt_info raw_bn_info raw_bclauses lthy3b
    
  val _ = trace_msg (K &quot;Defining alpha relations...&quot;)
  val (alpha_result, lthy4) =
    define_raw_alpha raw_dt_info raw_bn_info raw_bclauses raw_fvs lthy3c
    
  val _ = trace_msg (K &quot;Proving distinct theorems...&quot;)
  val alpha_distincts = raw_prove_alpha_distincts lthy4 alpha_result raw_dt_info

  val _ = trace_msg (K &quot;Proving eq-iff theorems...&quot;)
  val alpha_eq_iff = raw_prove_alpha_eq_iff lthy4 alpha_result raw_dt_info
    
  val _ = trace_msg (K &quot;Proving equivariance of bns, fvs, size and alpha...&quot;)
  val raw_bn_eqvt = 
    raw_prove_eqvt raw_bns raw_bn_inducts (raw_bn_defs @ raw_perm_simps) lthy4
    
  (* noting the raw_bn_eqvt lemmas in a temprorary theory *)
  val lthy_tmp = snd (Local_Theory.note ((Binding.empty, [eqvt_attr]), raw_bn_eqvt) lthy4)

  val raw_fv_eqvt = 
    raw_prove_eqvt (raw_fvs @ raw_fv_bns) raw_fv_bns_induct (raw_fv_defs @ raw_perm_simps) 
      (Local_Theory.restore lthy_tmp)
    
  val raw_size_eqvt =
    let
      val RawDtInfo {raw_size_trms, raw_size_thms, raw_induct_thms, ...} = raw_dt_info
    in
      raw_prove_eqvt raw_size_trms raw_induct_thms (raw_size_thms @ raw_perm_simps) 
        (Local_Theory.restore lthy_tmp)
        |&gt; map (rewrite_rule (Local_Theory.restore lthy_tmp)
            @{thms permute_nat_def[THEN eq_reflection]})
        |&gt; map (fn thm =&gt; thm RS @{thm sym})
    end 
     
  val lthy5 = snd (Local_Theory.note ((Binding.empty, [eqvt_attr]), raw_fv_eqvt) lthy_tmp)

  val alpha_eqvt =
    let
      val AlphaResult {alpha_trms, alpha_bn_trms, alpha_raw_induct, alpha_intros, ...} = alpha_result
    in
      Nominal_Eqvt.raw_equivariance lthy5 (alpha_trms @ alpha_bn_trms) alpha_raw_induct alpha_intros
    end

  val alpha_eqvt_norm = map (Nominal_ThmDecls.eqvt_transform lthy5) alpha_eqvt

  val _ = trace_msg (K &quot;Proving equivalence of alpha...&quot;)
  val alpha_refl_thms = raw_prove_refl lthy5 alpha_result raw_induct_thm  
  val alpha_sym_thms = raw_prove_sym lthy5 alpha_result alpha_eqvt_norm
  val alpha_trans_thms =
    raw_prove_trans lthy5 alpha_result (raw_distinct_thms @ raw_inject_thms) alpha_eqvt_norm

  val (alpha_equivp_thms, alpha_bn_equivp_thms) = 
    raw_prove_equivp lthy5 alpha_result alpha_refl_thms alpha_sym_thms alpha_trans_thms

  val _ = trace_msg (K &quot;Proving alpha implies bn...&quot;)
  val alpha_bn_imp_thms = raw_prove_bn_imp lthy5 alpha_result

  val _ = trace_msg (K &quot;Proving respectfulness...&quot;)
  val raw_funs_rsp_aux = 
    raw_fv_bn_rsp_aux lthy5 alpha_result raw_fvs raw_bns raw_fv_bns (raw_bn_defs @ raw_fv_defs) 

  val raw_funs_rsp = map (Drule.eta_contraction_rule o mk_funs_rsp lthy5) raw_funs_rsp_aux

  fun match_const cnst th =
    (fst o dest_Const o snd o dest_comb o HOLogic.dest_Trueprop o Thm.prop_of) th =
    fst (dest_Const cnst);
  fun find_matching_rsp cnst =
    hd (filter (fn th =&gt; match_const cnst th) raw_funs_rsp);
  val raw_fv_rsp = map find_matching_rsp raw_fvs;
  val raw_bn_rsp = map find_matching_rsp raw_bns;
  val raw_fv_bn_rsp = map find_matching_rsp raw_fv_bns;

  val raw_size_rsp = 
    raw_size_rsp_aux lthy5 alpha_result (raw_size_thms @ raw_size_eqvt)
      |&gt; map (mk_funs_rsp lthy5)

  val raw_constrs_rsp = 
    raw_constrs_rsp lthy5 alpha_result raw_all_cns (alpha_bn_imp_thms @ raw_funs_rsp_aux) 
    
  val alpha_permute_rsp = map (mk_alpha_permute_rsp lthy5) alpha_eqvt

  val alpha_bn_rsp = 
    raw_alpha_bn_rsp alpha_result alpha_bn_equivp_thms alpha_bn_imp_thms

  val raw_perm_bn_rsp = raw_perm_bn_rsp lthy5 alpha_result raw_perm_bns raw_perm_bn_simps

  val _ = trace_msg (K &quot;Defining the quotient types...&quot;)
  val qty_descr = map (fn ((bind, vs, mx), _) =&gt; (map fst vs, bind, mx)) dts

  val (qty_infos, lthy7) =
    let
      val AlphaResult {alpha_trms, alpha_tys, ...} = alpha_result
    in
      define_qtypes qty_descr alpha_tys alpha_trms alpha_equivp_thms lthy5
    end

  val qtys = map #qtyp qty_infos
  val qty_full_names = map (fst o dest_Type) qtys
  val qty_names = map Long_Name.base_name qty_full_names

  val _ = trace_msg (K &quot;Defining the quotient constants...&quot;)
  val qconstrs_descrs =
    (map2 o map2) (fn (b, _, mx) =&gt; fn (t, th) =&gt; (Variable.check_name b, t, mx, th))
      (get_cnstrs dts) (map (op ~~) (raw_all_cns ~~ raw_constrs_rsp))

  val qbns_descr =
    map2 (fn (b, _, mx) =&gt; fn (t, th) =&gt; (Variable.check_name b, t, mx, th)) bn_funs (raw_bns ~~ raw_bn_rsp)

  val qfvs_descr =
    map2 (fn n =&gt; fn (t, th) =&gt; (&quot;fv_&quot; ^ n, t, NoSyn, th)) qty_names (raw_fvs ~~ raw_fv_rsp)

  val qfv_bns_descr =
    map2 (fn (b, _, _) =&gt; fn (t, th) =&gt; (&quot;fv_&quot; ^ Variable.check_name b, t, NoSyn, th))
      bn_funs (raw_fv_bns ~~ raw_fv_bn_rsp)

  val qalpha_bns_descr = 
    let
      val AlphaResult {alpha_bn_trms, ...} = alpha_result 
    in
      map2 (fn (b, _, _) =&gt; fn (t, th) =&gt; (&quot;alpha_&quot; ^ Variable.check_name b, t, NoSyn, th)) 
        bn_funs (alpha_bn_trms ~~ alpha_bn_rsp)
    end

  val qperm_descr =
    map2 (fn n =&gt; fn (t, th) =&gt; (&quot;permute_&quot; ^ n, Type.legacy_freeze t, NoSyn, th))
      qty_names (raw_perm_funs ~~ (take (length raw_perm_funs) alpha_permute_rsp))

  val qsize_descr =
    map2 (fn n =&gt; fn (t, th) =&gt; (&quot;size_&quot; ^ n, t, NoSyn, th)) qty_names
      (raw_size_trms ~~ (take (length raw_size_trms) raw_size_rsp))

  val qperm_bn_descr = 
    map2 (fn (b, _, _) =&gt; fn (t, th) =&gt; (&quot;permute_&quot; ^ Variable.check_name b, t, NoSyn, th))
      bn_funs (raw_perm_bns ~~ raw_perm_bn_rsp)

  val ((((((qconstrs_infos, qbns_info), qfvs_info), qfv_bns_info), qalpha_bns_info), qperm_bns_info), 
    lthy8) = 
      lthy7
      |&gt; fold_map (define_qconsts qtys) qconstrs_descrs 
      ||&gt;&gt; define_qconsts qtys qbns_descr 
      ||&gt;&gt; define_qconsts qtys qfvs_descr
      ||&gt;&gt; define_qconsts qtys qfv_bns_descr
      ||&gt;&gt; define_qconsts qtys qalpha_bns_descr
      ||&gt;&gt; define_qconsts qtys qperm_bn_descr

  val lthy9 = 
    define_qperms qtys qty_full_names raw_ty_args qperm_descr raw_perm_laws lthy8 
  
  val lthy9a = 
    define_qsizes qtys qty_full_names raw_ty_args qsize_descr lthy9

  val qtrms = (map o map) #qconst qconstrs_infos
  val qbns = map #qconst qbns_info
  val qfvs = map #qconst qfvs_info
  val qfv_bns = map #qconst qfv_bns_info
  val qalpha_bns = map #qconst qalpha_bns_info
  val qperm_bns = map #qconst qperm_bns_info

  val _ = trace_msg (K &quot;Lifting of theorems...&quot;)  
  val eq_iff_simps = @{thms alphas permute_prod.simps prod_fv.simps prod_alpha_def rel_prod_sel
    prod.case} 

  val ([ qdistincts, qeq_iffs, qfv_defs, qbn_defs, qperm_simps, qfv_qbn_eqvts, 
         qbn_inducts, qsize_eqvt, [qinduct], qexhausts, qsize_simps, qperm_bn_simps, 
         qalpha_refl_thms, qalpha_sym_thms, qalpha_trans_thms ], lthyB) = 
    lthy9a    
    |&gt;&gt;&gt; lift_thms qtys [] alpha_distincts  
    ||&gt;&gt;&gt; lift_thms qtys eq_iff_simps alpha_eq_iff       
    ||&gt;&gt;&gt; lift_thms qtys [] raw_fv_defs
    ||&gt;&gt;&gt; lift_thms qtys [] raw_bn_defs
    ||&gt;&gt;&gt; lift_thms qtys [] raw_perm_simps
    ||&gt;&gt;&gt; lift_thms qtys [] (raw_fv_eqvt @ raw_bn_eqvt)
    ||&gt;&gt;&gt; lift_thms qtys [] raw_bn_inducts
    ||&gt;&gt;&gt; lift_thms qtys [] raw_size_eqvt
    ||&gt;&gt;&gt; lift_thms qtys [] [raw_induct_thm]
    ||&gt;&gt;&gt; lift_thms qtys [] raw_exhaust_thms
    ||&gt;&gt;&gt; lift_thms qtys [] raw_size_thms
    ||&gt;&gt;&gt; lift_thms qtys [] raw_perm_bn_simps
    ||&gt;&gt;&gt; lift_thms qtys [] alpha_refl_thms
    ||&gt;&gt;&gt; lift_thms qtys [] alpha_sym_thms
    ||&gt;&gt;&gt; lift_thms qtys [] alpha_trans_thms

  val qinducts = Project_Rule.projections lthyB qinduct

  val _ = trace_msg (K &quot;Proving supp lemmas and fs-instances...&quot;)
  val qsupports_thms = prove_supports lthyB qperm_simps (flat qtrms)

  (* finite supp lemmas *)
  val qfsupp_thms = prove_fsupp lthyB qtys qinduct qsupports_thms

  (* fs instances *)
  val lthyC = fs_instance qtys qty_full_names raw_ty_args qfsupp_thms lthyB

  val _ = trace_msg (K &quot;Proving equality between fv and supp...&quot;)
  val qfv_supp_thms = 
    prove_fv_supp qtys (flat qtrms) qfvs qfv_bns qalpha_bns qfv_defs qeq_iffs 
      qperm_simps qfv_qbn_eqvts qinduct (flat raw_bclauses) lthyC
    |&gt; map Drule.eta_contraction_rule

  (* postprocessing of eq and fv theorems *)
  val qeq_iffs&#39; = qeq_iffs
    |&gt; map (simplify (put_simpset HOL_basic_ss lthyC addsimps qfv_supp_thms))
    |&gt; map (simplify (put_simpset HOL_basic_ss lthyC
        addsimps @{thms prod_fv_supp prod_alpha_eq Abs_eq_iff[symmetric]}))

  (* filters the theorems that are of the form &quot;qfv = supp&quot; *)
  val qfv_names = map (fst o dest_Const) qfvs
  fun is_qfv_thm (@{term Trueprop} $ (Const (@{const_name HOL.eq}, _) $ Const (lhs, _) $ _)) = 
    member (op=) qfv_names lhs
  | is_qfv_thm _ = false

  val qsupp_constrs = qfv_defs
    |&gt; map (simplify (put_simpset HOL_basic_ss lthyC
        addsimps (filter (is_qfv_thm o Thm.prop_of) qfv_supp_thms)))

  val transform_thm = @{lemma &quot;x = y &#10233; a &#8713; x &#10231; a &#8713; y&quot; by simp}
  val transform_thms = 
    [ @{lemma &quot;a &#8713; (S &#8746; T) &#10231; a &#8713; S &#8743; a &#8713; T&quot; by simp}, 
      @{lemma &quot;a &#8713; (S - T) &#10231; a &#8713; S &#8744; a &#8712; T&quot; by simp}, 
      @{lemma &quot;(lhs = (a &#8713; {})) &#10231; lhs&quot; by simp}, 
      @{thm fresh_def[symmetric]}]

  val qfresh_constrs = qsupp_constrs
    |&gt; map (fn thm =&gt; thm RS transform_thm) 
    |&gt; map (simplify (put_simpset HOL_basic_ss lthyC addsimps transform_thms))

  (* proving that the qbn result is finite *)
  val qbn_finite_thms = prove_bns_finite qtys qbns qinduct qbn_defs lthyC

  (* proving that perm_bns preserve alpha *)
  val qperm_bn_alpha_thms = 
    prove_perm_bn_alpha_thms qtys qperm_bns qalpha_bns qinduct qperm_bn_simps qeq_iffs&#39; 
      qalpha_refl_thms lthyC

  (* proving the relationship of bn and permute_bn *)
  val qpermute_bn_thms = 
    prove_permute_bn_thms qtys qbns qperm_bns qinduct qperm_bn_simps qbn_defs qfv_qbn_eqvts lthyC

  val _ = trace_msg (K &quot;Proving strong exhaust lemmas...&quot;)
  val qstrong_exhaust_thms = prove_strong_exhausts lthyC qexhausts bclauses qbn_finite_thms qeq_iffs&#39;
    qfv_qbn_eqvts qpermute_bn_thms qperm_bn_alpha_thms

  val _ = trace_msg (K &quot;Proving strong induct lemmas...&quot;)
  val qstrong_induct_thms =  prove_strong_induct lthyC qinduct qstrong_exhaust_thms qsize_simps bclauses

  (* noting the theorems *)  

  (* generating the prefix for the theorem names *)
  val thms_name = 
    the_default (Binding.name (space_implode &quot;_&quot; qty_names)) opt_thms_name 
  fun thms_suffix s = Binding.qualified true s thms_name 
  val case_names_attr = Attrib.internal (K (Rule_Cases.case_names cnstr_names))

  val infos = mk_infos qty_full_names qeq_iffs&#39; qdistincts qstrong_exhaust_thms qstrong_induct_thms

  val (_, lthy9&#39;) = lthyC
     |&gt; Local_Theory.declaration {syntax = false, pervasive = false} (K (fold register_info infos))
     |&gt; Local_Theory.note ((thms_suffix &quot;distinct&quot;, [induct_attr, simp_attr]), qdistincts) 
     ||&gt;&gt; Local_Theory.note ((thms_suffix &quot;eq_iff&quot;, [induct_attr, simp_attr]), qeq_iffs&#39;)
     ||&gt;&gt; Local_Theory.note ((thms_suffix &quot;fv_defs&quot;, []), qfv_defs) 
     ||&gt;&gt; Local_Theory.note ((thms_suffix &quot;bn_defs&quot;, []), qbn_defs) 
     ||&gt;&gt; Local_Theory.note ((thms_suffix &quot;bn_inducts&quot;, []), qbn_inducts) 
     ||&gt;&gt; Local_Theory.note ((thms_suffix &quot;perm_simps&quot;, [eqvt_attr, simp_attr]), qperm_simps) 
     ||&gt;&gt; Local_Theory.note ((thms_suffix &quot;fv_bn_eqvt&quot;, [eqvt_attr]), qfv_qbn_eqvts) 
     ||&gt;&gt; Local_Theory.note ((thms_suffix &quot;size&quot;, [simp_attr]), qsize_simps)
     ||&gt;&gt; Local_Theory.note ((thms_suffix &quot;size_eqvt&quot;, []), qsize_eqvt)
     ||&gt;&gt; Local_Theory.note ((thms_suffix &quot;induct&quot;, [case_names_attr]), [qinduct]) 
     ||&gt;&gt; Local_Theory.note ((thms_suffix &quot;inducts&quot;, [case_names_attr]), qinducts)
     ||&gt;&gt; Local_Theory.note ((thms_suffix &quot;exhaust&quot;, [case_names_attr]), qexhausts)
     ||&gt;&gt; Local_Theory.note ((thms_suffix &quot;strong_exhaust&quot;, [case_names_attr]), qstrong_exhaust_thms)
     ||&gt;&gt; Local_Theory.note ((thms_suffix &quot;strong_induct&quot;, [case_names_attr]), qstrong_induct_thms)
     ||&gt;&gt; Local_Theory.note ((thms_suffix &quot;supports&quot;, []), qsupports_thms)
     ||&gt;&gt; Local_Theory.note ((thms_suffix &quot;fsupp&quot;, []), qfsupp_thms)
     ||&gt;&gt; Local_Theory.note ((thms_suffix &quot;supp&quot;, []), qsupp_constrs)
     ||&gt;&gt; Local_Theory.note ((thms_suffix &quot;fresh&quot;, [simp_attr]), qfresh_constrs)
     ||&gt;&gt; Local_Theory.note ((thms_suffix &quot;perm_bn_simps&quot;, []), qperm_bn_simps)
     ||&gt;&gt; Local_Theory.note ((thms_suffix &quot;bn_finite&quot;, []), qbn_finite_thms)
     ||&gt;&gt; Local_Theory.note ((thms_suffix &quot;perm_bn_alpha&quot;, []), qperm_bn_alpha_thms)
     ||&gt;&gt; Local_Theory.note ((thms_suffix &quot;permute_bn&quot;, []), qpermute_bn_thms)
     ||&gt;&gt; Local_Theory.note ((thms_suffix &quot;alpha_refl&quot;, []), qalpha_refl_thms)
     ||&gt;&gt; Local_Theory.note ((thms_suffix &quot;alpha_sym&quot;, []), qalpha_sym_thms)
     ||&gt;&gt; Local_Theory.note ((thms_suffix &quot;alpha_trans&quot;, []), qalpha_trans_thms)
     
in
  lthy9&#39;
end 
*}</span><span class="">
</span><span class="">
</span><span class="">
</span><span class="keyword1">section</span><span class=""> </span><span class="verbatim">{* Preparing and parsing of the specification *}</span><span class="">
</span><span class="">
</span><span class="keyword1">ML</span><span class=""> </span><span class="verbatim">{*
(* adds the default sort @{sort fs} to nominal specifications *)

fun augment_sort thy S = Sign.inter_sort thy (@{sort fs}, S)

fun augment_sort_typ thy =
  map_type_tfree (fn (s, S) =&gt; TFree (s, augment_sort thy S))
*}</span><span class="">
</span><span class="">
</span><span class="keyword1">ML</span><span class=""> </span><span class="verbatim">{* 
(* generates the parsed datatypes and declares the constructors *)

fun prepare_dts dt_strs thy = 
let
  fun prep_spec ((tname, tvs, mx), constrs) =
    ((tname, tvs, mx), constrs |&gt; map (fn (c, atys, mx&#39;, _) =&gt; (c, map snd atys, mx&#39;)))

  val (dts, spec_ctxt) = 
    Old_Datatype.read_specs (map prep_spec dt_strs) thy
 
  fun augment ((tname, tvs, mx), constrs) =
    ((tname, map (apsnd (augment_sort thy)) tvs, mx), 
      constrs |&gt; map (fn (c, tys, mx&#39;) =&gt; (c, map (augment_sort_typ thy) tys, mx&#39;)))
  
  val dts&#39; = map augment dts

  fun mk_constr_trms ((tname, tvs, _), constrs) =
    let
      val ty = Type (Sign.full_name thy tname, map TFree tvs)
    in
      map (fn (c, tys, mx) =&gt; (c, (tys ---&gt; ty), mx)) constrs
    end

  val constr_trms = flat (map mk_constr_trms dts&#39;)
  
  (* FIXME: local version *)
  (* val (_, spec_ctxt&#39;) = Proof_Context.add_fixes constr_trms spec_ctxt *)

  val thy&#39; = Sign.add_consts constr_trms (Proof_Context.theory_of spec_ctxt)
in
  (dts&#39;, thy&#39;)
end
*}</span><span class="">
</span><span class="">
</span><span class="keyword1">ML</span><span class=""> </span><span class="verbatim">{*
(* parsing the binding function specifications and *)
(* declaring the function constants                *)
fun prepare_bn_funs bn_fun_strs bn_eq_strs thy =
let
  val lthy = Named_Target.theory_init thy

  val ((bn_funs, bn_eqs), lthy&#39;) = 
    Specification.read_spec bn_fun_strs bn_eq_strs lthy

  fun prep_bn_fun ((bn, T), mx) = (bn, T, mx) 
  
  val bn_funs&#39; = map prep_bn_fun bn_funs

in
  (Local_Theory.exit_global lthy&#39;)
  |&gt; Sign.add_consts bn_funs&#39;
  |&gt; pair (bn_funs&#39;, bn_eqs) 
end 
*}</span><span class="">
</span><span class="">
</span><span class="keyword1">text</span><span class=""> </span><span class="verbatim">{* associates every SOME with the index in the list; drops NONEs *}</span><span class="">
</span><span class="keyword1">ML</span><span class=""> </span><span class="verbatim">{*
fun indexify xs =
let
  fun mapp _ [] = []
    | mapp i (NONE :: xs) = mapp (i + 1) xs
    | mapp i (SOME x :: xs) = (x, i) :: mapp (i + 1) xs
in 
  mapp 0 xs 
end

fun index_lookup xs x =
  case AList.lookup (op=) xs x of
    SOME x =&gt; x
  | NONE =&gt; error (&quot;Cannot find &quot; ^ x ^ &quot; as argument annotation.&quot;);
*}</span><span class="">
</span><span class="">
</span><span class="keyword1">ML</span><span class=""> </span><span class="verbatim">{*
fun prepare_bclauses dt_strs thy = 
let
  val annos_bclauses =
    get_cnstrs dt_strs
    |&gt; (map o map) (fn (_, antys, _, bns) =&gt; (map fst antys, bns))

  fun prep_binder env bn_str =
    case (Syntax.read_term_global thy bn_str) of
      Free (x, _) =&gt; (NONE, index_lookup env x)
    | Const (a, T) $ Free (x, _) =&gt; (SOME (Const (a, T)), index_lookup env x)
    | _ =&gt; error (&quot;The term &quot; ^ bn_str ^ &quot; is not allowed as binding function.&quot;)
 
  fun prep_body env bn_str = index_lookup env bn_str

  fun prep_bclause env (mode, binders, bodies) = 
  let
    val binders&#39; = map (prep_binder env) binders
    val bodies&#39; = map (prep_body env) bodies
  in  
    BC (mode, binders&#39;, bodies&#39;)
  end

  fun prep_bclauses (annos, bclause_strs) = 
  let
    val env = indexify annos (* for every label, associate the index *)
  in
    map (prep_bclause env) bclause_strs
  end
in
  ((map o map) prep_bclauses annos_bclauses, thy)
end
*}</span><span class="">
</span><span class="">
</span><span class="keyword1">text</span><span class=""> </span><span class="verbatim">{* 
  adds an empty binding clause for every argument
  that is not already part of a binding clause
*}</span><span class="">
</span><span class="">
</span><span class="keyword1">ML</span><span class=""> </span><span class="verbatim">{*
fun included i bcs = 
let
  fun incl (BC (_, bns, bds)) = 
    member (op =) (map snd bns) i orelse member (op =) bds i
in
  exists incl bcs 
end
*}</span><span class="">
</span><span class="">
</span><span class="keyword1">ML</span><span class=""> </span><span class="verbatim">{* 
fun complete dt_strs bclauses = 
let
  val args = 
    get_cnstrs dt_strs
    |&gt; (map o map) (fn (_, antys, _, _) =&gt; length antys)

  fun complt n bcs = 
  let
    fun add bcs i = (if included i bcs then [] else [BC (Lst, [], [i])]) 
  in
    bcs @ (flat (map_range (add bcs) n))
  end
in
  (map2 o map2) complt args bclauses
end
*}</span><span class="">
</span><span class="">
</span><span class="keyword1">ML</span><span class=""> </span><span class="verbatim">{*
fun nominal_datatype2_cmd (opt_thms_name, dt_strs, bn_fun_strs, bn_eq_strs) lthy = 
let
  (* this theory is used just for parsing *)
  val thy = Proof_Context.theory_of lthy  

  val (((dts, (bn_funs, bn_eqs)), bclauses), _) = 
    thy
    |&gt; prepare_dts dt_strs 
    ||&gt;&gt; prepare_bn_funs bn_fun_strs bn_eq_strs 
    ||&gt;&gt; prepare_bclauses dt_strs

  val bclauses&#39; = complete dt_strs bclauses
in
  nominal_datatype2 opt_thms_name dts bn_funs bn_eqs bclauses&#39; lthy 
end
*}</span><span class="">
</span><span class="">
</span><span class="keyword1">ML</span><span class=""> </span><span class="verbatim">{* 
(* nominal datatype parser *)
local
  fun triple1 ((x, y), z) = (x, y, z)
  fun triple2 ((x, y), z) = (y, x, z)
  fun tuple2 (((x, y), z), u) = (x, y, u, z)
  fun tuple3 ((x, y), (z, u)) = (x, y, z, u)
in

val opt_name = Scan.option (Parse.binding --| Args.colon)

val anno_typ = Scan.option (Parse.name --| @{keyword &quot;::&quot;}) -- Parse.typ

val bind_mode = @{keyword &quot;binds&quot;} |--
  Scan.optional (Args.parens 
    (Args.$$$ &quot;list&quot; &gt;&gt; K Lst || (Args.$$$ &quot;set&quot; -- Args.$$$ &quot;+&quot;) &gt;&gt; K Res || Args.$$$ &quot;set&quot; &gt;&gt; K Set)) Lst

val bind_clauses = 
  Parse.enum &quot;,&quot; (bind_mode -- Scan.repeat1 Parse.term -- (@{keyword &quot;in&quot;} |-- Scan.repeat1 Parse.name) &gt;&gt; triple1)

val cnstr_parser =
  Parse.binding -- Scan.repeat anno_typ -- bind_clauses -- Parse.opt_mixfix &gt;&gt; tuple2

(* datatype parser *)
val dt_parser =
  (Parse.type_args_constrained -- Parse.binding -- Parse.opt_mixfix &gt;&gt; triple2) -- 
    (@{keyword &quot;=&quot;} |-- Parse.enum1 &quot;|&quot; cnstr_parser)

(* binding function parser *)
val bnfun_parser = 
  Scan.optional (@{keyword &quot;binder&quot;} |-- Parse.fixes -- Parse_Spec.where_alt_specs) ([], [])

(* main parser *)
val main_parser =
  opt_name -- Parse.and_list1 dt_parser -- bnfun_parser &gt;&gt; tuple3

end

(* Command Keyword *)
val _ = Outer_Syntax.local_theory @{command_keyword nominal_datatype}
  &quot;declaration of nominal datatypes&quot; 
    (main_parser &gt;&gt; nominal_datatype2_cmd)
*}</span><span class="">
</span><span class="">
</span><span class="keyword2">end</span><span class="">
</span></pre>

</div>
</body>
</html>
