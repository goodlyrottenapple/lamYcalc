<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>Theory Multiset (Isabelle2016: February 2016)</title>
<link media="all" rel="stylesheet" type="text/css" href="isabelle.css"/>
</head>

<body>
<div class="head"><h1>Theory Multiset</h1>

<span class="command">theory</span> <span class="name">Multiset</span><br/>
<span class="keyword">imports</span> <a href="../../HOL/HOL/Main.html"><span class="name">Main</span></a><br/>

</div>
<div class="source">
<pre class="source"><span class="comment">(*  Title:      HOL/Library/Multiset.thy
    Author:     Tobias Nipkow, Markus Wenzel, Lawrence C Paulson, Norbert Voelker
    Author:     Andrei Popescu, TU Muenchen
    Author:     Jasmin Blanchette, Inria, LORIA, MPII
    Author:     Dmitriy Traytel, TU Muenchen
    Author:     Mathias Fleury, MPII
*)</span><span class="">
</span><span class="">
</span><span class="keyword1">section</span><span class=""> </span><span class="cartouche">&#8249;(Finite) multisets&#8250;</span><span class="">
</span><span class="">
</span><span class="keyword1">theory</span><span class=""> </span><span class="">Multiset</span><span class="">
</span><span class="keyword2">imports</span><span class=""> </span><span class="">Main</span><span class="">
</span><span class="keyword2">begin</span><span class="">
</span><span class="">
</span><span class="keyword1">subsection</span><span class=""> </span><span class="cartouche">&#8249;The type of multisets&#8250;</span><span class="">
</span><span class="">
</span><span class="keyword1">definition</span><span class=""> </span><span class="string">&quot;multiset = {f :: &#39;a &#8658; nat. finite {x. f x &gt; 0}}&quot;</span><span class="">
</span><span class="">
</span><span class="keyword1">typedef</span><span class=""> </span><span class="tfree">&#39;a</span><span class=""> </span><span class="">multiset</span><span class=""> </span><span class="delimiter">=</span><span class=""> </span><span class="string">&quot;multiset :: (&#39;a &#8658; nat) set&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">morphisms</span><span class=""> </span><span class="">count</span><span class=""> </span><span class="">Abs_multiset</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">multiset_def</span><span class="">
</span><span class="keyword1">proof</span><span class="">
</span><span class="">  </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;(&#955;x. 0::nat) &#8712; {f. finite {x. f x &gt; 0}}&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="keyword1">setup_lifting</span><span class=""> </span><span class="">type_definition_multiset</span><span class="">
</span><span class="">
</span><span class="keyword1">abbreviation</span><span class=""> </span><span class="">Melem</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;&#39;a &#8658; &#39;a multiset &#8658; bool&quot;</span><span class="">  </span><span class="delimiter">(</span><span class="keyword2">infix</span><span class=""> </span><span class="string">&quot;&#8712;#&quot;</span><span class=""> </span><span class="">50</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword2">where</span><span class=""> </span><span class="string">&quot;a &#8712;# M &#8801; 0 &lt; count M a&quot;</span><span class="">
</span><span class="">
</span><span class="keyword1">notation</span><span class=""> </span><span class="delimiter">(</span><span class="">ASCII</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="">Melem</span><span class="">  </span><span class="delimiter">(</span><span class="string">&quot;(_/ :# _)&quot;</span><span class=""> </span><span class="delimiter">[</span><span class="">50</span><span class="delimiter">,</span><span class=""> </span><span class="">51</span><span class="delimiter">]</span><span class=""> </span><span class="">50</span><span class="delimiter">)</span><span class="">  </span><span class="comment">(* FIXME !? *)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">multiset_eq_iff</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;M = N &#10231; (&#8704;a. count M a = count N a)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">only</span><span class="delimiter">:</span><span class=""> </span><span class="">count_inject</span><span class=""> </span><span class="delimiter">[</span><span class="">symmetric</span><span class="delimiter">]</span><span class=""> </span><span class="">fun_eq_iff</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">multiset_eqI</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;(&#8896;x. count A x = count B x) &#10233; A = B&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">using</span><span class=""> </span><span class="">multiset_eq_iff</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">
</span><span class="keyword1">text</span><span class=""> </span><span class="cartouche">&#8249;Preservation of the representing set @{term multiset}.&#8250;</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">const0_in_multiset</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;(&#955;a. 0) &#8712; multiset&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">multiset_def</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">only1_in_multiset</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;(&#955;b. if b = a then n else 0) &#8712; multiset&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">multiset_def</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">union_preserves_multiset</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;M &#8712; multiset &#10233; N &#8712; multiset &#10233; (&#955;a. M a + N a) &#8712; multiset&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">multiset_def</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">diff_preserves_multiset</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="string">&quot;M &#8712; multiset&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;(&#955;a. M a - N a) &#8712; multiset&quot;</span><span class="">
</span><span class="keyword1">proof</span><span class=""> </span><span class="">-</span><span class="">
</span><span class="">  </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;{x. N x &lt; M x} &#8838; {x. 0 &lt; M x}&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">  </span><span class="keyword1">with</span><span class=""> </span><span class="">assms</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="var">?thesis</span><span class="">
</span><span class="">    </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">multiset_def</span><span class=""> </span><span class="">intro</span><span class="delimiter">:</span><span class=""> </span><span class="">finite_subset</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">filter_preserves_multiset</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="string">&quot;M &#8712; multiset&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;(&#955;x. if P x then M x else 0) &#8712; multiset&quot;</span><span class="">
</span><span class="keyword1">proof</span><span class=""> </span><span class="">-</span><span class="">
</span><span class="">  </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;{x. (P x &#10230; 0 &lt; M x) &#8743; P x} &#8838; {x. 0 &lt; M x}&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">  </span><span class="keyword1">with</span><span class=""> </span><span class="">assms</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="var">?thesis</span><span class="">
</span><span class="">    </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">multiset_def</span><span class=""> </span><span class="">intro</span><span class="delimiter">:</span><span class=""> </span><span class="">finite_subset</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="keyword1">lemmas</span><span class=""> </span><span class="">in_multiset</span><span class=""> </span><span class="delimiter">=</span><span class=""> </span><span class="">const0_in_multiset</span><span class=""> </span><span class="">only1_in_multiset</span><span class="">
</span><span class="">  </span><span class="">union_preserves_multiset</span><span class=""> </span><span class="">diff_preserves_multiset</span><span class=""> </span><span class="">filter_preserves_multiset</span><span class="">
</span><span class="">
</span><span class="">
</span><span class="keyword1">subsection</span><span class=""> </span><span class="cartouche">&#8249;Representing multisets&#8250;</span><span class="">
</span><span class="">
</span><span class="keyword1">text</span><span class=""> </span><span class="cartouche">&#8249;Multiset enumeration&#8250;</span><span class="">
</span><span class="">
</span><span class="keyword1">instantiation</span><span class=""> </span><span class="">multiset</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="delimiter">(</span><span class="">type</span><span class="delimiter">)</span><span class=""> </span><span class="">cancel_comm_monoid_add</span><span class="">
</span><span class="keyword2">begin</span><span class="">
</span><span class="">
</span><span class="keyword1">lift_definition</span><span class=""> </span><span class="">zero_multiset</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;&#39;a multiset&quot;</span><span class=""> </span><span class="keyword2">is</span><span class=""> </span><span class="string">&quot;&#955;a. 0&quot;</span><span class="">
</span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">const0_in_multiset</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">abbreviation</span><span class=""> </span><span class="">Mempty</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;&#39;a multiset&quot;</span><span class=""> </span><span class="delimiter">(</span><span class="string">&quot;{#}&quot;</span><span class="delimiter">)</span><span class=""> </span><span class="keyword2">where</span><span class="">
</span><span class="">  </span><span class="string">&quot;Mempty &#8801; 0&quot;</span><span class="">
</span><span class="">
</span><span class="keyword1">lift_definition</span><span class=""> </span><span class="">plus_multiset</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;&#39;a multiset &#8658; &#39;a multiset &#8658; &#39;a multiset&quot;</span><span class=""> </span><span class="keyword2">is</span><span class=""> </span><span class="string">&quot;&#955;M N. (&#955;a. M a + N a)&quot;</span><span class="">
</span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">union_preserves_multiset</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lift_definition</span><span class=""> </span><span class="">minus_multiset</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;&#39;a multiset &#8658; &#39;a multiset &#8658; &#39;a multiset&quot;</span><span class=""> </span><span class="keyword2">is</span><span class=""> </span><span class="string">&quot;&#955; M N. &#955;a. M a - N a&quot;</span><span class="">
</span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">diff_preserves_multiset</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">instance</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">standard</span><span class="delimiter">;</span><span class=""> </span><span class="">transfer</span><span class="delimiter">;</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">fun_eq_iff</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword2">end</span><span class="">
</span><span class="">
</span><span class="keyword1">lift_definition</span><span class=""> </span><span class="">single</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;&#39;a &#8658; &#39;a multiset&quot;</span><span class=""> </span><span class="keyword2">is</span><span class=""> </span><span class="string">&quot;&#955;a b. if b = a then 1 else 0&quot;</span><span class="">
</span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">only1_in_multiset</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">syntax</span><span class="">
</span><span class="">  </span><span class="string">&quot;_multiset&quot;</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;args &#8658; &#39;a multiset&quot;</span><span class="">    </span><span class="delimiter">(</span><span class="string">&quot;{#(_)#}&quot;</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1">translations</span><span class="">
</span><span class="">  </span><span class="string">&quot;{#x, xs#}&quot;</span><span class=""> </span><span class="delimiter">==</span><span class=""> </span><span class="string">&quot;{#x#} + {#xs#}&quot;</span><span class="">
</span><span class="">  </span><span class="string">&quot;{#x#}&quot;</span><span class=""> </span><span class="delimiter">==</span><span class=""> </span><span class="string">&quot;CONST single x&quot;</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">count_empty</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;count {#} a = 0&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">zero_multiset.rep_eq</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">count_single</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;count {#b#} a = (if b = a then 1 else 0)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">single.rep_eq</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="">
</span><span class="keyword1">subsection</span><span class=""> </span><span class="cartouche">&#8249;Basic operations&#8250;</span><span class="">
</span><span class="">
</span><span class="keyword1">subsubsection</span><span class=""> </span><span class="cartouche">&#8249;Union&#8250;</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">count_union</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;count (M + N) a = count M a + count N a&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">plus_multiset.rep_eq</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="">
</span><span class="keyword1">subsubsection</span><span class=""> </span><span class="cartouche">&#8249;Difference&#8250;</span><span class="">
</span><span class="">
</span><span class="keyword1">instantiation</span><span class=""> </span><span class="">multiset</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="delimiter">(</span><span class="">type</span><span class="delimiter">)</span><span class=""> </span><span class="">comm_monoid_diff</span><span class="">
</span><span class="keyword2">begin</span><span class="">
</span><span class="">
</span><span class="keyword1">instance</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">standard</span><span class="delimiter">;</span><span class=""> </span><span class="">transfer</span><span class="delimiter">;</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">fun_eq_iff</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword2">end</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">count_diff</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;count (M - N) a = count M a - count N a&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">minus_multiset.rep_eq</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">diff_empty</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;M - {#} = M &#8743; {#} - M = {#}&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="">rule</span><span class=""> </span><span class="delimiter">(</span><span class="">fact</span><span class=""> </span><span class="">Groups.diff_zero</span><span class="delimiter">,</span><span class=""> </span><span class="">fact</span><span class=""> </span><span class="">Groups.zero_diff</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">diff_cancel</span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;A - A = {#}&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">fact</span><span class=""> </span><span class="">Groups.diff_cancel</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">diff_union_cancelR</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;M + N - N = (M::&#39;a multiset)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">fact</span><span class=""> </span><span class="">add_diff_cancel_right&#39;</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">diff_union_cancelL</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;N + M - N = (M::&#39;a multiset)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">fact</span><span class=""> </span><span class="">add_diff_cancel_left&#39;</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">diff_right_commute</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">fixes</span><span class=""> </span><span class="">M</span><span class=""> </span><span class="">N</span><span class=""> </span><span class="">Q</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;&#39;a multiset&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;M - N - Q = M - Q - N&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">fact</span><span class=""> </span><span class="">diff_right_commute</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">diff_add</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">fixes</span><span class=""> </span><span class="">M</span><span class=""> </span><span class="">N</span><span class=""> </span><span class="">Q</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;&#39;a multiset&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;M - (N + Q) = M - N - Q&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">sym</span><span class="delimiter">)</span><span class=""> </span><span class="delimiter">(</span><span class="">fact</span><span class=""> </span><span class="">diff_diff_add</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">insert_DiffM</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;x &#8712;# M &#10233; {#x#} + (M - {#x#}) = M&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">clarsimp</span><span class=""> </span><span class="">simp</span><span class="delimiter">:</span><span class=""> </span><span class="">multiset_eq_iff</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">insert_DiffM2</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;x &#8712;# M &#10233; M - {#x#} + {#x#} = M&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">clarsimp</span><span class=""> </span><span class="">simp</span><span class="delimiter">:</span><span class=""> </span><span class="">multiset_eq_iff</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">diff_union_swap</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;a &#8800; b &#10233; M - {#a#} + {#b#} = M + {#b#} - {#a#}&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">multiset_eq_iff</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">diff_union_single_conv</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;a &#8712;# J &#10233; I + J - {#a#} = I + (J - {#a#})&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">multiset_eq_iff</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="">
</span><span class="keyword1">subsubsection</span><span class=""> </span><span class="cartouche">&#8249;Equality of multisets&#8250;</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">single_not_empty</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;{#a#} &#8800; {#} &#8743; {#} &#8800; {#a#}&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">multiset_eq_iff</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">single_eq_single</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;{#a#} = {#b#} &#10231; a = b&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">multiset_eq_iff</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">union_eq_empty</span><span class=""> </span><span class="delimiter">[</span><span class="">iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;M + N = {#} &#10231; M = {#} &#8743; N = {#}&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">multiset_eq_iff</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">empty_eq_union</span><span class=""> </span><span class="delimiter">[</span><span class="">iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;{#} = M + N &#10231; M = {#} &#8743; N = {#}&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">multiset_eq_iff</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">multi_self_add_other_not_self</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;M = M + {#x#} &#10231; False&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">multiset_eq_iff</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">diff_single_trivial</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;&#172; x &#8712;# M &#10233; M - {#x#} = M&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">multiset_eq_iff</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">diff_single_eq_union</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;x &#8712;# M &#10233; M - {#x#} = N &#10231; M = N + {#x#}&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">union_single_eq_diff</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;M + {#x#} = N &#10233; M = N - {#x#}&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">dest</span><span class="delimiter">:</span><span class=""> </span><span class="">sym</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">union_single_eq_member</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;M + {#x#} = N &#10233; x &#8712;# N&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">union_is_single</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;M + N = {#a#} &#10231; M = {#a#} &#8743; N={#} &#8744; M = {#} &#8743; N = {#a#}&quot;</span><span class="">
</span><span class="">  </span><span class="delimiter">(</span><span class="keyword2">is</span><span class=""> </span><span class="string">&quot;?lhs = ?rhs&quot;</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1">proof</span><span class="">
</span><span class="">  </span><span class="keyword3">show</span><span class=""> </span><span class="var">?lhs</span><span class=""> </span><span class="keyword2">if</span><span class=""> </span><span class="var">?rhs</span><span class=""> </span><span class="keyword1">using</span><span class=""> </span><span class="">that</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">  </span><span class="keyword3">show</span><span class=""> </span><span class="var">?rhs</span><span class=""> </span><span class="keyword2">if</span><span class=""> </span><span class="var">?lhs</span><span class="">
</span><span class="">    </span><span class="keyword1">using</span><span class=""> </span><span class="">that</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">multiset_eq_iff</span><span class=""> </span><span class="">split</span><span class="delimiter">:</span><span class=""> </span><span class="">if_splits</span><span class="delimiter">)</span><span class=""> </span><span class="delimiter">(</span><span class="">metis</span><span class=""> </span><span class="">add_is_1</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">single_is_union</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;{#a#} = M + N &#10231; {#a#} = M &#8743; N = {#} &#8744; M = {#} &#8743; {#a#} = N&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">eq_commute</span><span class=""> </span><span class="delimiter">[</span><span class="">of</span><span class=""> </span><span class="string">&quot;{#a#}&quot;</span><span class=""> </span><span class="string">&quot;M + N&quot;</span><span class="delimiter">]</span><span class=""> </span><span class="">union_is_single</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">add_eq_conv_diff</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="string">&quot;M + {#a#} = N + {#b#} &#10231; M = N &#8743; a = b &#8744; M = N - {#a#} + {#b#} &#8743; N = M - {#b#} + {#a#}&quot;</span><span class="">
</span><span class="">  </span><span class="delimiter">(</span><span class="keyword2">is</span><span class=""> </span><span class="string">&quot;?lhs &#10231; ?rhs&quot;</span><span class="delimiter">)</span><span class="">
</span><span class="comment">(* shorter: by (simp add: multiset_eq_iff) fastforce *)</span><span class="">
</span><span class="keyword1">proof</span><span class="">
</span><span class="">  </span><span class="keyword3">show</span><span class=""> </span><span class="var">?lhs</span><span class=""> </span><span class="keyword2">if</span><span class=""> </span><span class="var">?rhs</span><span class="">
</span><span class="">    </span><span class="keyword1">using</span><span class=""> </span><span class="">that</span><span class="">
</span><span class="">    </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">add.assoc</span><span class=""> </span><span class="">add.commute</span><span class=""> </span><span class="delimiter">[</span><span class="">of</span><span class=""> </span><span class="string">&quot;{#b#}&quot;</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="">
</span><span class="">      </span><span class="delimiter">(</span><span class="">drule</span><span class=""> </span><span class="">sym</span><span class="delimiter">,</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">add.assoc</span><span class=""> </span><span class="delimiter">[</span><span class="">symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword3">show</span><span class=""> </span><span class="var">?rhs</span><span class=""> </span><span class="keyword2">if</span><span class=""> </span><span class="var">?lhs</span><span class="">
</span><span class="">  </span><span class="keyword1">proof</span><span class=""> </span><span class="delimiter">(</span><span class="">cases</span><span class=""> </span><span class="string">&quot;a = b&quot;</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword3">case</span><span class=""> </span><span class="">True</span><span class=""> </span><span class="keyword1">with</span><span class=""> </span><span class="cartouche">&#8249;?lhs&#8250;</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="var">?thesis</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">  </span><span class="keyword1">next</span><span class="">
</span><span class="">    </span><span class="keyword3">case</span><span class=""> </span><span class="">False</span><span class="">
</span><span class="">    </span><span class="keyword1">from</span><span class=""> </span><span class="cartouche">&#8249;?lhs&#8250;</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;a &#8712;# N + {#b#}&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">union_single_eq_member</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1">with</span><span class=""> </span><span class="">False</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;a &#8712;# N&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">    </span><span class="keyword1">moreover</span><span class=""> </span><span class="keyword1">from</span><span class=""> </span><span class="cartouche">&#8249;?lhs&#8250;</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;M = N + {#b#} - {#a#}&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">union_single_eq_diff</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1">moreover</span><span class=""> </span><span class="keyword1">note</span><span class=""> </span><span class="">False</span><span class="">
</span><span class="">    </span><span class="keyword1">ultimately</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="var">?thesis</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">diff_right_commute</span><span class=""> </span><span class="delimiter">[</span><span class="">of</span><span class=""> </span><span class="">_</span><span class=""> </span><span class="string">&quot;{#a#}&quot;</span><span class="delimiter">]</span><span class=""> </span><span class="">diff_union_swap</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">qed</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">insert_noteq_member</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="">BC</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;B + {#b#} = C + {#c#}&quot;</span><span class="">
</span><span class="">   </span><span class="keyword2">and</span><span class=""> </span><span class="">bnotc</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;b &#8800; c&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;c &#8712;# B&quot;</span><span class="">
</span><span class="keyword1">proof</span><span class=""> </span><span class="">-</span><span class="">
</span><span class="">  </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;c &#8712;# C + {#c#}&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">  </span><span class="keyword1">have</span><span class=""> </span><span class="">nc</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;&#172; c &#8712;# {#b#}&quot;</span><span class=""> </span><span class="keyword1">using</span><span class=""> </span><span class="">bnotc</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">  </span><span class="keyword1">then</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;c &#8712;# B + {#b#}&quot;</span><span class=""> </span><span class="keyword1">using</span><span class=""> </span><span class="">BC</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">  </span><span class="keyword1">then</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;c &#8712;# B&quot;</span><span class=""> </span><span class="keyword1">using</span><span class=""> </span><span class="">nc</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">add_eq_conv_ex</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="string">&quot;(M + {#a#} = N + {#b#}) =
    (M = N &#8743; a = b &#8744; (&#8707;K. M = K + {#b#} &#8743; N = K + {#a#}))&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">add_eq_conv_diff</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">multi_member_split</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;x &#8712;# M &#10233; &#8707;A. M = A + {#x#}&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">exI</span><span class=""> </span><span class="delimiter">[</span><span class="keyword2">where</span><span class=""> </span><span class="">x</span><span class=""> </span><span class="delimiter">=</span><span class=""> </span><span class="string">&quot;M - {#x#}&quot;</span><span class="delimiter">]</span><span class="delimiter">)</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">multiset_add_sub_el_shuffle</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="string">&quot;c &#8712;# B&quot;</span><span class="">
</span><span class="">    </span><span class="keyword2">and</span><span class=""> </span><span class="string">&quot;b &#8800; c&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;B - {#c#} + {#b#} = B + {#b#} - {#c#}&quot;</span><span class="">
</span><span class="keyword1">proof</span><span class=""> </span><span class="">-</span><span class="">
</span><span class="">  </span><span class="keyword1">from</span><span class=""> </span><span class="cartouche">&#8249;c &#8712;# B&#8250;</span><span class=""> </span><span class="keyword3">obtain</span><span class=""> </span><span class="">A</span><span class=""> </span><span class="keyword2">where</span><span class=""> </span><span class="">B</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;B = A + {#c#}&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">blast</span><span class=""> </span><span class="">dest</span><span class="delimiter">:</span><span class=""> </span><span class="">multi_member_split</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;A + {#b#} = A + {#b#} + {#c#} - {#c#}&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">  </span><span class="keyword1">then</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;A + {#b#} = A + {#c#} + {#b#} - {#c#}&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">ac_simps</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">then</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="var">?thesis</span><span class=""> </span><span class="keyword1">using</span><span class=""> </span><span class="">B</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="">
</span><span class="keyword1">subsubsection</span><span class=""> </span><span class="cartouche">&#8249;Pointwise ordering induced by count&#8250;</span><span class="">
</span><span class="">
</span><span class="keyword1">definition</span><span class=""> </span><span class="">subseteq_mset</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;&#39;a multiset &#8658; &#39;a multiset &#8658; bool&quot;</span><span class="">  </span><span class="delimiter">(</span><span class="keyword2">infix</span><span class=""> </span><span class="string">&quot;&#8838;#&quot;</span><span class=""> </span><span class="">50</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword2">where</span><span class=""> </span><span class="string">&quot;A &#8838;# B = (&#8704;a. count A a &#8804; count B a)&quot;</span><span class="">
</span><span class="">
</span><span class="keyword1">definition</span><span class=""> </span><span class="">subset_mset</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;&#39;a multiset &#8658; &#39;a multiset &#8658; bool&quot;</span><span class=""> </span><span class="delimiter">(</span><span class="keyword2">infix</span><span class=""> </span><span class="string">&quot;&#8834;#&quot;</span><span class=""> </span><span class="">50</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword2">where</span><span class=""> </span><span class="string">&quot;A &#8834;# B = (A &#8838;# B &#8743; A &#8800; B)&quot;</span><span class="">
</span><span class="">
</span><span class="keyword1">abbreviation</span><span class=""> </span><span class="delimiter">(</span><span class="">input</span><span class="delimiter">)</span><span class=""> </span><span class="">supseteq_mset</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;&#39;a multiset &#8658; &#39;a multiset &#8658; bool&quot;</span><span class=""> </span><span class="keyword2">where</span><span class="">
</span><span class="">  </span><span class="string">&quot;supseteq_mset A B == B &#8838;# A&quot;</span><span class="">
</span><span class="">
</span><span class="keyword1">abbreviation</span><span class=""> </span><span class="delimiter">(</span><span class="">input</span><span class="delimiter">)</span><span class=""> </span><span class="">supset_mset</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;&#39;a multiset &#8658; &#39;a multiset &#8658; bool&quot;</span><span class=""> </span><span class="keyword2">where</span><span class="">
</span><span class="">  </span><span class="string">&quot;supset_mset A B == B &#8834;# A&quot;</span><span class="">
</span><span class="">
</span><span class="keyword1">notation</span><span class=""> </span><span class="delimiter">(</span><span class="">input</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="">subseteq_mset</span><span class="">  </span><span class="delimiter">(</span><span class="keyword2">infix</span><span class=""> </span><span class="string">&quot;&#8804;#&quot;</span><span class=""> </span><span class="">50</span><span class="delimiter">)</span><span class=""> </span><span class="keyword2">and</span><span class="">
</span><span class="">  </span><span class="">supseteq_mset</span><span class="">  </span><span class="delimiter">(</span><span class="keyword2">infix</span><span class=""> </span><span class="string">&quot;&#8805;#&quot;</span><span class=""> </span><span class="">50</span><span class="delimiter">)</span><span class=""> </span><span class="keyword2">and</span><span class="">
</span><span class="">  </span><span class="">supseteq_mset</span><span class="">  </span><span class="delimiter">(</span><span class="keyword2">infix</span><span class=""> </span><span class="string">&quot;&#8839;#&quot;</span><span class=""> </span><span class="">50</span><span class="delimiter">)</span><span class=""> </span><span class="keyword2">and</span><span class="">
</span><span class="">  </span><span class="">supset_mset</span><span class="">  </span><span class="delimiter">(</span><span class="keyword2">infix</span><span class=""> </span><span class="string">&quot;&#8835;#&quot;</span><span class=""> </span><span class="">50</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">notation</span><span class=""> </span><span class="delimiter">(</span><span class="">ASCII</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="">subseteq_mset</span><span class="">  </span><span class="delimiter">(</span><span class="keyword2">infix</span><span class=""> </span><span class="string">&quot;&lt;=#&quot;</span><span class=""> </span><span class="">50</span><span class="delimiter">)</span><span class=""> </span><span class="keyword2">and</span><span class="">
</span><span class="">  </span><span class="">subset_mset</span><span class="">  </span><span class="delimiter">(</span><span class="keyword2">infix</span><span class=""> </span><span class="string">&quot;&lt;#&quot;</span><span class=""> </span><span class="">50</span><span class="delimiter">)</span><span class=""> </span><span class="keyword2">and</span><span class="">
</span><span class="">  </span><span class="">supseteq_mset</span><span class="">  </span><span class="delimiter">(</span><span class="keyword2">infix</span><span class=""> </span><span class="string">&quot;&gt;=#&quot;</span><span class=""> </span><span class="">50</span><span class="delimiter">)</span><span class=""> </span><span class="keyword2">and</span><span class="">
</span><span class="">  </span><span class="">supset_mset</span><span class="">  </span><span class="delimiter">(</span><span class="keyword2">infix</span><span class=""> </span><span class="string">&quot;&gt;#&quot;</span><span class=""> </span><span class="">50</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">interpretation</span><span class=""> </span><span class="">subset_mset</span><span class="delimiter">:</span><span class=""> </span><span class="">ordered_ab_semigroup_add_imp_le</span><span class=""> </span><span class="string">&quot;op +&quot;</span><span class=""> </span><span class="string">&quot;op -&quot;</span><span class=""> </span><span class="string">&quot;op &#8838;#&quot;</span><span class=""> </span><span class="string">&quot;op &#8834;#&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="">standard</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">subset_mset_def</span><span class=""> </span><span class="">subseteq_mset_def</span><span class=""> </span><span class="">multiset_eq_iff</span><span class=""> </span><span class="">intro</span><span class="delimiter">:</span><span class=""> </span><span class="">order_trans</span><span class=""> </span><span class="">antisym</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">mset_less_eqI</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;(&#8896;x. count A x &#8804; count B x) &#10233; A &#8804;# B&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">subseteq_mset_def</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">mset_le_exists_conv</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;(A::&#39;a multiset) &#8804;# B &#10231; (&#8707;C. B = A + C)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">subseteq_mset_def</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">iffI</span><span class="delimiter">)</span><span class="">
</span><span class="">   </span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">exI</span><span class=""> </span><span class="delimiter">[</span><span class="keyword2">where</span><span class=""> </span><span class="">x</span><span class=""> </span><span class="delimiter">=</span><span class=""> </span><span class="string">&quot;B - A&quot;</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="">
</span><span class="">   </span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">intro</span><span class="delimiter">:</span><span class=""> </span><span class="">multiset_eq_iff</span><span class=""> </span><span class="delimiter">[</span><span class="">THEN</span><span class=""> </span><span class="">iffD2</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">done</span></span><span class="">
</span><span class="">
</span><span class="keyword1">interpretation</span><span class=""> </span><span class="">subset_mset</span><span class="delimiter">:</span><span class=""> </span><span class="">ordered_cancel_comm_monoid_diff</span><span class="">  </span><span class="string">&quot;op +&quot;</span><span class=""> </span><span class="string">&quot;op -&quot;</span><span class=""> </span><span class="">0</span><span class=""> </span><span class="string">&quot;op &#8804;#&quot;</span><span class=""> </span><span class="string">&quot;op &lt;#&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="">standard</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class="delimiter">,</span><span class=""> </span><span class="">fact</span><span class=""> </span><span class="">mset_le_exists_conv</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">mset_le_mono_add_right_cancel</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;(A::&#39;a multiset) + C &#8804;# B + C &#10231; A &#8804;# B&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">fact</span><span class=""> </span><span class="">subset_mset.add_le_cancel_right</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">mset_le_mono_add_left_cancel</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;C + (A::&#39;a multiset) &#8804;# C + B &#10231; A &#8804;# B&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">fact</span><span class=""> </span><span class="">subset_mset.add_le_cancel_left</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">mset_le_mono_add</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;(A::&#39;a multiset) &#8804;# B &#10233; C &#8804;# D &#10233; A + C &#8804;# B + D&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">fact</span><span class=""> </span><span class="">subset_mset.add_mono</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">mset_le_add_left</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;(A::&#39;a multiset) &#8804;# A + B&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">subseteq_mset_def</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">mset_le_add_right</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;B &#8804;# (A::&#39;a multiset) + B&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">subseteq_mset_def</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">mset_le_single</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;a &#8712;# B &#10233; {#a#} &#8804;# B&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">subseteq_mset_def</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">multiset_diff_union_assoc</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">fixes</span><span class=""> </span><span class="">A</span><span class=""> </span><span class="">B</span><span class=""> </span><span class="">C</span><span class=""> </span><span class="">D</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;&#39;a multiset&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;C &#8804;# B &#10233; A + B - C = A + (B - C)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">subset_mset.diff_add_assoc</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">mset_le_multiset_union_diff_commute</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">fixes</span><span class=""> </span><span class="">A</span><span class=""> </span><span class="">B</span><span class=""> </span><span class="">C</span><span class=""> </span><span class="">D</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;&#39;a multiset&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;B &#8804;# A &#10233; A - B + C = A + C - B&quot;</span><span class="">
</span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">subset_mset.add_diff_assoc2</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">diff_le_self</span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;(M::&#39;a multiset) - N &#8804;# M&quot;</span><span class="">
</span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">subseteq_mset_def</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">mset_lessD</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;A &lt;# B &#10233; x &#8712;# A &#10233; x &#8712;# B&quot;</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">clarsimp</span><span class=""> </span><span class="">simp</span><span class="delimiter">:</span><span class=""> </span><span class="">subset_mset_def</span><span class=""> </span><span class="">subseteq_mset_def</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">erule</span><span class=""> </span><span class="">allE</span><span class=""> </span><span class="delimiter">[</span><span class="keyword2">where</span><span class=""> </span><span class="">x</span><span class=""> </span><span class="delimiter">=</span><span class=""> </span><span class="">x</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="keyword1"><span class="improper">done</span></span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">mset_leD</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;A &#8804;# B &#10233; x &#8712;# A &#10233; x &#8712;# B&quot;</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">clarsimp</span><span class=""> </span><span class="">simp</span><span class="delimiter">:</span><span class=""> </span><span class="">subset_mset_def</span><span class=""> </span><span class="">subseteq_mset_def</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">erule</span><span class=""> </span><span class="">allE</span><span class=""> </span><span class="delimiter">[</span><span class="keyword2">where</span><span class=""> </span><span class="">x</span><span class=""> </span><span class="delimiter">=</span><span class=""> </span><span class="">x</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="keyword1"><span class="improper">done</span></span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">mset_less_insertD</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;(A + {#x#} &lt;# B) &#10233; (x &#8712;# B &#8743; A &lt;# B)&quot;</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">conjI</span><span class="delimiter">)</span><span class="">
</span><span class=""> </span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">mset_lessD</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">clarsimp</span><span class=""> </span><span class="">simp</span><span class="delimiter">:</span><span class=""> </span><span class="">subset_mset_def</span><span class=""> </span><span class="">subseteq_mset_def</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="">safe</span><span class="">
</span><span class=""> </span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">erule_tac</span><span class=""> </span><span class="">x</span><span class=""> </span><span class="delimiter">=</span><span class=""> </span><span class="">a</span><span class=""> </span><span class="keyword2">in</span><span class=""> </span><span class="">allE</span><span class="delimiter">)</span><span class="">
</span><span class=""> </span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">split</span><span class="delimiter">:</span><span class=""> </span><span class="">split_if_asm</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">done</span></span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">mset_le_insertD</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;(A + {#x#} &#8804;# B) &#10233; (x &#8712;# B &#8743; A &#8804;# B)&quot;</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">conjI</span><span class="delimiter">)</span><span class="">
</span><span class=""> </span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">mset_leD</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">force</span><span class=""> </span><span class="">simp</span><span class="delimiter">:</span><span class=""> </span><span class="">subset_mset_def</span><span class=""> </span><span class="">subseteq_mset_def</span><span class=""> </span><span class="">split</span><span class="delimiter">:</span><span class=""> </span><span class="">split_if_asm</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">done</span></span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">mset_less_of_empty</span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;A &lt;# {#} &#10231; False&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">subseteq_mset_def</span><span class=""> </span><span class="">subset_mset_def</span><span class=""> </span><span class="">multiset_eq_iff</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">empty_le</span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;{#} &#8804;# A&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">mset_le_exists_conv</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">le_empty</span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;(M &#8804;# {#}) = (M = {#})&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">mset_le_exists_conv</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">multi_psub_of_add_self</span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;A &lt;# A + {#x#}&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class="delimiter">:</span><span class=""> </span><span class="">subset_mset_def</span><span class=""> </span><span class="">subseteq_mset_def</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">multi_psub_self</span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;(A::&#39;a multiset) &lt;# A = False&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">mset_less_add_bothsides</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;N + {#x#} &lt;# M + {#x#} &#10233; N &lt;# M&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">fact</span><span class=""> </span><span class="">subset_mset.add_less_imp_less_right</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">mset_less_empty_nonempty</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;{#} &lt;# S &#10231; S &#8800; {#}&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class="delimiter">:</span><span class=""> </span><span class="">subset_mset_def</span><span class=""> </span><span class="">subseteq_mset_def</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">mset_less_diff_self</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;c &#8712;# B &#10233; B - {#c#} &lt;# B&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class="delimiter">:</span><span class=""> </span><span class="">subset_mset_def</span><span class=""> </span><span class="">subseteq_mset_def</span><span class=""> </span><span class="">multiset_eq_iff</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="">
</span><span class="keyword1">subsubsection</span><span class=""> </span><span class="cartouche">&#8249;Intersection&#8250;</span><span class="">
</span><span class="">
</span><span class="keyword1">definition</span><span class=""> </span><span class="">inf_subset_mset</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;&#39;a multiset &#8658; &#39;a multiset &#8658; &#39;a multiset&quot;</span><span class=""> </span><span class="delimiter">(</span><span class="keyword2">infixl</span><span class=""> </span><span class="string">&quot;#&#8745;&quot;</span><span class=""> </span><span class="">70</span><span class="delimiter">)</span><span class=""> </span><span class="keyword2">where</span><span class="">
</span><span class="">  </span><span class="">multiset_inter_def</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;inf_subset_mset A B = A - (A - B)&quot;</span><span class="">
</span><span class="">
</span><span class="keyword1">interpretation</span><span class=""> </span><span class="">subset_mset</span><span class="delimiter">:</span><span class=""> </span><span class="">semilattice_inf</span><span class=""> </span><span class="">inf_subset_mset</span><span class=""> </span><span class="string">&quot;op &#8804;#&quot;</span><span class=""> </span><span class="string">&quot;op &lt;#&quot;</span><span class="">
</span><span class="keyword1">proof</span><span class=""> </span><span class="">-</span><span class="">
</span><span class="">  </span><span class="keyword1">have</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;m &#8804; n &#10233; m &#8804; q &#10233; m &#8804; n - (n - q)&quot;</span><span class=""> </span><span class="keyword2">for</span><span class=""> </span><span class="">m</span><span class=""> </span><span class="">n</span><span class=""> </span><span class="">q</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="">nat</span><span class="">
</span><span class="">    </span><span class="keyword1">by</span><span class=""> </span><span class="">arith</span><span class="">
</span><span class="">  </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;class.semilattice_inf op #&#8745; op &#8804;# op &lt;#&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">by</span><span class=""> </span><span class="">standard</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">multiset_inter_def</span><span class=""> </span><span class="">subseteq_mset_def</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">multiset_inter_count</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">fixes</span><span class=""> </span><span class="">A</span><span class=""> </span><span class="">B</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;&#39;a multiset&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;count (A #&#8745; B) x = min (count A x) (count B x)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">multiset_inter_def</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">multiset_inter_single</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;a &#8800; b &#10233; {#a#} #&#8745; {#b#} = {#}&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">multiset_eqI</span><span class="delimiter">)</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">multiset_union_diff_commute</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="string">&quot;B #&#8745; C = {#}&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;A + B - C = A - C + B&quot;</span><span class="">
</span><span class="keyword1">proof</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">multiset_eqI</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword3">fix</span><span class=""> </span><span class="">x</span><span class="">
</span><span class="">  </span><span class="keyword1">from</span><span class=""> </span><span class="">assms</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;min (count B x) (count C x) = 0&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">multiset_eq_iff</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">then</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;count B x = 0 &#8744; count C x = 0&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">  </span><span class="keyword1">then</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;count (A + B - C) x = count (A - C + B) x&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">empty_inter</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;{#} #&#8745; M = {#}&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">multiset_eq_iff</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">inter_empty</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;M #&#8745; {#} = {#}&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">multiset_eq_iff</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">inter_add_left1</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;&#172; x &#8712;# N &#10233; (M + {#x#}) #&#8745; N = M #&#8745; N&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">multiset_eq_iff</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">inter_add_left2</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;x &#8712;# N &#10233; (M + {#x#}) #&#8745; N = (M #&#8745; (N - {#x#})) + {#x#}&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">multiset_eq_iff</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">inter_add_right1</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;&#172; x &#8712;# N &#10233; N #&#8745; (M + {#x#}) = N #&#8745; M&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">multiset_eq_iff</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">inter_add_right2</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;x &#8712;# N &#10233; N #&#8745; (M + {#x#}) = ((N - {#x#}) #&#8745; M) + {#x#}&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">multiset_eq_iff</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="">
</span><span class="keyword1">subsubsection</span><span class=""> </span><span class="cartouche">&#8249;Bounded union&#8250;</span><span class="">
</span><span class="">
</span><span class="keyword1">definition</span><span class=""> </span><span class="">sup_subset_mset</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;&#39;a multiset &#8658; &#39;a multiset &#8658; &#39;a multiset&quot;</span><span class="delimiter">(</span><span class="keyword2">infixl</span><span class=""> </span><span class="string">&quot;#&#8746;&quot;</span><span class=""> </span><span class="">70</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword2">where</span><span class=""> </span><span class="string">&quot;sup_subset_mset A B = A + (B - A)&quot;</span><span class="">
</span><span class="">
</span><span class="keyword1">interpretation</span><span class=""> </span><span class="">subset_mset</span><span class="delimiter">:</span><span class=""> </span><span class="">semilattice_sup</span><span class=""> </span><span class="">sup_subset_mset</span><span class=""> </span><span class="string">&quot;op &#8804;#&quot;</span><span class=""> </span><span class="string">&quot;op &lt;#&quot;</span><span class="">
</span><span class="keyword1">proof</span><span class=""> </span><span class="">-</span><span class="">
</span><span class="">  </span><span class="keyword1">have</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;m &#8804; n &#10233; q &#8804; n &#10233; m + (q - m) &#8804; n&quot;</span><span class=""> </span><span class="keyword2">for</span><span class=""> </span><span class="">m</span><span class=""> </span><span class="">n</span><span class=""> </span><span class="">q</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="">nat</span><span class="">
</span><span class="">    </span><span class="keyword1">by</span><span class=""> </span><span class="">arith</span><span class="">
</span><span class="">  </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;class.semilattice_sup op #&#8746; op &#8804;# op &lt;#&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">by</span><span class=""> </span><span class="">standard</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">sup_subset_mset_def</span><span class=""> </span><span class="">subseteq_mset_def</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">sup_subset_mset_count</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;count (A #&#8746; B) x = max (count A x) (count B x)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">sup_subset_mset_def</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">empty_sup</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;{#} #&#8746; M = M&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">multiset_eq_iff</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">sup_empty</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;M #&#8746; {#} = M&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">multiset_eq_iff</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">sup_add_left1</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;&#172; x &#8712;# N &#10233; (M + {#x#}) #&#8746; N = (M #&#8746; N) + {#x#}&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">multiset_eq_iff</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">sup_add_left2</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;x &#8712;# N &#10233; (M + {#x#}) #&#8746; N = (M #&#8746; (N - {#x#})) + {#x#}&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">multiset_eq_iff</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">sup_add_right1</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;&#172; x &#8712;# N &#10233; N #&#8746; (M + {#x#}) = (N #&#8746; M) + {#x#}&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">multiset_eq_iff</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">sup_add_right2</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;x &#8712;# N &#10233; N #&#8746; (M + {#x#}) = ((N - {#x#}) #&#8746; M) + {#x#}&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">multiset_eq_iff</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">subsubsection</span><span class=""> </span><span class="cartouche">&#8249;Subset is an order&#8250;</span><span class="">
</span><span class="keyword1">interpretation</span><span class=""> </span><span class="">subset_mset</span><span class="delimiter">:</span><span class=""> </span><span class="">order</span><span class=""> </span><span class="string">&quot;op &#8804;#&quot;</span><span class=""> </span><span class="string">&quot;op &lt;#&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">unfold_locales</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">
</span><span class="keyword1">subsubsection</span><span class=""> </span><span class="cartouche">&#8249;Filter (with comprehension syntax)&#8250;</span><span class="">
</span><span class="">
</span><span class="keyword1">text</span><span class=""> </span><span class="cartouche">&#8249;Multiset comprehension&#8250;</span><span class="">
</span><span class="">
</span><span class="keyword1">lift_definition</span><span class=""> </span><span class="">filter_mset</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;(&#39;a &#8658; bool) &#8658; &#39;a multiset &#8658; &#39;a multiset&quot;</span><span class="">
</span><span class="keyword2">is</span><span class=""> </span><span class="string">&quot;&#955;P M. &#955;x. if P x then M x else 0&quot;</span><span class="">
</span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">filter_preserves_multiset</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">count_filter_mset</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;count (filter_mset P M) a = (if P a then count M a else 0)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">filter_mset.rep_eq</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">filter_empty_mset</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;filter_mset P {#} = {#}&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">multiset_eqI</span><span class="delimiter">)</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">filter_single_mset</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;filter_mset P {#x#} = (if P x then {#x#} else {#})&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">multiset_eqI</span><span class="delimiter">)</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">filter_union_mset</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;filter_mset P (M + N) = filter_mset P M + filter_mset P N&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">multiset_eqI</span><span class="delimiter">)</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">filter_diff_mset</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;filter_mset P (M - N) = filter_mset P M - filter_mset P N&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">multiset_eqI</span><span class="delimiter">)</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">filter_inter_mset</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;filter_mset P (M #&#8745; N) = filter_mset P M #&#8745; filter_mset P N&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">multiset_eqI</span><span class="delimiter">)</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">multiset_filter_subset</span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;filter_mset f M &#8804;# M&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">mset_less_eqI</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">multiset_filter_mono</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="string">&quot;A &#8804;# B&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;filter_mset f A &#8804;# filter_mset f B&quot;</span><span class="">
</span><span class="keyword1">proof</span><span class=""> </span><span class="">-</span><span class="">
</span><span class="">  </span><span class="keyword1">from</span><span class=""> </span><span class="">assms</span><span class="delimiter">[</span><span class="">unfolded</span><span class=""> </span><span class="">mset_le_exists_conv</span><span class="delimiter">]</span><span class="">
</span><span class="">  </span><span class="keyword3">obtain</span><span class=""> </span><span class="">C</span><span class=""> </span><span class="keyword2">where</span><span class=""> </span><span class="">B</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;B = A + C&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">  </span><span class="keyword3">show</span><span class=""> </span><span class="var">?thesis</span><span class=""> </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">B</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="keyword1">syntax</span><span class=""> </span><span class="delimiter">(</span><span class="">ASCII</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="string">&quot;_MCollect&quot;</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;pttrn &#8658; &#39;a multiset &#8658; bool &#8658; &#39;a multiset&quot;</span><span class="">    </span><span class="delimiter">(</span><span class="string">&quot;(1{# _ :# _./ _#})&quot;</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1">syntax</span><span class="">
</span><span class="">  </span><span class="string">&quot;_MCollect&quot;</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;pttrn &#8658; &#39;a multiset &#8658; bool &#8658; &#39;a multiset&quot;</span><span class="">    </span><span class="delimiter">(</span><span class="string">&quot;(1{# _ &#8712;# _./ _#})&quot;</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1">translations</span><span class="">
</span><span class="">  </span><span class="string">&quot;{#x &#8712;# M. P#}&quot;</span><span class=""> </span><span class="delimiter">==</span><span class=""> </span><span class="string">&quot;CONST filter_mset (&#955;x. P) M&quot;</span><span class="">
</span><span class="">
</span><span class="">
</span><span class="keyword1">subsubsection</span><span class=""> </span><span class="cartouche">&#8249;Set of elements&#8250;</span><span class="">
</span><span class="">
</span><span class="keyword1">definition</span><span class=""> </span><span class="">set_mset</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;&#39;a multiset &#8658; &#39;a set&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">where</span><span class=""> </span><span class="string">&quot;set_mset M = {x. x &#8712;# M}&quot;</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">set_mset_empty</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;set_mset {#} = {}&quot;</span><span class="">
</span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">set_mset_def</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">set_mset_single</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;set_mset {#b#} = {b}&quot;</span><span class="">
</span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">set_mset_def</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">set_mset_union</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;set_mset (M + N) = set_mset M &#8746; set_mset N&quot;</span><span class="">
</span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">set_mset_def</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">set_mset_eq_empty_iff</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;(set_mset M = {}) = (M = {#})&quot;</span><span class="">
</span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">set_mset_def</span><span class=""> </span><span class="">multiset_eq_iff</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">mem_set_mset_iff</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;(x &#8712; set_mset M) = (x &#8712;# M)&quot;</span><span class="">
</span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">set_mset_def</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">set_mset_filter</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;set_mset {# x&#8712;#M. P x #} = set_mset M &#8745; {x. P x}&quot;</span><span class="">
</span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">set_mset_def</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">finite_set_mset</span><span class=""> </span><span class="delimiter">[</span><span class="">iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;finite (set_mset M)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">using</span><span class=""> </span><span class="">count</span><span class=""> </span><span class="delimiter">[</span><span class="">of</span><span class=""> </span><span class="">M</span><span class="delimiter">]</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">multiset_def</span><span class=""> </span><span class="">set_mset_def</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">finite_Collect_mem</span><span class=""> </span><span class="delimiter">[</span><span class="">iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;finite {x. x &#8712;# M}&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">set_mset_def</span><span class="delimiter">[</span><span class="">symmetric</span><span class="delimiter">]</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">set_mset_mono</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;A &#8804;# B &#10233; set_mset A &#8838; set_mset B&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">metis</span><span class=""> </span><span class="">mset_leD</span><span class=""> </span><span class="">subsetI</span><span class=""> </span><span class="">mem_set_mset_iff</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">ball_set_mset_iff</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;(&#8704;x &#8712; set_mset M. P x) &#10231; (&#8704;x. x &#8712;# M &#10230; P x)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">
</span><span class="">
</span><span class="keyword1">subsubsection</span><span class=""> </span><span class="cartouche">&#8249;Size&#8250;</span><span class="">
</span><span class="">
</span><span class="keyword1">definition</span><span class=""> </span><span class="">wcount</span><span class=""> </span><span class="keyword2">where</span><span class=""> </span><span class="string">&quot;wcount f M = (&#955;x. count M x * Suc (f x))&quot;</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">wcount_union</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;wcount f (M + N) a = wcount f M a + wcount f N a&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class="delimiter">:</span><span class=""> </span><span class="">wcount_def</span><span class=""> </span><span class="">add_mult_distrib</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">definition</span><span class=""> </span><span class="">size_multiset</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;(&#39;a &#8658; nat) &#8658; &#39;a multiset &#8658; nat&quot;</span><span class=""> </span><span class="keyword2">where</span><span class="">
</span><span class="">  </span><span class="string">&quot;size_multiset f M = setsum (wcount f M) (set_mset M)&quot;</span><span class="">
</span><span class="">
</span><span class="keyword1">lemmas</span><span class=""> </span><span class="">size_multiset_eq</span><span class=""> </span><span class="delimiter">=</span><span class=""> </span><span class="">size_multiset_def</span><span class="delimiter">[</span><span class="">unfolded</span><span class=""> </span><span class="">wcount_def</span><span class="delimiter">]</span><span class="">
</span><span class="">
</span><span class="keyword1">instantiation</span><span class=""> </span><span class="">multiset</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="delimiter">(</span><span class="">type</span><span class="delimiter">)</span><span class=""> </span><span class="">size</span><span class="">
</span><span class="keyword2">begin</span><span class="">
</span><span class="">
</span><span class="keyword1">definition</span><span class=""> </span><span class="">size_multiset</span><span class=""> </span><span class="keyword2">where</span><span class="">
</span><span class="">  </span><span class="">size_multiset_overloaded_def</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;size_multiset = Multiset.size_multiset (&#955;_. 0)&quot;</span><span class="">
</span><span class="keyword1">instance</span><span class=""> </span><span class="keyword1">..</span><span class="">
</span><span class="">
</span><span class="keyword2">end</span><span class="">
</span><span class="">
</span><span class="keyword1">lemmas</span><span class=""> </span><span class="">size_multiset_overloaded_eq</span><span class=""> </span><span class="delimiter">=</span><span class="">
</span><span class="">  </span><span class="">size_multiset_overloaded_def</span><span class="delimiter">[</span><span class="">THEN</span><span class=""> </span><span class="">fun_cong</span><span class="delimiter">,</span><span class=""> </span><span class="">unfolded</span><span class=""> </span><span class="">size_multiset_eq</span><span class="delimiter">,</span><span class=""> </span><span class="">simplified</span><span class="delimiter">]</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">size_multiset_empty</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;size_multiset f {#} = 0&quot;</span><span class="">
</span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">size_multiset_def</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">size_empty</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;size {#} = 0&quot;</span><span class="">
</span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">size_multiset_overloaded_def</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">size_multiset_single</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;size_multiset f {#b#} = Suc (f b)&quot;</span><span class="">
</span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">size_multiset_eq</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">size_single</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;size {#b#} = 1&quot;</span><span class="">
</span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">size_multiset_overloaded_def</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">setsum_wcount_Int</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="string">&quot;finite A &#10233; setsum (wcount f N) (A &#8745; set_mset N) = setsum (wcount f N) A&quot;</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">rule</span><span class="delimiter">:</span><span class=""> </span><span class="">finite_induct</span><span class="delimiter">)</span><span class="">
</span><span class=""> </span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">Int_insert_left</span><span class=""> </span><span class="">set_mset_def</span><span class=""> </span><span class="">wcount_def</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">done</span></span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">size_multiset_union</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="string">&quot;size_multiset f (M + N::&#39;a multiset) = size_multiset f M + size_multiset f N&quot;</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">size_multiset_def</span><span class=""> </span><span class="">setsum_Un_nat</span><span class=""> </span><span class="">setsum.distrib</span><span class=""> </span><span class="">setsum_wcount_Int</span><span class=""> </span><span class="">wcount_union</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">subst</span><span class=""> </span><span class="">Int_commute</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">setsum_wcount_Int</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">done</span></span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">size_union</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;size (M + N::&#39;a multiset) = size M + size N&quot;</span><span class="">
</span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">size_multiset_overloaded_def</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">size_multiset_eq_0_iff_empty</span><span class=""> </span><span class="delimiter">[</span><span class="">iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;(size_multiset f M = 0) = (M = {#})&quot;</span><span class="">
</span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">size_multiset_eq</span><span class=""> </span><span class="">multiset_eq_iff</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">size_eq_0_iff_empty</span><span class=""> </span><span class="delimiter">[</span><span class="">iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;(size M = 0) = (M = {#})&quot;</span><span class="">
</span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">size_multiset_overloaded_def</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">nonempty_has_size</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;(S &#8800; {#}) = (0 &lt; size S)&quot;</span><span class="">
</span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">metis</span><span class=""> </span><span class="">gr0I</span><span class=""> </span><span class="">gr_implies_not0</span><span class=""> </span><span class="">size_empty</span><span class=""> </span><span class="">size_eq_0_iff_empty</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">size_eq_Suc_imp_elem</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;size M = Suc n &#10233; &#8707;a. a &#8712;# M&quot;</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">unfold</span><span class=""> </span><span class="">size_multiset_overloaded_eq</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">drule</span><span class=""> </span><span class="">setsum_SucD</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="keyword1"><span class="improper">done</span></span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">size_eq_Suc_imp_eq_union</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="string">&quot;size M = Suc n&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;&#8707;a N. M = N + {#a#}&quot;</span><span class="">
</span><span class="keyword1">proof</span><span class=""> </span><span class="">-</span><span class="">
</span><span class="">  </span><span class="keyword1">from</span><span class=""> </span><span class="">assms</span><span class=""> </span><span class="keyword3">obtain</span><span class=""> </span><span class="">a</span><span class=""> </span><span class="keyword2">where</span><span class=""> </span><span class="string">&quot;a &#8712;# M&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">erule</span><span class=""> </span><span class="">size_eq_Suc_imp_elem</span><span class=""> </span><span class="delimiter">[</span><span class="">THEN</span><span class=""> </span><span class="">exE</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">then</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;M = M - {#a#} + {#a#}&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">  </span><span class="keyword1">then</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="var">?thesis</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">blast</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">size_mset_mono</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">fixes</span><span class=""> </span><span class="">A</span><span class=""> </span><span class="">B</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;&#39;a multiset&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="string">&quot;A &#8804;# B&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;size A &#8804; size B&quot;</span><span class="">
</span><span class="keyword1">proof</span><span class=""> </span><span class="">-</span><span class="">
</span><span class="">  </span><span class="keyword1">from</span><span class=""> </span><span class="">assms</span><span class="delimiter">[</span><span class="">unfolded</span><span class=""> </span><span class="">mset_le_exists_conv</span><span class="delimiter">]</span><span class="">
</span><span class="">  </span><span class="keyword3">obtain</span><span class=""> </span><span class="">C</span><span class=""> </span><span class="keyword2">where</span><span class=""> </span><span class="">B</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;B = A + C&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">  </span><span class="keyword3">show</span><span class=""> </span><span class="var">?thesis</span><span class=""> </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">B</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">C</span><span class="delimiter">)</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">size_filter_mset_lesseq</span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;size (filter_mset f M) &#8804; size M&quot;</span><span class="">
</span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">size_mset_mono</span><span class="delimiter">[</span><span class="">OF</span><span class=""> </span><span class="">multiset_filter_subset</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">size_Diff_submset</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="string">&quot;M &#8804;# M&#39; &#10233; size (M&#39; - M) = size M&#39; - size(M::&#39;a multiset)&quot;</span><span class="">
</span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">metis</span><span class=""> </span><span class="">add_diff_cancel_left&#39;</span><span class=""> </span><span class="">size_union</span><span class=""> </span><span class="">mset_le_exists_conv</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">subsection</span><span class=""> </span><span class="cartouche">&#8249;Induction and case splits&#8250;</span><span class="">
</span><span class="">
</span><span class="keyword1">theorem</span><span class=""> </span><span class="">multiset_induct</span><span class=""> </span><span class="delimiter">[</span><span class="">case_names</span><span class=""> </span><span class="">empty</span><span class=""> </span><span class="">add</span><span class="delimiter">,</span><span class=""> </span><span class="">induct</span><span class=""> </span><span class="">type</span><span class="delimiter">:</span><span class=""> </span><span class="">multiset</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="">empty</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;P {#}&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;&#8896;M x. P M &#10233; P (M + {#x#})&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;P M&quot;</span><span class="">
</span><span class="keyword1">proof</span><span class=""> </span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">n</span><span class=""> </span><span class="delimiter">&#8801;</span><span class=""> </span><span class="string">&quot;size M&quot;</span><span class=""> </span><span class="">arbitrary</span><span class="delimiter">:</span><span class=""> </span><span class="">M</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword3">case</span><span class=""> </span><span class="">0</span><span class=""> </span><span class="keyword3">thus</span><span class=""> </span><span class="string">&quot;P M&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">empty</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1">next</span><span class="">
</span><span class="">  </span><span class="keyword3">case</span><span class=""> </span><span class="delimiter">(</span><span class="">Suc</span><span class=""> </span><span class="">k</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword3">obtain</span><span class=""> </span><span class="">N</span><span class=""> </span><span class="">x</span><span class=""> </span><span class="keyword2">where</span><span class=""> </span><span class="string">&quot;M = N + {#x#}&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">using</span><span class=""> </span><span class="cartouche">&#8249;Suc k = size M&#8250;</span><span class=""> </span><span class="delimiter">[</span><span class="">symmetric</span><span class="delimiter">]</span><span class="">
</span><span class="">    </span><span class="keyword1">using</span><span class=""> </span><span class="">size_eq_Suc_imp_eq_union</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">fast</span><span class="">
</span><span class="">  </span><span class="keyword1">with</span><span class=""> </span><span class="">Suc</span><span class=""> </span><span class="">add</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;P M&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">multi_nonempty_split</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;M &#8800; {#} &#10233; &#8707;A a. M = A + {#a#}&quot;</span><span class="">
</span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">M</span><span class="delimiter">)</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">multiset_cases</span><span class=""> </span><span class="delimiter">[</span><span class="">cases</span><span class=""> </span><span class="">type</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">obtains</span><span class=""> </span><span class="delimiter">(</span><span class="">empty</span><span class="delimiter">)</span><span class=""> </span><span class="string">&quot;M = {#}&quot;</span><span class="">
</span><span class="">    </span><span class="delimiter">|</span><span class=""> </span><span class="delimiter">(</span><span class="">add</span><span class="delimiter">)</span><span class=""> </span><span class="">N</span><span class=""> </span><span class="">x</span><span class=""> </span><span class="keyword2">where</span><span class=""> </span><span class="string">&quot;M = N + {#x#}&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">using</span><span class=""> </span><span class="">assms</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">M</span><span class="delimiter">)</span><span class=""> </span><span class="">simp_all</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">multi_drop_mem_not_eq</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;c &#8712;# B &#10233; B - {#c#} &#8800; B&quot;</span><span class="">
</span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">cases</span><span class=""> </span><span class="string">&quot;B = {#}&quot;</span><span class="delimiter">)</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">dest</span><span class="delimiter">:</span><span class=""> </span><span class="">multi_member_split</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">multiset_partition</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;M = {# x&#8712;#M. P x #} + {# x&#8712;#M. &#172; P x #}&quot;</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">subst</span><span class=""> </span><span class="">multiset_eq_iff</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="keyword1"><span class="improper">done</span></span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">mset_less_size</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;(A::&#39;a multiset) &lt;# B &#10233; size A &lt; size B&quot;</span><span class="">
</span><span class="keyword1">proof</span><span class=""> </span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">A</span><span class=""> </span><span class="">arbitrary</span><span class="delimiter">:</span><span class=""> </span><span class="">B</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword3">case</span><span class=""> </span><span class="delimiter">(</span><span class="">empty</span><span class=""> </span><span class="">M</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">then</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;M &#8800; {#}&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">mset_less_empty_nonempty</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">then</span><span class=""> </span><span class="keyword3">obtain</span><span class=""> </span><span class="">M&#39;</span><span class=""> </span><span class="">x</span><span class=""> </span><span class="keyword2">where</span><span class=""> </span><span class="string">&quot;M = M&#39; + {#x#}&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">blast</span><span class=""> </span><span class="">dest</span><span class="delimiter">:</span><span class=""> </span><span class="">multi_nonempty_split</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">then</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="var">?case</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="keyword1">next</span><span class="">
</span><span class="">  </span><span class="keyword3">case</span><span class=""> </span><span class="delimiter">(</span><span class="">add</span><span class=""> </span><span class="">S</span><span class=""> </span><span class="">x</span><span class=""> </span><span class="">T</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">have</span><span class=""> </span><span class="">IH</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;&#8896;B. S &lt;# B &#10233; size S &lt; size B&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">fact</span><span class="">
</span><span class="">  </span><span class="keyword1">have</span><span class=""> </span><span class="">SxsubT</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;S + {#x#} &lt;# T&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">fact</span><span class="">
</span><span class="">  </span><span class="keyword1">then</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;x &#8712;# T&quot;</span><span class=""> </span><span class="keyword2">and</span><span class=""> </span><span class="string">&quot;S &lt;# T&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">dest</span><span class="delimiter">:</span><span class=""> </span><span class="">mset_less_insertD</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">then</span><span class=""> </span><span class="keyword3">obtain</span><span class=""> </span><span class="">T&#39;</span><span class=""> </span><span class="keyword2">where</span><span class=""> </span><span class="">T</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;T = T&#39; + {#x#}&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">blast</span><span class=""> </span><span class="">dest</span><span class="delimiter">:</span><span class=""> </span><span class="">multi_member_split</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">then</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;S &lt;# T&#39;&quot;</span><span class=""> </span><span class="keyword1">using</span><span class=""> </span><span class="">SxsubT</span><span class="">
</span><span class="">    </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">blast</span><span class=""> </span><span class="">intro</span><span class="delimiter">:</span><span class=""> </span><span class="">mset_less_add_bothsides</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">then</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;size S &lt; size T&#39;&quot;</span><span class=""> </span><span class="keyword1">using</span><span class=""> </span><span class="">IH</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">  </span><span class="keyword1">then</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="var">?case</span><span class=""> </span><span class="keyword1">using</span><span class=""> </span><span class="">T</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">size_1_singleton_mset</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;size M = 1 &#10233; &#8707;a. M = {#a#}&quot;</span><span class="">
</span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">cases</span><span class=""> </span><span class="">M</span><span class="delimiter">)</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">
</span><span class="keyword1">subsubsection</span><span class=""> </span><span class="cartouche">&#8249;Strong induction and subset induction for multisets&#8250;</span><span class="">
</span><span class="">
</span><span class="keyword1">text</span><span class=""> </span><span class="cartouche">&#8249;Well-foundedness of strict subset relation&#8250;</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">wf_less_mset_rel</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;wf {(M, N :: &#39;a multiset). M &lt;# N}&quot;</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">wf_measure</span><span class=""> </span><span class="delimiter">[</span><span class="">THEN</span><span class=""> </span><span class="">wf_subset</span><span class="delimiter">,</span><span class=""> </span><span class="keyword2">where</span><span class=""> </span><span class="">f1</span><span class="delimiter">=</span><span class="">size</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">clarsimp</span><span class=""> </span><span class="">simp</span><span class="delimiter">:</span><span class=""> </span><span class="">measure_def</span><span class=""> </span><span class="">inv_image_def</span><span class=""> </span><span class="">mset_less_size</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">done</span></span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">full_multiset_induct</span><span class=""> </span><span class="delimiter">[</span><span class="">case_names</span><span class=""> </span><span class="">less</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="keyword2">assumes</span><span class=""> </span><span class="">ih</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;&#8896;B. &#8704;(A::&#39;a multiset). A &lt;# B &#10230; P A &#10233; P B&quot;</span><span class="">
</span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;P B&quot;</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">wf_less_mset_rel</span><span class=""> </span><span class="delimiter">[</span><span class="">THEN</span><span class=""> </span><span class="">wf_induct</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">ih</span><span class="delimiter">,</span><span class=""> </span><span class="">auto</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">done</span></span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">multi_subset_induct</span><span class=""> </span><span class="delimiter">[</span><span class="">consumes</span><span class=""> </span><span class="">2</span><span class="delimiter">,</span><span class=""> </span><span class="">case_names</span><span class=""> </span><span class="">empty</span><span class=""> </span><span class="">add</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="string">&quot;F &#8804;# A&quot;</span><span class="">
</span><span class="">    </span><span class="keyword2">and</span><span class=""> </span><span class="">empty</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;P {#}&quot;</span><span class="">
</span><span class="">    </span><span class="keyword2">and</span><span class=""> </span><span class="">insert</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;&#8896;a F. a &#8712;# A &#10233; P F &#10233; P (F + {#a#})&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;P F&quot;</span><span class="">
</span><span class="keyword1">proof</span><span class=""> </span><span class="">-</span><span class="">
</span><span class="">  </span><span class="keyword1">from</span><span class=""> </span><span class="cartouche">&#8249;F &#8804;# A&#8250;</span><span class="">
</span><span class="">  </span><span class="keyword3">show</span><span class=""> </span><span class="var">?thesis</span><span class="">
</span><span class="">  </span><span class="keyword1">proof</span><span class=""> </span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">F</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;P {#}&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">fact</span><span class="">
</span><span class="">  </span><span class="keyword1">next</span><span class="">
</span><span class="">    </span><span class="keyword3">fix</span><span class=""> </span><span class="">x</span><span class=""> </span><span class="">F</span><span class="">
</span><span class="">    </span><span class="keyword3">assume</span><span class=""> </span><span class="">P</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;F &#8804;# A &#10233; P F&quot;</span><span class=""> </span><span class="keyword2">and</span><span class=""> </span><span class="">i</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;F + {#x#} &#8804;# A&quot;</span><span class="">
</span><span class="">    </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;P (F + {#x#})&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">proof</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">insert</span><span class="delimiter">)</span><span class="">
</span><span class="">      </span><span class="keyword1">from</span><span class=""> </span><span class="">i</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;x &#8712;# A&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">dest</span><span class="delimiter">:</span><span class=""> </span><span class="">mset_le_insertD</span><span class="delimiter">)</span><span class="">
</span><span class="">      </span><span class="keyword1">from</span><span class=""> </span><span class="">i</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;F &#8804;# A&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">dest</span><span class="delimiter">:</span><span class=""> </span><span class="">mset_le_insertD</span><span class="delimiter">)</span><span class="">
</span><span class="">      </span><span class="keyword1">with</span><span class=""> </span><span class="">P</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;P F&quot;</span><span class=""> </span><span class="keyword1">.</span><span class="">
</span><span class="">    </span><span class="keyword1">qed</span><span class="">
</span><span class="">  </span><span class="keyword1">qed</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="">
</span><span class="keyword1">subsection</span><span class=""> </span><span class="cartouche">&#8249;The fold combinator&#8250;</span><span class="">
</span><span class="">
</span><span class="keyword1">definition</span><span class=""> </span><span class="">fold_mset</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;(&#39;a &#8658; &#39;b &#8658; &#39;b) &#8658; &#39;b &#8658; &#39;a multiset &#8658; &#39;b&quot;</span><span class="">
</span><span class="keyword2">where</span><span class="">
</span><span class="">  </span><span class="string">&quot;fold_mset f s M = Finite_Set.fold (&#955;x. f x ^^ count M x) s (set_mset M)&quot;</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">fold_mset_empty</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;fold_mset f s {#} = s&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">fold_mset_def</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">context</span><span class=""> </span><span class="">comp_fun_commute</span><span class="">
</span><span class="keyword2">begin</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">fold_mset_insert</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;fold_mset f s (M + {#x#}) = f x (fold_mset f s M)&quot;</span><span class="">
</span><span class="keyword1">proof</span><span class=""> </span><span class="">-</span><span class="">
</span><span class="">  </span><span class="keyword1">interpret</span><span class=""> </span><span class="">mset</span><span class="delimiter">:</span><span class=""> </span><span class="">comp_fun_commute</span><span class=""> </span><span class="string">&quot;&#955;y. f y ^^ count M y&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">fact</span><span class=""> </span><span class="">comp_fun_commute_funpow</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">interpret</span><span class=""> </span><span class="">mset_union</span><span class="delimiter">:</span><span class=""> </span><span class="">comp_fun_commute</span><span class=""> </span><span class="string">&quot;&#955;y. f y ^^ count (M + {#x#}) y&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">fact</span><span class=""> </span><span class="">comp_fun_commute_funpow</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword3">show</span><span class=""> </span><span class="var">?thesis</span><span class="">
</span><span class="">  </span><span class="keyword1">proof</span><span class=""> </span><span class="delimiter">(</span><span class="">cases</span><span class=""> </span><span class="string">&quot;x &#8712; set_mset M&quot;</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword3">case</span><span class=""> </span><span class="">False</span><span class="">
</span><span class="">    </span><span class="keyword1">then</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="">*</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;count (M + {#x#}) x = 1&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">    </span><span class="keyword1">from</span><span class=""> </span><span class="">False</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;Finite_Set.fold (&#955;y. f y ^^ count (M + {#x#}) y) s (set_mset M) =
      Finite_Set.fold (&#955;y. f y ^^ count M y) s (set_mset M)&quot;</span><span class="">
</span><span class="">      </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span class=""> </span><span class="">Finite_Set.fold_cong</span><span class=""> </span><span class="">comp_fun_commute_funpow</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1">with</span><span class=""> </span><span class="">False</span><span class=""> </span><span class="">*</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="var">?thesis</span><span class="">
</span><span class="">      </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">fold_mset_def</span><span class=""> </span><span class="">del</span><span class="delimiter">:</span><span class=""> </span><span class="">count_union</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">next</span><span class="">
</span><span class="">    </span><span class="keyword3">case</span><span class=""> </span><span class="">True</span><span class="">
</span><span class="">    </span><span class="keyword3">def</span><span class=""> </span><span class="">N</span><span class=""> </span><span class="delimiter">&#8801;</span><span class=""> </span><span class="string">&quot;set_mset M - {x}&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">from</span><span class=""> </span><span class="">N_def</span><span class=""> </span><span class="">True</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="">*</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;set_mset M = insert x N&quot;</span><span class=""> </span><span class="string">&quot;x &#8713; N&quot;</span><span class=""> </span><span class="string">&quot;finite N&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">    </span><span class="keyword1">then</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;Finite_Set.fold (&#955;y. f y ^^ count (M + {#x#}) y) s N =
      Finite_Set.fold (&#955;y. f y ^^ count M y) s N&quot;</span><span class="">
</span><span class="">      </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span class=""> </span><span class="">Finite_Set.fold_cong</span><span class=""> </span><span class="">comp_fun_commute_funpow</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1">with</span><span class=""> </span><span class="">*</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="var">?thesis</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">fold_mset_def</span><span class=""> </span><span class="">del</span><span class="delimiter">:</span><span class=""> </span><span class="">count_union</span><span class="delimiter">)</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">  </span><span class="keyword1">qed</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="keyword1">corollary</span><span class=""> </span><span class="">fold_mset_single</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;fold_mset f s {#x#} = f x s&quot;</span><span class="">
</span><span class="keyword1">proof</span><span class=""> </span><span class="">-</span><span class="">
</span><span class="">  </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;fold_mset f s ({#} + {#x#}) = f x s&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">only</span><span class="delimiter">:</span><span class=""> </span><span class="">fold_mset_insert</span><span class="delimiter">)</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">  </span><span class="keyword1">then</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="var">?thesis</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">fold_mset_fun_left_comm</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;f x (fold_mset f s M) = fold_mset f (f x s) M&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">M</span><span class="delimiter">)</span><span class=""> </span><span class="delimiter">(</span><span class="">simp_all</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">fold_mset_insert</span><span class=""> </span><span class="">fun_left_comm</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">fold_mset_union</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;fold_mset f s (M + N) = fold_mset f (fold_mset f s M) N&quot;</span><span class="">
</span><span class="keyword1">proof</span><span class=""> </span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">M</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword3">case</span><span class=""> </span><span class="">empty</span><span class=""> </span><span class="keyword1">then</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="var">?case</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="keyword1">next</span><span class="">
</span><span class="">  </span><span class="keyword3">case</span><span class=""> </span><span class="delimiter">(</span><span class="">add</span><span class=""> </span><span class="">M</span><span class=""> </span><span class="">x</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;M + {#x#} + N = (M + N) + {#x#}&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">ac_simps</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">with</span><span class=""> </span><span class="">add</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="var">?case</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">fold_mset_insert</span><span class=""> </span><span class="">fold_mset_fun_left_comm</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">fold_mset_fusion</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="string">&quot;comp_fun_commute g&quot;</span><span class="">
</span><span class="">    </span><span class="keyword2">and</span><span class=""> </span><span class="">*</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;&#8896;x y. h (g x y) = f x (h y)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;h (fold_mset g w A) = fold_mset f (h w) A&quot;</span><span class="">
</span><span class="keyword1">proof</span><span class=""> </span><span class="">-</span><span class="">
</span><span class="">  </span><span class="keyword1">interpret</span><span class=""> </span><span class="">comp_fun_commute</span><span class=""> </span><span class="">g</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">fact</span><span class=""> </span><span class="">assms</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">from</span><span class=""> </span><span class="">*</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="var">?thesis</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">A</span><span class="delimiter">)</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="keyword2">end</span><span class="">
</span><span class="">
</span><span class="keyword1">text</span><span class=""> </span><span class="cartouche">&#8249;
  A note on code generation: When defining some function containing a
  subterm @{term &quot;fold_mset F&quot;}, code generation is not automatic. When
  interpreting locale &#8249;left_commutative&#8250; with &#8249;F&#8250;, the
  would be code thms for @{const fold_mset} become thms like
  @{term &quot;fold_mset F z {#} = z&quot;} where &#8249;F&#8250; is not a pattern but
  contains defined symbols, i.e.\ is not a code thm. Hence a separate
  constant with its own code thms needs to be introduced for &#8249;F&#8250;. See the image operator below.
&#8250;</span><span class="">
</span><span class="">
</span><span class="">
</span><span class="keyword1">subsection</span><span class=""> </span><span class="cartouche">&#8249;Image&#8250;</span><span class="">
</span><span class="">
</span><span class="keyword1">definition</span><span class=""> </span><span class="">image_mset</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;(&#39;a &#8658; &#39;b) &#8658; &#39;a multiset &#8658; &#39;b multiset&quot;</span><span class=""> </span><span class="keyword2">where</span><span class="">
</span><span class="">  </span><span class="string">&quot;image_mset f = fold_mset (plus &#8728; single &#8728; f) {#}&quot;</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">comp_fun_commute_mset_image</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;comp_fun_commute (plus &#8728; single &#8728; f)&quot;</span><span class="">
</span><span class="keyword1">proof</span><span class="">
</span><span class="keyword1">qed</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">ac_simps</span><span class=""> </span><span class="">fun_eq_iff</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">image_mset_empty</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;image_mset f {#} = {#}&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">image_mset_def</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">image_mset_single</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;image_mset f {#x#} = {#f x#}&quot;</span><span class="">
</span><span class="keyword1">proof</span><span class=""> </span><span class="">-</span><span class="">
</span><span class="">  </span><span class="keyword1">interpret</span><span class=""> </span><span class="">comp_fun_commute</span><span class=""> </span><span class="string">&quot;plus &#8728; single &#8728; f&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">fact</span><span class=""> </span><span class="">comp_fun_commute_mset_image</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword3">show</span><span class=""> </span><span class="var">?thesis</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">image_mset_def</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">image_mset_union</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;image_mset f (M + N) = image_mset f M + image_mset f N&quot;</span><span class="">
</span><span class="keyword1">proof</span><span class=""> </span><span class="">-</span><span class="">
</span><span class="">  </span><span class="keyword1">interpret</span><span class=""> </span><span class="">comp_fun_commute</span><span class=""> </span><span class="string">&quot;plus &#8728; single &#8728; f&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">fact</span><span class=""> </span><span class="">comp_fun_commute_mset_image</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword3">show</span><span class=""> </span><span class="var">?thesis</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">N</span><span class="delimiter">)</span><span class=""> </span><span class="delimiter">(</span><span class="">simp_all</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">image_mset_def</span><span class=""> </span><span class="">ac_simps</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="keyword1">corollary</span><span class=""> </span><span class="">image_mset_insert</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;image_mset f (M + {#a#}) = image_mset f M + {#f a#}&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">set_image_mset</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;set_mset (image_mset f M) = image f (set_mset M)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">M</span><span class="delimiter">)</span><span class=""> </span><span class="">simp_all</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">size_image_mset</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;size (image_mset f M) = size M&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">M</span><span class="delimiter">)</span><span class=""> </span><span class="">simp_all</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">image_mset_is_empty_iff</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;image_mset f M = {#} &#10231; M = {#}&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">cases</span><span class=""> </span><span class="">M</span><span class="delimiter">)</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">
</span><span class="keyword1">syntax</span><span class=""> </span><span class="delimiter">(</span><span class="">ASCII</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="string">&quot;_comprehension_mset&quot;</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;&#39;a &#8658; &#39;b &#8658; &#39;b multiset &#8658; &#39;a multiset&quot;</span><span class="">  </span><span class="delimiter">(</span><span class="string">&quot;({#_/. _ :# _#})&quot;</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1">syntax</span><span class="">
</span><span class="">  </span><span class="string">&quot;_comprehension_mset&quot;</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;&#39;a &#8658; &#39;b &#8658; &#39;b multiset &#8658; &#39;a multiset&quot;</span><span class="">  </span><span class="delimiter">(</span><span class="string">&quot;({#_/. _ &#8712;# _#})&quot;</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1">translations</span><span class="">
</span><span class="">  </span><span class="string">&quot;{#e. x &#8712;# M#}&quot;</span><span class=""> </span><span class="delimiter">&#8652;</span><span class=""> </span><span class="string">&quot;CONST image_mset (&#955;x. e) M&quot;</span><span class="">
</span><span class="">
</span><span class="keyword1">syntax</span><span class=""> </span><span class="delimiter">(</span><span class="">ASCII</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="string">&quot;_comprehension_mset&#39;&quot;</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;&#39;a &#8658; &#39;b &#8658; &#39;b multiset &#8658; bool &#8658; &#39;a multiset&quot;</span><span class="">  </span><span class="delimiter">(</span><span class="string">&quot;({#_/ | _ :# _./ _#})&quot;</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1">syntax</span><span class="">
</span><span class="">  </span><span class="string">&quot;_comprehension_mset&#39;&quot;</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;&#39;a &#8658; &#39;b &#8658; &#39;b multiset &#8658; bool &#8658; &#39;a multiset&quot;</span><span class="">  </span><span class="delimiter">(</span><span class="string">&quot;({#_/ | _ &#8712;# _./ _#})&quot;</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1">translations</span><span class="">
</span><span class="">  </span><span class="string">&quot;{#e | x&#8712;#M. P#}&quot;</span><span class=""> </span><span class="delimiter">&#8640;</span><span class=""> </span><span class="string">&quot;{#e. x &#8712;# {# x&#8712;#M. P#}#}&quot;</span><span class="">
</span><span class="">
</span><span class="keyword1">text</span><span class=""> </span><span class="cartouche">&#8249;
  This allows to write not just filters like @{term &quot;{#x&#8712;#M. x&lt;c#}&quot;}
  but also images like @{term &quot;{#x+x. x&#8712;#M #}&quot;} and @{term [source]
  &quot;{#x+x|x&#8712;#M. x&lt;c#}&quot;}, where the latter is currently displayed as
  @{term &quot;{#x+x|x&#8712;#M. x&lt;c#}&quot;}.
&#8250;</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">in_image_mset</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;y &#8712;# {#f x. x &#8712;# M#} &#10231; y &#8712; f ` set_mset M&quot;</span><span class="">
</span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">metis</span><span class=""> </span><span class="">mem_set_mset_iff</span><span class=""> </span><span class="">set_image_mset</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">functor</span><span class=""> </span><span class="">image_mset</span><span class="delimiter">:</span><span class=""> </span><span class="">image_mset</span><span class="">
</span><span class="keyword1">proof</span><span class=""> </span><span class="">-</span><span class="">
</span><span class="">  </span><span class="keyword3">fix</span><span class=""> </span><span class="">f</span><span class=""> </span><span class="">g</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;image_mset f &#8728; image_mset g = image_mset (f &#8728; g)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">proof</span><span class="">
</span><span class="">    </span><span class="keyword3">fix</span><span class=""> </span><span class="">A</span><span class="">
</span><span class="">    </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;(image_mset f &#8728; image_mset g) A = image_mset (f &#8728; g) A&quot;</span><span class="">
</span><span class="">      </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">A</span><span class="delimiter">)</span><span class=""> </span><span class="">simp_all</span><span class="">
</span><span class="">  </span><span class="keyword1">qed</span><span class="">
</span><span class="">  </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;image_mset id = id&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">proof</span><span class="">
</span><span class="">    </span><span class="keyword3">fix</span><span class=""> </span><span class="">A</span><span class="">
</span><span class="">    </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;image_mset id A = id A&quot;</span><span class="">
</span><span class="">      </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">A</span><span class="delimiter">)</span><span class=""> </span><span class="">simp_all</span><span class="">
</span><span class="">  </span><span class="keyword1">qed</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="keyword1">declare</span><span class="">
</span><span class="">  </span><span class="">image_mset.id</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="">
</span><span class="">  </span><span class="">image_mset.identity</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">image_mset_id</span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;image_mset id x = x&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">id_def</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">image_mset_cong</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;(&#8896;x. x &#8712;# M &#10233; f x = g x) &#10233; {#f x. x &#8712;# M#} = {#g x. x &#8712;# M#}&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">M</span><span class="delimiter">)</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">image_mset_cong_pair</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="string">&quot;(&#8704;x y. (x, y) &#8712;# M &#10230; f x y = g x y) &#10233; {#f x y. (x, y) &#8712;# M#} = {#g x y. (x, y) &#8712;# M#}&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">metis</span><span class=""> </span><span class="">image_mset_cong</span><span class=""> </span><span class="">split_cong</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="">
</span><span class="keyword1">subsection</span><span class=""> </span><span class="cartouche">&#8249;Further conversions&#8250;</span><span class="">
</span><span class="">
</span><span class="keyword1">primrec</span><span class=""> </span><span class="">mset</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;&#39;a list &#8658; &#39;a multiset&quot;</span><span class=""> </span><span class="keyword2">where</span><span class="">
</span><span class="">  </span><span class="string">&quot;mset [] = {#}&quot;</span><span class=""> </span><span class="delimiter">|</span><span class="">
</span><span class="">  </span><span class="string">&quot;mset (a # x) = mset x + {# a #}&quot;</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">in_multiset_in_set</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="string">&quot;x &#8712;# mset xs &#10231; x &#8712; set xs&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">xs</span><span class="delimiter">)</span><span class=""> </span><span class="">simp_all</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">count_mset</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="string">&quot;count (mset xs) x = length (filter (&#955;y. x = y) xs)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">xs</span><span class="delimiter">)</span><span class=""> </span><span class="">simp_all</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">mset_zero_iff</span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;(mset x = {#}) = (x = [])&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">x</span><span class="delimiter">)</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">mset_zero_iff_right</span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;({#} = mset x) = (x = [])&quot;</span><span class="">
</span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">x</span><span class="delimiter">)</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">set_mset_mset</span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;set_mset (mset x) = set x&quot;</span><span class="">
</span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">x</span><span class="delimiter">)</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">mem_set_multiset_eq</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;x &#8712; set xs = (x &#8712;# mset xs)&quot;</span><span class="">
</span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">xs</span><span class="delimiter">)</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">size_mset</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;size (mset xs) = length xs&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">xs</span><span class="delimiter">)</span><span class=""> </span><span class="">simp_all</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">mset_append</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;mset (xs @ ys) = mset xs + mset ys&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">xs</span><span class=""> </span><span class="">arbitrary</span><span class="delimiter">:</span><span class=""> </span><span class="">ys</span><span class="delimiter">)</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class="delimiter">:</span><span class=""> </span><span class="">ac_simps</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">mset_filter</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;mset (filter P xs) = {#x &#8712;# mset xs. P x #}&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">xs</span><span class="delimiter">)</span><span class=""> </span><span class="">simp_all</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">mset_rev</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="string">&quot;mset (rev xs) = mset xs&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">xs</span><span class="delimiter">)</span><span class=""> </span><span class="">simp_all</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">surj_mset</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;surj mset&quot;</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">unfold</span><span class=""> </span><span class="">surj_def</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">allI</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">rule_tac</span><span class=""> </span><span class="">M</span><span class=""> </span><span class="delimiter">=</span><span class=""> </span><span class="">y</span><span class=""> </span><span class="keyword2">in</span><span class=""> </span><span class="">multiset_induct</span><span class="delimiter">)</span><span class="">
</span><span class=""> </span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">rule_tac</span><span class=""> </span><span class="">x</span><span class=""> </span><span class="delimiter">=</span><span class=""> </span><span class="string">&quot;x # xa&quot;</span><span class=""> </span><span class="keyword2">in</span><span class=""> </span><span class="">exI</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="keyword1"><span class="improper">done</span></span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">set_count_greater_0</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;set x = {a. count (mset x) a &gt; 0}&quot;</span><span class="">
</span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">x</span><span class="delimiter">)</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">distinct_count_atmost_1</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="string">&quot;distinct x = (&#8704;a. count (mset x) a = (if a &#8712; set x then 1 else 0))&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">x</span><span class="delimiter">,</span><span class=""> </span><span class="">simp</span><span class="delimiter">,</span><span class=""> </span><span class="">rule</span><span class=""> </span><span class="">iffI</span><span class="delimiter">,</span><span class=""> </span><span class="">simp_all</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">subgoal</span></span><span class=""> </span><span class="keyword2">for</span><span class=""> </span><span class="">a</span><span class=""> </span><span class="">b</span><span class="">
</span><span class="">    </span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">conjI</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">simp_all</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">set_mset_mset</span><span class=""> </span><span class="delimiter">[</span><span class="">symmetric</span><span class="delimiter">]</span><span class=""> </span><span class="">del</span><span class="delimiter">:</span><span class=""> </span><span class="">set_mset_mset</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">erule_tac</span><span class=""> </span><span class="">x</span><span class=""> </span><span class="delimiter">=</span><span class=""> </span><span class="">a</span><span class=""> </span><span class="keyword2">in</span><span class=""> </span><span class="">allE</span><span class="delimiter">,</span><span class=""> </span><span class="">simp</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="">clarify</span><span class="">
</span><span class="">    </span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">erule_tac</span><span class=""> </span><span class="">x</span><span class=""> </span><span class="delimiter">=</span><span class=""> </span><span class="">aa</span><span class=""> </span><span class="keyword2">in</span><span class=""> </span><span class="">allE</span><span class="delimiter">,</span><span class=""> </span><span class="">simp</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1"><span class="improper">done</span></span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">done</span></span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">mset_eq_setD</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;mset xs = mset ys &#10233; set xs = set ys&quot;</span><span class="">
</span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class="delimiter">)</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class="">multiset_eq_iff</span><span class=""> </span><span class="">set_count_greater_0</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">set_eq_iff_mset_eq_distinct</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="string">&quot;distinct x &#10233; distinct y &#10233;
    (set x = set y) = (mset x = mset y)&quot;</span><span class="">
</span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class="delimiter">:</span><span class=""> </span><span class="">multiset_eq_iff</span><span class=""> </span><span class="">distinct_count_atmost_1</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">set_eq_iff_mset_remdups_eq</span><span class="delimiter">:</span><span class="">
</span><span class="">   </span><span class="string">&quot;(set x = set y) = (mset (remdups x) = mset (remdups y))&quot;</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">iffI</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">set_eq_iff_mset_eq_distinct</span><span class="delimiter">[</span><span class="">THEN</span><span class=""> </span><span class="">iffD1</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">drule</span><span class=""> </span><span class="">distinct_remdups</span><span class=""> </span><span class="delimiter">[</span><span class="">THEN</span><span class=""> </span><span class="">distinct_remdups</span><span class="">
</span><span class="">      </span><span class="delimiter">[</span><span class="">THEN</span><span class=""> </span><span class="">set_eq_iff_mset_eq_distinct</span><span class=""> </span><span class="delimiter">[</span><span class="">THEN</span><span class=""> </span><span class="">iffD2</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="keyword1"><span class="improper">done</span></span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">mset_compl_union</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;mset [x&#8592;xs. P x] + mset [x&#8592;xs. &#172;P x] = mset xs&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">xs</span><span class="delimiter">)</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class="delimiter">:</span><span class=""> </span><span class="">ac_simps</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">nth_mem_mset</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;i &lt; length ls &#10233; (ls ! i) &#8712;# mset ls&quot;</span><span class="">
</span><span class="keyword1">proof</span><span class=""> </span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">ls</span><span class=""> </span><span class="">arbitrary</span><span class="delimiter">:</span><span class=""> </span><span class="">i</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword3">case</span><span class=""> </span><span class="">Nil</span><span class="">
</span><span class="">  </span><span class="keyword1">then</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="var">?case</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="keyword1">next</span><span class="">
</span><span class="">  </span><span class="keyword3">case</span><span class=""> </span><span class="">Cons</span><span class="">
</span><span class="">  </span><span class="keyword1">then</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="var">?case</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">cases</span><span class=""> </span><span class="">i</span><span class="delimiter">)</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">mset_remove1</span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;mset (remove1 a xs) = mset xs - {#a#}&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">xs</span><span class="delimiter">)</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">multiset_eq_iff</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">mset_eq_length</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="string">&quot;mset xs = mset ys&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;length xs = length ys&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">using</span><span class=""> </span><span class="">assms</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">metis</span><span class=""> </span><span class="">size_mset</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">mset_eq_length_filter</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="string">&quot;mset xs = mset ys&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;length (filter (&#955;x. z = x) xs) = length (filter (&#955;y. z = y) ys)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">using</span><span class=""> </span><span class="">assms</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">metis</span><span class=""> </span><span class="">count_mset</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">fold_multiset_equiv</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="">f</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;&#8896;x y. x &#8712; set xs &#10233; y &#8712; set xs &#10233; f x &#8728; f y = f y &#8728; f x&quot;</span><span class="">
</span><span class="">    </span><span class="keyword2">and</span><span class=""> </span><span class="">equiv</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;mset xs = mset ys&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;List.fold f xs = List.fold f ys&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">using</span><span class=""> </span><span class="">f</span><span class=""> </span><span class="">equiv</span><span class=""> </span><span class="delimiter">[</span><span class="">symmetric</span><span class="delimiter">]</span><span class="">
</span><span class="keyword1">proof</span><span class=""> </span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">xs</span><span class=""> </span><span class="">arbitrary</span><span class="delimiter">:</span><span class=""> </span><span class="">ys</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword3">case</span><span class=""> </span><span class="">Nil</span><span class="">
</span><span class="">  </span><span class="keyword1">then</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="var">?case</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="keyword1">next</span><span class="">
</span><span class="">  </span><span class="keyword3">case</span><span class=""> </span><span class="delimiter">(</span><span class="">Cons</span><span class=""> </span><span class="">x</span><span class=""> </span><span class="">xs</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">then</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="">*</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;set ys = set (x # xs)&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">blast</span><span class=""> </span><span class="">dest</span><span class="delimiter">:</span><span class=""> </span><span class="">mset_eq_setD</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;&#8896;x y. x &#8712; set ys &#10233; y &#8712; set ys &#10233; f x &#8728; f y = f y &#8728; f x&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">Cons.prems</span><span class="delimiter">(</span><span class="">1</span><span class="delimiter">)</span><span class="delimiter">)</span><span class=""> </span><span class="delimiter">(</span><span class="">simp_all</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">*</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">moreover</span><span class=""> </span><span class="keyword1">from</span><span class=""> </span><span class="">*</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;x &#8712; set ys&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">  </span><span class="keyword1">ultimately</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;List.fold f ys = List.fold f (remove1 x ys) &#8728; f x&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">fact</span><span class=""> </span><span class="">fold_remove1_split</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">moreover</span><span class=""> </span><span class="keyword1">from</span><span class=""> </span><span class="">Cons.prems</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;List.fold f xs = List.fold f (remove1 x ys)&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">intro</span><span class="delimiter">:</span><span class=""> </span><span class="">Cons.hyps</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">ultimately</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="var">?case</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">mset_insort</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;mset (insort x xs) = mset xs + {#x#}&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">xs</span><span class="delimiter">)</span><span class=""> </span><span class="delimiter">(</span><span class="">simp_all</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">ac_simps</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">mset_map</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;mset (map f xs) = image_mset f (mset xs)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">xs</span><span class="delimiter">)</span><span class=""> </span><span class="">simp_all</span><span class="">
</span><span class="">
</span><span class="keyword1">global_interpretation</span><span class=""> </span><span class="">mset_set</span><span class="delimiter">:</span><span class=""> </span><span class="">folding</span><span class=""> </span><span class="string">&quot;&#955;x M. {#x#} + M&quot;</span><span class=""> </span><span class="string">&quot;{#}&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">defines</span><span class=""> </span><span class="">mset_set</span><span class=""> </span><span class="delimiter">=</span><span class=""> </span><span class="string">&quot;folding.F (&#955;x M. {#x#} + M) {#}&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="">standard</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">fun_eq_iff</span><span class=""> </span><span class="">ac_simps</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">count_mset_set</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="string">&quot;finite A &#10233; x &#8712; A &#10233; count (mset_set A) x = 1&quot;</span><span class=""> </span><span class="delimiter">(</span><span class="keyword2">is</span><span class=""> </span><span class="string">&quot;PROP ?P&quot;</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="string">&quot;&#172; finite A &#10233; count (mset_set A) x = 0&quot;</span><span class=""> </span><span class="delimiter">(</span><span class="keyword2">is</span><span class=""> </span><span class="string">&quot;PROP ?Q&quot;</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="string">&quot;x &#8713; A &#10233; count (mset_set A) x = 0&quot;</span><span class=""> </span><span class="delimiter">(</span><span class="keyword2">is</span><span class=""> </span><span class="string">&quot;PROP ?R&quot;</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1">proof</span><span class=""> </span><span class="">-</span><span class="">
</span><span class="">  </span><span class="keyword1">have</span><span class=""> </span><span class="">*</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;count (mset_set A) x = 0&quot;</span><span class=""> </span><span class="keyword2">if</span><span class=""> </span><span class="string">&quot;x &#8713; A&quot;</span><span class=""> </span><span class="keyword2">for</span><span class=""> </span><span class="">A</span><span class="">
</span><span class="">  </span><span class="keyword1">proof</span><span class=""> </span><span class="delimiter">(</span><span class="">cases</span><span class=""> </span><span class="string">&quot;finite A&quot;</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword3">case</span><span class=""> </span><span class="">False</span><span class=""> </span><span class="keyword1">then</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="var">?thesis</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">  </span><span class="keyword1">next</span><span class="">
</span><span class="">    </span><span class="keyword3">case</span><span class=""> </span><span class="">True</span><span class=""> </span><span class="keyword1">from</span><span class=""> </span><span class="">True</span><span class=""> </span><span class="cartouche">&#8249;x &#8713; A&#8250;</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="var">?thesis</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">A</span><span class="delimiter">)</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">  </span><span class="keyword1">qed</span><span class="">
</span><span class="">  </span><span class="keyword1">then</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;PROP ?P&quot;</span><span class=""> </span><span class="string">&quot;PROP ?Q&quot;</span><span class=""> </span><span class="string">&quot;PROP ?R&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span class=""> </span><span class="">Set.set_insert</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1">qed</span><span class=""> </span><span class="delimiter">&#8213;</span><span class=""> </span><span class="cartouche">&#8249;TODO: maybe define @{const mset_set} also in terms of @{const Abs_multiset}&#8250;</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">elem_mset_set</span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">,</span><span class=""> </span><span class="">intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;finite A &#10233; x &#8712;# mset_set A &#10231; x &#8712; A&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">A</span><span class=""> </span><span class="">rule</span><span class="delimiter">:</span><span class=""> </span><span class="">finite_induct</span><span class="delimiter">)</span><span class=""> </span><span class="">simp_all</span><span class="">
</span><span class="">
</span><span class="keyword1">context</span><span class=""> </span><span class="">linorder</span><span class="">
</span><span class="keyword2">begin</span><span class="">
</span><span class="">
</span><span class="keyword1">definition</span><span class=""> </span><span class="">sorted_list_of_multiset</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;&#39;a multiset &#8658; &#39;a list&quot;</span><span class="">
</span><span class="keyword2">where</span><span class="">
</span><span class="">  </span><span class="string">&quot;sorted_list_of_multiset M = fold_mset insort [] M&quot;</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">sorted_list_of_multiset_empty</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="string">&quot;sorted_list_of_multiset {#} = []&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">sorted_list_of_multiset_def</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">sorted_list_of_multiset_singleton</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="string">&quot;sorted_list_of_multiset {#x#} = [x]&quot;</span><span class="">
</span><span class="keyword1">proof</span><span class=""> </span><span class="">-</span><span class="">
</span><span class="">  </span><span class="keyword1">interpret</span><span class=""> </span><span class="">comp_fun_commute</span><span class=""> </span><span class="">insort</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">fact</span><span class=""> </span><span class="">comp_fun_commute_insort</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword3">show</span><span class=""> </span><span class="var">?thesis</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">sorted_list_of_multiset_def</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">sorted_list_of_multiset_insert</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="string">&quot;sorted_list_of_multiset (M + {#x#}) = List.insort x (sorted_list_of_multiset M)&quot;</span><span class="">
</span><span class="keyword1">proof</span><span class=""> </span><span class="">-</span><span class="">
</span><span class="">  </span><span class="keyword1">interpret</span><span class=""> </span><span class="">comp_fun_commute</span><span class=""> </span><span class="">insort</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">fact</span><span class=""> </span><span class="">comp_fun_commute_insort</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword3">show</span><span class=""> </span><span class="var">?thesis</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">sorted_list_of_multiset_def</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="keyword2">end</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">mset_sorted_list_of_multiset</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="string">&quot;mset (sorted_list_of_multiset M) = M&quot;</span><span class="">
</span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">M</span><span class="delimiter">)</span><span class=""> </span><span class="">simp_all</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">sorted_list_of_multiset_mset</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="string">&quot;sorted_list_of_multiset (mset xs) = sort xs&quot;</span><span class="">
</span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">xs</span><span class="delimiter">)</span><span class=""> </span><span class="">simp_all</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">finite_set_mset_mset_set</span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="string">&quot;finite A &#10233; set_mset (mset_set A) = A&quot;</span><span class="">
</span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">A</span><span class=""> </span><span class="">rule</span><span class="delimiter">:</span><span class=""> </span><span class="">finite_induct</span><span class="delimiter">)</span><span class=""> </span><span class="">simp_all</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">infinite_set_mset_mset_set</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="string">&quot;&#172; finite A &#10233; set_mset (mset_set A) = {}&quot;</span><span class="">
</span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">set_sorted_list_of_multiset</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="string">&quot;set (sorted_list_of_multiset M) = set_mset M&quot;</span><span class="">
</span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">M</span><span class="delimiter">)</span><span class=""> </span><span class="delimiter">(</span><span class="">simp_all</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">set_insort</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">sorted_list_of_mset_set</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="string">&quot;sorted_list_of_multiset (mset_set A) = sorted_list_of_set A&quot;</span><span class="">
</span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">cases</span><span class=""> </span><span class="string">&quot;finite A&quot;</span><span class="delimiter">)</span><span class=""> </span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">A</span><span class=""> </span><span class="">rule</span><span class="delimiter">:</span><span class=""> </span><span class="">finite_induct</span><span class="delimiter">,</span><span class=""> </span><span class="">simp_all</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">ac_simps</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="">
</span><span class="keyword1">subsection</span><span class=""> </span><span class="cartouche">&#8249;Replicate operation&#8250;</span><span class="">
</span><span class="">
</span><span class="keyword1">definition</span><span class=""> </span><span class="">replicate_mset</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;nat &#8658; &#39;a &#8658; &#39;a multiset&quot;</span><span class=""> </span><span class="keyword2">where</span><span class="">
</span><span class="">  </span><span class="string">&quot;replicate_mset n x = ((op + {#x#}) ^^ n) {#}&quot;</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">replicate_mset_0</span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;replicate_mset 0 x = {#}&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">replicate_mset_def</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">replicate_mset_Suc</span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;replicate_mset (Suc n) x = replicate_mset n x + {#x#}&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">replicate_mset_def</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">n</span><span class="delimiter">)</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">intro</span><span class="delimiter">:</span><span class=""> </span><span class="">add.commute</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">in_replicate_mset</span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;x &#8712;# replicate_mset n y &#10231; n &gt; 0 &#8743; x = y&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">replicate_mset_def</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">n</span><span class="delimiter">)</span><span class=""> </span><span class="">simp_all</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">count_replicate_mset</span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;count (replicate_mset n x) y = (if y = x then n else 0)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">replicate_mset_def</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">n</span><span class="delimiter">)</span><span class=""> </span><span class="">simp_all</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">set_mset_replicate_mset_subset</span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;set_mset (replicate_mset n x) = (if n = 0 then {} else {x})&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">split</span><span class="delimiter">:</span><span class=""> </span><span class="">if_splits</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">size_replicate_mset</span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;size (replicate_mset n M) = n&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">n</span><span class="delimiter">,</span><span class=""> </span><span class="">simp_all</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">count_le_replicate_mset_le</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;n &#8804; count M x &#10231; replicate_mset n x &#8804;# M&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">assms</span><span class=""> </span><span class="">mset_less_eqI</span><span class="delimiter">)</span><span class=""> </span><span class="delimiter">(</span><span class="">metis</span><span class=""> </span><span class="">count_replicate_mset</span><span class=""> </span><span class="">subseteq_mset_def</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">filter_eq_replicate_mset</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;{#y &#8712;# D. y = x#} = replicate_mset (count D x) x&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">D</span><span class="delimiter">)</span><span class=""> </span><span class="">simp_all</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">replicate_count_mset_eq_filter_eq</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="string">&quot;replicate (count (mset xs) k) k = filter (HOL.eq k) xs&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">xs</span><span class="delimiter">)</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">
</span><span class="">
</span><span class="keyword1">subsection</span><span class=""> </span><span class="cartouche">&#8249;Big operators&#8250;</span><span class="">
</span><span class="">
</span><span class="keyword1">no_notation</span><span class=""> </span><span class="">times</span><span class=""> </span><span class="delimiter">(</span><span class="keyword2">infixl</span><span class=""> </span><span class="string">&quot;*&quot;</span><span class=""> </span><span class="">70</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1">no_notation</span><span class=""> </span><span class="">Groups.one</span><span class=""> </span><span class="delimiter">(</span><span class="string">&quot;1&quot;</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">locale</span><span class=""> </span><span class="">comm_monoid_mset</span><span class=""> </span><span class="delimiter">=</span><span class=""> </span><span class="">comm_monoid</span><span class="">
</span><span class="keyword2">begin</span><span class="">
</span><span class="">
</span><span class="keyword1">definition</span><span class=""> </span><span class="">F</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;&#39;a multiset &#8658; &#39;a&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">where</span><span class=""> </span><span class="">eq_fold</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;F M = fold_mset f 1 M&quot;</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">empty</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;F {#} = 1&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">eq_fold</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">singleton</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;F {#x#} = x&quot;</span><span class="">
</span><span class="keyword1">proof</span><span class=""> </span><span class="">-</span><span class="">
</span><span class="">  </span><span class="keyword1">interpret</span><span class=""> </span><span class="">comp_fun_commute</span><span class="">
</span><span class="">    </span><span class="keyword1">by</span><span class=""> </span><span class="">standard</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">fun_eq_iff</span><span class=""> </span><span class="">left_commute</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword3">show</span><span class=""> </span><span class="var">?thesis</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">eq_fold</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">union</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;F (M + N) = F M * F N&quot;</span><span class="">
</span><span class="keyword1">proof</span><span class=""> </span><span class="">-</span><span class="">
</span><span class="">  </span><span class="keyword1">interpret</span><span class=""> </span><span class="">comp_fun_commute</span><span class=""> </span><span class="">f</span><span class="">
</span><span class="">    </span><span class="keyword1">by</span><span class=""> </span><span class="">standard</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">fun_eq_iff</span><span class=""> </span><span class="">left_commute</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword3">show</span><span class=""> </span><span class="var">?thesis</span><span class="">
</span><span class="">    </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">N</span><span class="delimiter">)</span><span class=""> </span><span class="delimiter">(</span><span class="">simp_all</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">left_commute</span><span class=""> </span><span class="">eq_fold</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="keyword2">end</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">comp_fun_commute_plus_mset</span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;comp_fun_commute (op + :: &#39;a multiset &#8658; _ &#8658; _)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="">standard</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">add_ac</span><span class=""> </span><span class="">comp_def</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">declare</span><span class=""> </span><span class="">comp_fun_commute.fold_mset_insert</span><span class="delimiter">[</span><span class="">OF</span><span class=""> </span><span class="">comp_fun_commute_plus_mset</span><span class="delimiter">,</span><span class=""> </span><span class="">simp</span><span class="delimiter">]</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">in_mset_fold_plus_iff</span><span class="delimiter">[</span><span class="">iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;x &#8712;# fold_mset (op +) M NN &#10231; x &#8712;# M &#8744; (&#8707;N. N &#8712;# NN &#8743; x &#8712;# N)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">NN</span><span class="delimiter">)</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">
</span><span class="keyword1">notation</span><span class=""> </span><span class="">times</span><span class=""> </span><span class="delimiter">(</span><span class="keyword2">infixl</span><span class=""> </span><span class="string">&quot;*&quot;</span><span class=""> </span><span class="">70</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1">notation</span><span class=""> </span><span class="">Groups.one</span><span class=""> </span><span class="delimiter">(</span><span class="string">&quot;1&quot;</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">context</span><span class=""> </span><span class="">comm_monoid_add</span><span class="">
</span><span class="keyword2">begin</span><span class="">
</span><span class="">
</span><span class="keyword1">sublocale</span><span class=""> </span><span class="">msetsum</span><span class="delimiter">:</span><span class=""> </span><span class="">comm_monoid_mset</span><span class=""> </span><span class="">plus</span><span class=""> </span><span class="">0</span><span class="">
</span><span class="">  </span><span class="keyword2">defines</span><span class=""> </span><span class="">msetsum</span><span class=""> </span><span class="delimiter">=</span><span class=""> </span><span class="">msetsum.F</span><span class=""> </span><span class="keyword1">..</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="delimiter">(</span><span class="keyword2">in</span><span class=""> </span><span class="">semiring_1</span><span class="delimiter">)</span><span class=""> </span><span class="">msetsum_replicate_mset</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="string">&quot;msetsum (replicate_mset n a) = of_nat n * a&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">n</span><span class="delimiter">)</span><span class=""> </span><span class="delimiter">(</span><span class="">simp_all</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">algebra_simps</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">setsum_unfold_msetsum</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="string">&quot;setsum f A = msetsum (image_mset f (mset_set A))&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">cases</span><span class=""> </span><span class="string">&quot;finite A&quot;</span><span class="delimiter">)</span><span class=""> </span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">A</span><span class=""> </span><span class="">rule</span><span class="delimiter">:</span><span class=""> </span><span class="">finite_induct</span><span class="delimiter">,</span><span class=""> </span><span class="">simp_all</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword2">end</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">msetsum_diff</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">fixes</span><span class=""> </span><span class="">M</span><span class=""> </span><span class="">N</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;(&#39;a :: ordered_cancel_comm_monoid_diff) multiset&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;N &#8804;# M &#10233; msetsum (M - N) = msetsum M - msetsum N&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">metis</span><span class=""> </span><span class="">add_diff_cancel_right&#39;</span><span class=""> </span><span class="">msetsum.union</span><span class=""> </span><span class="">subset_mset.diff_add</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">size_eq_msetsum</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;size M = msetsum (image_mset (&#955;_. 1) M)&quot;</span><span class="">
</span><span class="keyword1">proof</span><span class=""> </span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">M</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword3">case</span><span class=""> </span><span class="">empty</span><span class=""> </span><span class="keyword1">then</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="var">?case</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="keyword1">next</span><span class="">
</span><span class="">  </span><span class="keyword3">case</span><span class=""> </span><span class="delimiter">(</span><span class="">add</span><span class=""> </span><span class="">M</span><span class=""> </span><span class="">x</span><span class="delimiter">)</span><span class=""> </span><span class="keyword1">then</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="var">?case</span><span class="">
</span><span class="">    </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">cases</span><span class=""> </span><span class="string">&quot;x &#8712; set_mset M&quot;</span><span class="delimiter">)</span><span class="">
</span><span class="">      </span><span class="delimiter">(</span><span class="">simp_all</span><span class=""> </span><span class="">del</span><span class="delimiter">:</span><span class=""> </span><span class="">mem_set_mset_iff</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">size_multiset_overloaded_eq</span><span class=""> </span><span class="">setsum.distrib</span><span class=""> </span><span class="">setsum.delta&#39;</span><span class=""> </span><span class="">insert_absorb</span><span class="delimiter">,</span><span class=""> </span><span class="">simp</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="">
</span><span class="keyword1">abbreviation</span><span class=""> </span><span class="">Union_mset</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;&#39;a multiset multiset &#8658; &#39;a multiset&quot;</span><span class="">  </span><span class="delimiter">(</span><span class="string">&quot;&#8899;#_&quot;</span><span class=""> </span><span class="delimiter">[</span><span class="">900</span><span class="delimiter">]</span><span class=""> </span><span class="">900</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword2">where</span><span class=""> </span><span class="string">&quot;&#8899;# MM &#8801; msetsum MM&quot;</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">set_mset_Union_mset</span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;set_mset (&#8899;# MM) = (&#8899;M &#8712; set_mset MM. set_mset M)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">MM</span><span class="delimiter">)</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">in_Union_mset_iff</span><span class="delimiter">[</span><span class="">iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;x &#8712;# &#8899;# MM &#10231; (&#8707;M. M &#8712;# MM &#8743; x &#8712;# M)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">MM</span><span class="delimiter">)</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">
</span><span class="keyword1">syntax</span><span class=""> </span><span class="delimiter">(</span><span class="">ASCII</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="string">&quot;_msetsum_image&quot;</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;pttrn &#8658; &#39;b set &#8658; &#39;a &#8658; &#39;a::comm_monoid_add&quot;</span><span class="">  </span><span class="delimiter">(</span><span class="string">&quot;(3SUM _:#_. _)&quot;</span><span class=""> </span><span class="delimiter">[</span><span class="">0</span><span class="delimiter">,</span><span class=""> </span><span class="">51</span><span class="delimiter">,</span><span class=""> </span><span class="">10</span><span class="delimiter">]</span><span class=""> </span><span class="">10</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1">syntax</span><span class="">
</span><span class="">  </span><span class="string">&quot;_msetsum_image&quot;</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;pttrn &#8658; &#39;b set &#8658; &#39;a &#8658; &#39;a::comm_monoid_add&quot;</span><span class="">  </span><span class="delimiter">(</span><span class="string">&quot;(3&#8721;_&#8712;#_. _)&quot;</span><span class=""> </span><span class="delimiter">[</span><span class="">0</span><span class="delimiter">,</span><span class=""> </span><span class="">51</span><span class="delimiter">,</span><span class=""> </span><span class="">10</span><span class="delimiter">]</span><span class=""> </span><span class="">10</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1">translations</span><span class="">
</span><span class="">  </span><span class="string">&quot;&#8721;i &#8712;# A. b&quot;</span><span class=""> </span><span class="delimiter">&#8652;</span><span class=""> </span><span class="string">&quot;CONST msetsum (CONST image_mset (&#955;i. b) A)&quot;</span><span class="">
</span><span class="">
</span><span class="keyword1">context</span><span class=""> </span><span class="">comm_monoid_mult</span><span class="">
</span><span class="keyword2">begin</span><span class="">
</span><span class="">
</span><span class="keyword1">sublocale</span><span class=""> </span><span class="">msetprod</span><span class="delimiter">:</span><span class=""> </span><span class="">comm_monoid_mset</span><span class=""> </span><span class="">times</span><span class=""> </span><span class="">1</span><span class="">
</span><span class="">  </span><span class="keyword2">defines</span><span class=""> </span><span class="">msetprod</span><span class=""> </span><span class="delimiter">=</span><span class=""> </span><span class="">msetprod.F</span><span class=""> </span><span class="keyword1">..</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">msetprod_empty</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="string">&quot;msetprod {#} = 1&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">fact</span><span class=""> </span><span class="">msetprod.empty</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">msetprod_singleton</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="string">&quot;msetprod {#x#} = x&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">fact</span><span class=""> </span><span class="">msetprod.singleton</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">msetprod_Un</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="string">&quot;msetprod (A + B) = msetprod A * msetprod B&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">fact</span><span class=""> </span><span class="">msetprod.union</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">msetprod_replicate_mset</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="string">&quot;msetprod (replicate_mset n a) = a ^ n&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">n</span><span class="delimiter">)</span><span class=""> </span><span class="delimiter">(</span><span class="">simp_all</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">ac_simps</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">setprod_unfold_msetprod</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="string">&quot;setprod f A = msetprod (image_mset f (mset_set A))&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">cases</span><span class=""> </span><span class="string">&quot;finite A&quot;</span><span class="delimiter">)</span><span class=""> </span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">A</span><span class=""> </span><span class="">rule</span><span class="delimiter">:</span><span class=""> </span><span class="">finite_induct</span><span class="delimiter">,</span><span class=""> </span><span class="">simp_all</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">msetprod_multiplicity</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="string">&quot;msetprod M = setprod (&#955;x. x ^ count M x) (set_mset M)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">fold_mset_def</span><span class=""> </span><span class="">setprod.eq_fold</span><span class=""> </span><span class="">msetprod.eq_fold</span><span class=""> </span><span class="">funpow_times_power</span><span class=""> </span><span class="">comp_def</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword2">end</span><span class="">
</span><span class="">
</span><span class="keyword1">syntax</span><span class=""> </span><span class="delimiter">(</span><span class="">ASCII</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="string">&quot;_msetprod_image&quot;</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;pttrn &#8658; &#39;b set &#8658; &#39;a &#8658; &#39;a::comm_monoid_mult&quot;</span><span class="">  </span><span class="delimiter">(</span><span class="string">&quot;(3PROD _:#_. _)&quot;</span><span class=""> </span><span class="delimiter">[</span><span class="">0</span><span class="delimiter">,</span><span class=""> </span><span class="">51</span><span class="delimiter">,</span><span class=""> </span><span class="">10</span><span class="delimiter">]</span><span class=""> </span><span class="">10</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1">syntax</span><span class="">
</span><span class="">  </span><span class="string">&quot;_msetprod_image&quot;</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;pttrn &#8658; &#39;b set &#8658; &#39;a &#8658; &#39;a::comm_monoid_mult&quot;</span><span class="">  </span><span class="delimiter">(</span><span class="string">&quot;(3&#8719;_&#8712;#_. _)&quot;</span><span class=""> </span><span class="delimiter">[</span><span class="">0</span><span class="delimiter">,</span><span class=""> </span><span class="">51</span><span class="delimiter">,</span><span class=""> </span><span class="">10</span><span class="delimiter">]</span><span class=""> </span><span class="">10</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1">translations</span><span class="">
</span><span class="">  </span><span class="string">&quot;&#8719;i &#8712;# A. b&quot;</span><span class=""> </span><span class="delimiter">&#8652;</span><span class=""> </span><span class="string">&quot;CONST msetprod (CONST image_mset (&#955;i. b) A)&quot;</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="delimiter">(</span><span class="keyword2">in</span><span class=""> </span><span class="">comm_semiring_1</span><span class="delimiter">)</span><span class=""> </span><span class="">dvd_msetprod</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="string">&quot;x &#8712;# A&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;x dvd msetprod A&quot;</span><span class="">
</span><span class="keyword1">proof</span><span class=""> </span><span class="">-</span><span class="">
</span><span class="">  </span><span class="keyword1">from</span><span class=""> </span><span class="">assms</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;A = (A - {#x#}) + {#x#}&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">  </span><span class="keyword1">then</span><span class=""> </span><span class="keyword3">obtain</span><span class=""> </span><span class="">B</span><span class=""> </span><span class="keyword2">where</span><span class=""> </span><span class="string">&quot;A = B + {#x#}&quot;</span><span class=""> </span><span class="keyword1">..</span><span class="">
</span><span class="">  </span><span class="keyword1">then</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="var">?thesis</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="">
</span><span class="keyword1">subsection</span><span class=""> </span><span class="cartouche">&#8249;Alternative representations&#8250;</span><span class="">
</span><span class="">
</span><span class="keyword1">subsubsection</span><span class=""> </span><span class="cartouche">&#8249;Lists&#8250;</span><span class="">
</span><span class="">
</span><span class="keyword1">context</span><span class=""> </span><span class="">linorder</span><span class="">
</span><span class="keyword2">begin</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">mset_insort</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="string">&quot;mset (insort_key k x xs) = {#x#} + mset xs&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">xs</span><span class="delimiter">)</span><span class=""> </span><span class="delimiter">(</span><span class="">simp_all</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">ac_simps</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">mset_sort</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="string">&quot;mset (sort_key k xs) = mset xs&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">xs</span><span class="delimiter">)</span><span class=""> </span><span class="delimiter">(</span><span class="">simp_all</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">ac_simps</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">text</span><span class=""> </span><span class="cartouche">&#8249;
  This lemma shows which properties suffice to show that a function
  &#8249;f&#8250; with &#8249;f xs = ys&#8250; behaves like sort.
&#8250;</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">properties_for_sort_key</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="string">&quot;mset ys = mset xs&quot;</span><span class="">
</span><span class="">    </span><span class="keyword2">and</span><span class=""> </span><span class="string">&quot;&#8896;k. k &#8712; set ys &#10233; filter (&#955;x. f k = f x) ys = filter (&#955;x. f k = f x) xs&quot;</span><span class="">
</span><span class="">    </span><span class="keyword2">and</span><span class=""> </span><span class="string">&quot;sorted (map f ys)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;sort_key f xs = ys&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">using</span><span class=""> </span><span class="">assms</span><span class="">
</span><span class="keyword1">proof</span><span class=""> </span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">xs</span><span class=""> </span><span class="">arbitrary</span><span class="delimiter">:</span><span class=""> </span><span class="">ys</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword3">case</span><span class=""> </span><span class="">Nil</span><span class=""> </span><span class="keyword1">then</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="var">?case</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="keyword1">next</span><span class="">
</span><span class="">  </span><span class="keyword3">case</span><span class=""> </span><span class="delimiter">(</span><span class="">Cons</span><span class=""> </span><span class="">x</span><span class=""> </span><span class="">xs</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">from</span><span class=""> </span><span class="">Cons.prems</span><span class="delimiter">(</span><span class="">2</span><span class="delimiter">)</span><span class=""> </span><span class="keyword1">have</span><span class="">
</span><span class="">    </span><span class="string">&quot;&#8704;k &#8712; set ys. filter (&#955;x. f k = f x) (remove1 x ys) = filter (&#955;x. f k = f x) xs&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">filter_remove1</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">with</span><span class=""> </span><span class="">Cons.prems</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;sort_key f xs = remove1 x ys&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span class=""> </span><span class="">Cons.hyps</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">sorted_map_remove1</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">moreover</span><span class=""> </span><span class="keyword1">from</span><span class=""> </span><span class="">Cons.prems</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;x &#8712; set ys&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">mem_set_multiset_eq</span><span class=""> </span><span class="">intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span class=""> </span><span class="">ccontr</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">ultimately</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="var">?case</span><span class=""> </span><span class="keyword1">using</span><span class=""> </span><span class="">Cons.prems</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">insort_key_remove1</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">properties_for_sort</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="">multiset</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;mset ys = mset xs&quot;</span><span class="">
</span><span class="">    </span><span class="keyword2">and</span><span class=""> </span><span class="string">&quot;sorted ys&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;sort xs = ys&quot;</span><span class="">
</span><span class="keyword1">proof</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">properties_for_sort_key</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">from</span><span class=""> </span><span class="">multiset</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;mset ys = mset xs&quot;</span><span class=""> </span><span class="keyword1">.</span><span class="">
</span><span class="">  </span><span class="keyword1">from</span><span class=""> </span><span class="cartouche">&#8249;sorted ys&#8250;</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;sorted (map (&#955;x. x) ys)&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">  </span><span class="keyword1">from</span><span class=""> </span><span class="">multiset</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;length (filter (&#955;y. k = y) ys) = length (filter (&#955;x. k = x) xs)&quot;</span><span class=""> </span><span class="keyword2">for</span><span class=""> </span><span class="">k</span><span class="">
</span><span class="">    </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">mset_eq_length_filter</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">then</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;replicate (length (filter (&#955;y. k = y) ys)) k =
    replicate (length (filter (&#955;x. k = x) xs)) k&quot;</span><span class=""> </span><span class="keyword2">for</span><span class=""> </span><span class="">k</span><span class="">
</span><span class="">    </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">  </span><span class="keyword1">then</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;k &#8712; set ys &#10233; filter (&#955;y. k = y) ys = filter (&#955;x. k = x) xs&quot;</span><span class=""> </span><span class="keyword2">for</span><span class=""> </span><span class="">k</span><span class="">
</span><span class="">    </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">replicate_length_filter</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">sort_key_inj_key_eq</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="">mset_equal</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;mset xs = mset ys&quot;</span><span class="">
</span><span class="">    </span><span class="keyword2">and</span><span class=""> </span><span class="string">&quot;inj_on f (set xs)&quot;</span><span class="">
</span><span class="">    </span><span class="keyword2">and</span><span class=""> </span><span class="string">&quot;sorted (map f ys)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;sort_key f xs = ys&quot;</span><span class="">
</span><span class="keyword1">proof</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">properties_for_sort_key</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">from</span><span class=""> </span><span class="">mset_equal</span><span class="">
</span><span class="">  </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;mset ys = mset xs&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">  </span><span class="keyword1">from</span><span class=""> </span><span class="cartouche">&#8249;sorted (map f ys)&#8250;</span><span class="">
</span><span class="">  </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;sorted (map f ys)&quot;</span><span class=""> </span><span class="keyword1">.</span><span class="">
</span><span class="">  </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;[x&#8592;ys . f k = f x] = [x&#8592;xs . f k = f x]&quot;</span><span class=""> </span><span class="keyword2">if</span><span class=""> </span><span class="string">&quot;k &#8712; set ys&quot;</span><span class=""> </span><span class="keyword2">for</span><span class=""> </span><span class="">k</span><span class="">
</span><span class="">  </span><span class="keyword1">proof</span><span class=""> </span><span class="">-</span><span class="">
</span><span class="">    </span><span class="keyword1">from</span><span class=""> </span><span class="">mset_equal</span><span class="">
</span><span class="">    </span><span class="keyword1">have</span><span class=""> </span><span class="">set_equal</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;set xs = set ys&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">mset_eq_setD</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1">with</span><span class=""> </span><span class="">that</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;insert k (set ys) = set ys&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">    </span><span class="keyword1">with</span><span class=""> </span><span class="cartouche">&#8249;inj_on f (set xs)&#8250;</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="">inj</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;inj_on f (insert k (set ys))&quot;</span><span class="">
</span><span class="">      </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">set_equal</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1">from</span><span class=""> </span><span class="">inj</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;[x&#8592;ys . f k = f x] = filter (HOL.eq k) ys&quot;</span><span class="">
</span><span class="">      </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span class=""> </span><span class="">inj_on_filter_key_eq</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1">also</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;&#8230; = replicate (count (mset ys) k) k&quot;</span><span class="">
</span><span class="">      </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">replicate_count_mset_eq_filter_eq</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1">also</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;&#8230; = replicate (count (mset xs) k) k&quot;</span><span class="">
</span><span class="">      </span><span class="keyword1">using</span><span class=""> </span><span class="">mset_equal</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">    </span><span class="keyword1">also</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;&#8230; = filter (HOL.eq k) xs&quot;</span><span class="">
</span><span class="">      </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">replicate_count_mset_eq_filter_eq</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1">also</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;&#8230; = [x&#8592;xs . f k = f x]&quot;</span><span class="">
</span><span class="">      </span><span class="keyword1">using</span><span class=""> </span><span class="">inj</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span class=""> </span><span class="">inj_on_filter_key_eq</span><span class=""> </span><span class="delimiter">[</span><span class="">symmetric</span><span class="delimiter">]</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">set_equal</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1">finally</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="var">?thesis</span><span class=""> </span><span class="keyword1">.</span><span class="">
</span><span class="">  </span><span class="keyword1">qed</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">sort_key_eq_sort_key</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="string">&quot;mset xs = mset ys&quot;</span><span class="">
</span><span class="">    </span><span class="keyword2">and</span><span class=""> </span><span class="string">&quot;inj_on f (set xs)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;sort_key f xs = sort_key f ys&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">sort_key_inj_key_eq</span><span class="delimiter">)</span><span class=""> </span><span class="delimiter">(</span><span class="">simp_all</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">assms</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">sort_key_by_quicksort</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="string">&quot;sort_key f xs = sort_key f [x&#8592;xs. f x &lt; f (xs ! (length xs div 2))]
    @ [x&#8592;xs. f x = f (xs ! (length xs div 2))]
    @ sort_key f [x&#8592;xs. f x &gt; f (xs ! (length xs div 2))]&quot;</span><span class=""> </span><span class="delimiter">(</span><span class="keyword2">is</span><span class=""> </span><span class="string">&quot;sort_key f ?lhs = ?rhs&quot;</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1">proof</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">properties_for_sort_key</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;mset ?rhs = mset ?lhs&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">multiset_eqI</span><span class="delimiter">)</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">mset_filter</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;sorted (map f ?rhs)&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">sorted_append</span><span class=""> </span><span class="">intro</span><span class="delimiter">:</span><span class=""> </span><span class="">sorted_map_same</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1">next</span><span class="">
</span><span class="">  </span><span class="keyword3">fix</span><span class=""> </span><span class="">l</span><span class="">
</span><span class="">  </span><span class="keyword3">assume</span><span class=""> </span><span class="string">&quot;l &#8712; set ?rhs&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">let</span><span class=""> </span><span class="var">?pivot</span><span class=""> </span><span class="delimiter">=</span><span class=""> </span><span class="string">&quot;f (xs ! (length xs div 2))&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">have</span><span class=""> </span><span class="">*</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;&#8896;x. f l = f x &#10231; f x = f l&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">  </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;[x &#8592; sort_key f xs . f x = f l] = [x &#8592; xs. f x = f l]&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">filter_sort</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">properties_for_sort_key</span><span class="delimiter">)</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">intro</span><span class="delimiter">:</span><span class=""> </span><span class="">sorted_map_same</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">with</span><span class=""> </span><span class="">*</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="">**</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;[x &#8592; sort_key f xs . f l = f x] = [x &#8592; xs. f l = f x]&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">  </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;&#8896;x P. P (f x) ?pivot &#8743; f l = f x &#10231; P (f l) ?pivot &#8743; f l = f x&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">  </span><span class="keyword1">then</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;&#8896;P. [x &#8592; sort_key f xs . P (f x) ?pivot &#8743; f l = f x] =
    [x &#8592; sort_key f xs. P (f l) ?pivot &#8743; f l = f x]&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">  </span><span class="keyword1">note</span><span class=""> </span><span class="">***</span><span class=""> </span><span class="delimiter">=</span><span class=""> </span><span class="">this</span><span class=""> </span><span class="delimiter">[</span><span class="">of</span><span class=""> </span><span class="string">&quot;op &lt;&quot;</span><span class="delimiter">]</span><span class=""> </span><span class="">this</span><span class=""> </span><span class="delimiter">[</span><span class="">of</span><span class=""> </span><span class="string">&quot;op &gt;&quot;</span><span class="delimiter">]</span><span class=""> </span><span class="">this</span><span class=""> </span><span class="delimiter">[</span><span class="">of</span><span class=""> </span><span class="string">&quot;op =&quot;</span><span class="delimiter">]</span><span class="">
</span><span class="">  </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;[x &#8592; ?rhs. f l = f x] = [x &#8592; ?lhs. f l = f x]&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">proof</span><span class=""> </span><span class="delimiter">(</span><span class="">cases</span><span class=""> </span><span class="string">&quot;f l&quot;</span><span class=""> </span><span class="var">?pivot</span><span class=""> </span><span class="">rule</span><span class="delimiter">:</span><span class=""> </span><span class="">linorder_cases</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword3">case</span><span class=""> </span><span class="">less</span><span class="">
</span><span class="">    </span><span class="keyword1">then</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;f l &#8800; ?pivot&quot;</span><span class=""> </span><span class="keyword2">and</span><span class=""> </span><span class="string">&quot;&#172; f l &gt; ?pivot&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">    </span><span class="keyword1">with</span><span class=""> </span><span class="">less</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="var">?thesis</span><span class="">
</span><span class="">      </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">filter_sort</span><span class=""> </span><span class="delimiter">[</span><span class="">symmetric</span><span class="delimiter">]</span><span class=""> </span><span class="">**</span><span class=""> </span><span class="">***</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">next</span><span class="">
</span><span class="">    </span><span class="keyword3">case</span><span class=""> </span><span class="">equal</span><span class=""> </span><span class="keyword1">then</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="var">?thesis</span><span class="">
</span><span class="">      </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">*</span><span class=""> </span><span class="">less_le</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">next</span><span class="">
</span><span class="">    </span><span class="keyword3">case</span><span class=""> </span><span class="">greater</span><span class="">
</span><span class="">    </span><span class="keyword1">then</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;f l &#8800; ?pivot&quot;</span><span class=""> </span><span class="keyword2">and</span><span class=""> </span><span class="string">&quot;&#172; f l &lt; ?pivot&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">    </span><span class="keyword1">with</span><span class=""> </span><span class="">greater</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="var">?thesis</span><span class="">
</span><span class="">      </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">filter_sort</span><span class=""> </span><span class="delimiter">[</span><span class="">symmetric</span><span class="delimiter">]</span><span class=""> </span><span class="">**</span><span class=""> </span><span class="">***</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">qed</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">sort_by_quicksort</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="string">&quot;sort xs = sort [x&#8592;xs. x &lt; xs ! (length xs div 2)]
    @ [x&#8592;xs. x = xs ! (length xs div 2)]
    @ sort [x&#8592;xs. x &gt; xs ! (length xs div 2)]&quot;</span><span class=""> </span><span class="delimiter">(</span><span class="keyword2">is</span><span class=""> </span><span class="string">&quot;sort ?lhs = ?rhs&quot;</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">using</span><span class=""> </span><span class="">sort_key_by_quicksort</span><span class=""> </span><span class="delimiter">[</span><span class="">of</span><span class=""> </span><span class="string">&quot;&#955;x. x&quot;</span><span class="delimiter">,</span><span class=""> </span><span class="">symmetric</span><span class="delimiter">]</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">
</span><span class="keyword1">text</span><span class=""> </span><span class="cartouche">&#8249;A stable parametrized quicksort&#8250;</span><span class="">
</span><span class="">
</span><span class="keyword1">definition</span><span class=""> </span><span class="">part</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;(&#39;b &#8658; &#39;a) &#8658; &#39;a &#8658; &#39;b list &#8658; &#39;b list &#215; &#39;b list &#215; &#39;b list&quot;</span><span class=""> </span><span class="keyword2">where</span><span class="">
</span><span class="">  </span><span class="string">&quot;part f pivot xs = ([x &#8592; xs. f x &lt; pivot], [x &#8592; xs. f x = pivot], [x &#8592; xs. pivot &lt; f x])&quot;</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">part_code</span><span class=""> </span><span class="delimiter">[</span><span class="">code</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="string">&quot;part f pivot [] = ([], [], [])&quot;</span><span class="">
</span><span class="">  </span><span class="string">&quot;part f pivot (x # xs) = (let (lts, eqs, gts) = part f pivot xs; x&#39; = f x in
     if x&#39; &lt; pivot then (x # lts, eqs, gts)
     else if x&#39; &gt; pivot then (lts, eqs, x # gts)
     else (lts, x # eqs, gts))&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">part_def</span><span class=""> </span><span class="">Let_def</span><span class=""> </span><span class="">split_def</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">sort_key_by_quicksort_code</span><span class=""> </span><span class="delimiter">[</span><span class="">code</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="string">&quot;sort_key f xs =
    (case xs of
      [] &#8658; []
    | [x] &#8658; xs
    | [x, y] &#8658; (if f x &#8804; f y then xs else [y, x])
    | _ &#8658;
        let (lts, eqs, gts) = part f (f (xs ! (length xs div 2))) xs
        in sort_key f lts @ eqs @ sort_key f gts)&quot;</span><span class="">
</span><span class="keyword1">proof</span><span class=""> </span><span class="delimiter">(</span><span class="">cases</span><span class=""> </span><span class="">xs</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword3">case</span><span class=""> </span><span class="">Nil</span><span class=""> </span><span class="keyword1">then</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="var">?thesis</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="keyword1">next</span><span class="">
</span><span class="">  </span><span class="keyword3">case</span><span class=""> </span><span class="delimiter">(</span><span class="">Cons</span><span class=""> </span><span class="">_</span><span class=""> </span><span class="">ys</span><span class="delimiter">)</span><span class=""> </span><span class="keyword1">note</span><span class=""> </span><span class="">hyps</span><span class=""> </span><span class="delimiter">=</span><span class=""> </span><span class="">Cons</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="var">?thesis</span><span class="">
</span><span class="">  </span><span class="keyword1">proof</span><span class=""> </span><span class="delimiter">(</span><span class="">cases</span><span class=""> </span><span class="">ys</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword3">case</span><span class=""> </span><span class="">Nil</span><span class=""> </span><span class="keyword1">with</span><span class=""> </span><span class="">hyps</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="var">?thesis</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">  </span><span class="keyword1">next</span><span class="">
</span><span class="">    </span><span class="keyword3">case</span><span class=""> </span><span class="delimiter">(</span><span class="">Cons</span><span class=""> </span><span class="">_</span><span class=""> </span><span class="">zs</span><span class="delimiter">)</span><span class=""> </span><span class="keyword1">note</span><span class=""> </span><span class="">hyps</span><span class=""> </span><span class="delimiter">=</span><span class=""> </span><span class="">hyps</span><span class=""> </span><span class="">Cons</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="var">?thesis</span><span class="">
</span><span class="">    </span><span class="keyword1">proof</span><span class=""> </span><span class="delimiter">(</span><span class="">cases</span><span class=""> </span><span class="">zs</span><span class="delimiter">)</span><span class="">
</span><span class="">      </span><span class="keyword3">case</span><span class=""> </span><span class="">Nil</span><span class=""> </span><span class="keyword1">with</span><span class=""> </span><span class="">hyps</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="var">?thesis</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">    </span><span class="keyword1">next</span><span class="">
</span><span class="">      </span><span class="keyword3">case</span><span class=""> </span><span class="">Cons</span><span class="">
</span><span class="">      </span><span class="keyword1">from</span><span class=""> </span><span class="">sort_key_by_quicksort</span><span class=""> </span><span class="delimiter">[</span><span class="">of</span><span class=""> </span><span class="">f</span><span class=""> </span><span class="">xs</span><span class="delimiter">]</span><span class="">
</span><span class="">      </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;sort_key f xs = (let (lts, eqs, gts) = part f (f (xs ! (length xs div 2))) xs
        in sort_key f lts @ eqs @ sort_key f gts)&quot;</span><span class="">
</span><span class="">      </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">only</span><span class="delimiter">:</span><span class=""> </span><span class="">split_def</span><span class=""> </span><span class="">Let_def</span><span class=""> </span><span class="">part_def</span><span class=""> </span><span class="">fst_conv</span><span class=""> </span><span class="">snd_conv</span><span class="delimiter">)</span><span class="">
</span><span class="">      </span><span class="keyword1">with</span><span class=""> </span><span class="">hyps</span><span class=""> </span><span class="">Cons</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="var">?thesis</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">only</span><span class="delimiter">:</span><span class=""> </span><span class="">list.cases</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1">qed</span><span class="">
</span><span class="">  </span><span class="keyword1">qed</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="keyword2">end</span><span class="">
</span><span class="">
</span><span class="keyword1">hide_const</span><span class=""> </span><span class="delimiter">(</span><span class="keyword2">open</span><span class="delimiter">)</span><span class=""> </span><span class="">part</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">mset_remdups_le</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;mset (remdups xs) &#8804;# mset xs&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">xs</span><span class="delimiter">)</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">intro</span><span class="delimiter">:</span><span class=""> </span><span class="">subset_mset.order_trans</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">mset_update</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="string">&quot;i &lt; length ls &#10233; mset (ls[i := v]) = mset ls - {#ls ! i#} + {#v#}&quot;</span><span class="">
</span><span class="keyword1">proof</span><span class=""> </span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">ls</span><span class=""> </span><span class="">arbitrary</span><span class="delimiter">:</span><span class=""> </span><span class="">i</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword3">case</span><span class=""> </span><span class="">Nil</span><span class=""> </span><span class="keyword1">then</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="var">?case</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="keyword1">next</span><span class="">
</span><span class="">  </span><span class="keyword3">case</span><span class=""> </span><span class="delimiter">(</span><span class="">Cons</span><span class=""> </span><span class="">x</span><span class=""> </span><span class="">xs</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword3">show</span><span class=""> </span><span class="var">?case</span><span class="">
</span><span class="">  </span><span class="keyword1">proof</span><span class=""> </span><span class="delimiter">(</span><span class="">cases</span><span class=""> </span><span class="">i</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword3">case</span><span class=""> </span><span class="">0</span><span class=""> </span><span class="keyword1">then</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="var">?thesis</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">  </span><span class="keyword1">next</span><span class="">
</span><span class="">    </span><span class="keyword3">case</span><span class=""> </span><span class="delimiter">(</span><span class="">Suc</span><span class=""> </span><span class="">i&#39;</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1">with</span><span class=""> </span><span class="">Cons</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="var">?thesis</span><span class="">
</span><span class="">      </span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">      </span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">subst</span><span class=""> </span><span class="">add.assoc</span><span class="delimiter">)</span><span class="">
</span><span class="">      </span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">subst</span><span class=""> </span><span class="">add.commute</span><span class=""> </span><span class="delimiter">[</span><span class="">of</span><span class=""> </span><span class="string">&quot;{#v#}&quot;</span><span class=""> </span><span class="string">&quot;{#x#}&quot;</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="">
</span><span class="">      </span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">subst</span><span class=""> </span><span class="">add.assoc</span><span class=""> </span><span class="delimiter">[</span><span class="">symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="">
</span><span class="">      </span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">      </span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">mset_le_multiset_union_diff_commute</span><span class="delimiter">)</span><span class="">
</span><span class="">      </span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">mset_le_single</span><span class=""> </span><span class="">nth_mem_mset</span><span class="delimiter">)</span><span class="">
</span><span class="">      </span><span class="keyword1"><span class="improper">done</span></span><span class="">
</span><span class="">  </span><span class="keyword1">qed</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">mset_swap</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="string">&quot;i &lt; length ls &#10233; j &lt; length ls &#10233;
    mset (ls[j := ls ! i, i := ls ! j]) = mset ls&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">cases</span><span class=""> </span><span class="string">&quot;i = j&quot;</span><span class="delimiter">)</span><span class=""> </span><span class="delimiter">(</span><span class="">simp_all</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">mset_update</span><span class=""> </span><span class="">nth_mem_mset</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="">
</span><span class="keyword1">subsection</span><span class=""> </span><span class="cartouche">&#8249;The multiset order&#8250;</span><span class="">
</span><span class="">
</span><span class="keyword1">subsubsection</span><span class=""> </span><span class="cartouche">&#8249;Well-foundedness&#8250;</span><span class="">
</span><span class="">
</span><span class="keyword1">definition</span><span class=""> </span><span class="">mult1</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;(&#39;a &#215; &#39;a) set &#8658; (&#39;a multiset &#215; &#39;a multiset) set&quot;</span><span class=""> </span><span class="keyword2">where</span><span class="">
</span><span class="">  </span><span class="string">&quot;mult1 r = {(N, M). &#8707;a M0 K. M = M0 + {#a#} &#8743; N = M0 + K &#8743;
      (&#8704;b. b &#8712;# K &#10230; (b, a) &#8712; r)}&quot;</span><span class="">
</span><span class="">
</span><span class="keyword1">definition</span><span class=""> </span><span class="">mult</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;(&#39;a &#215; &#39;a) set &#8658; (&#39;a multiset &#215; &#39;a multiset) set&quot;</span><span class=""> </span><span class="keyword2">where</span><span class="">
</span><span class="">  </span><span class="string">&quot;mult r = (mult1 r)<span class="hidden">&#8679;</span><sup>+</sup>&quot;</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">not_less_empty</span><span class=""> </span><span class="delimiter">[</span><span class="">iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;(M, {#}) &#8713; mult1 r&quot;</span><span class="">
</span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">mult1_def</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">less_add</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="">mult1</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;(N, M0 + {#a#}) &#8712; mult1 r&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class="">
</span><span class="">    </span><span class="string">&quot;(&#8707;M. (M, M0) &#8712; mult1 r &#8743; N = M + {#a#}) &#8744;
     (&#8707;K. (&#8704;b. b &#8712;# K &#10230; (b, a) &#8712; r) &#8743; N = M0 + K)&quot;</span><span class="">
</span><span class="keyword1">proof</span><span class=""> </span><span class="">-</span><span class="">
</span><span class="">  </span><span class="keyword1">let</span><span class=""> </span><span class="var">?r</span><span class=""> </span><span class="delimiter">=</span><span class=""> </span><span class="string">&quot;&#955;K a. &#8704;b. b &#8712;# K &#10230; (b, a) &#8712; r&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">let</span><span class=""> </span><span class="var">?R</span><span class=""> </span><span class="delimiter">=</span><span class=""> </span><span class="string">&quot;&#955;N M. &#8707;a M0 K. M = M0 + {#a#} &#8743; N = M0 + K &#8743; ?r K a&quot;</span><span class="">
</span><span class="">  </span><span class="keyword3">obtain</span><span class=""> </span><span class="">a&#39;</span><span class=""> </span><span class="">M0&#39;</span><span class=""> </span><span class="">K</span><span class=""> </span><span class="keyword2">where</span><span class=""> </span><span class="">M0</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;M0 + {#a#} = M0&#39; + {#a&#39;#}&quot;</span><span class="">
</span><span class="">    </span><span class="keyword2">and</span><span class=""> </span><span class="">N</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;N = M0&#39; + K&quot;</span><span class="">
</span><span class="">    </span><span class="keyword2">and</span><span class=""> </span><span class="">r</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;?r K a&#39;&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">using</span><span class=""> </span><span class="">mult1</span><span class=""> </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">mult1_def</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">  </span><span class="keyword3">show</span><span class=""> </span><span class="var">?thesis</span><span class=""> </span><span class="delimiter">(</span><span class="keyword2">is</span><span class=""> </span><span class="string">&quot;?case1 &#8744; ?case2&quot;</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">proof</span><span class=""> </span><span class="">-</span><span class="">
</span><span class="">    </span><span class="keyword1">from</span><span class=""> </span><span class="">M0</span><span class=""> </span><span class="keyword1">consider</span><span class=""> </span><span class="string">&quot;M0 = M0&#39;&quot;</span><span class=""> </span><span class="string">&quot;a = a&#39;&quot;</span><span class="">
</span><span class="">      </span><span class="delimiter">|</span><span class=""> </span><span class="">K&#39;</span><span class=""> </span><span class="keyword2">where</span><span class=""> </span><span class="string">&quot;M0 = K&#39; + {#a&#39;#}&quot;</span><span class=""> </span><span class="string">&quot;M0&#39; = K&#39; + {#a#}&quot;</span><span class="">
</span><span class="">      </span><span class="keyword1">by</span><span class=""> </span><span class="">atomize_elim</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">only</span><span class="delimiter">:</span><span class=""> </span><span class="">add_eq_conv_ex</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1">then</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="var">?thesis</span><span class="">
</span><span class="">    </span><span class="keyword1">proof</span><span class=""> </span><span class="">cases</span><span class="">
</span><span class="">      </span><span class="keyword3">case</span><span class=""> </span><span class="">1</span><span class="">
</span><span class="">      </span><span class="keyword1">with</span><span class=""> </span><span class="">N</span><span class=""> </span><span class="">r</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;?r K a &#8743; N = M0 + K&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">      </span><span class="keyword1">then</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="var">?case2</span><span class=""> </span><span class="keyword1">..</span><span class="">
</span><span class="">      </span><span class="keyword1">then</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="var">?thesis</span><span class=""> </span><span class="keyword1">..</span><span class="">
</span><span class="">    </span><span class="keyword1">next</span><span class="">
</span><span class="">      </span><span class="keyword3">case</span><span class=""> </span><span class="">2</span><span class="">
</span><span class="">      </span><span class="keyword1">from</span><span class=""> </span><span class="">N</span><span class=""> </span><span class="">2</span><span class="delimiter">(</span><span class="">2</span><span class="delimiter">)</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="">n</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;N = K&#39; + K + {#a#}&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">ac_simps</span><span class="delimiter">)</span><span class="">
</span><span class="">      </span><span class="keyword1">with</span><span class=""> </span><span class="">r</span><span class=""> </span><span class="">2</span><span class="delimiter">(</span><span class="">1</span><span class="delimiter">)</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;?R (K&#39; + K) M0&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">blast</span><span class="">
</span><span class="">      </span><span class="keyword1">with</span><span class=""> </span><span class="">n</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="var">?case1</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">mult1_def</span><span class="delimiter">)</span><span class="">
</span><span class="">      </span><span class="keyword1">then</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="var">?thesis</span><span class=""> </span><span class="keyword1">..</span><span class="">
</span><span class="">    </span><span class="keyword1">qed</span><span class="">
</span><span class="">  </span><span class="keyword1">qed</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">all_accessible</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="string">&quot;wf r&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;&#8704;M. M &#8712; Wellfounded.acc (mult1 r)&quot;</span><span class="">
</span><span class="keyword1">proof</span><span class="">
</span><span class="">  </span><span class="keyword1">let</span><span class=""> </span><span class="var">?R</span><span class=""> </span><span class="delimiter">=</span><span class=""> </span><span class="string">&quot;mult1 r&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">let</span><span class=""> </span><span class="var">?W</span><span class=""> </span><span class="delimiter">=</span><span class=""> </span><span class="string">&quot;Wellfounded.acc ?R&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">{</span><span class="">
</span><span class="">    </span><span class="keyword3">fix</span><span class=""> </span><span class="">M</span><span class=""> </span><span class="">M0</span><span class=""> </span><span class="">a</span><span class="">
</span><span class="">    </span><span class="keyword3">assume</span><span class=""> </span><span class="">M0</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;M0 &#8712; ?W&quot;</span><span class="">
</span><span class="">      </span><span class="keyword2">and</span><span class=""> </span><span class="">wf_hyp</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;&#8896;b. (b, a) &#8712; r &#10233; (&#8704;M &#8712; ?W. M + {#b#} &#8712; ?W)&quot;</span><span class="">
</span><span class="">      </span><span class="keyword2">and</span><span class=""> </span><span class="">acc_hyp</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;&#8704;M. (M, M0) &#8712; ?R &#10230; M + {#a#} &#8712; ?W&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;M0 + {#a#} &#8712; ?W&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">proof</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">accI</span><span class=""> </span><span class="delimiter">[</span><span class="">of</span><span class=""> </span><span class="string">&quot;M0 + {#a#}&quot;</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="">
</span><span class="">      </span><span class="keyword3">fix</span><span class=""> </span><span class="">N</span><span class="">
</span><span class="">      </span><span class="keyword3">assume</span><span class=""> </span><span class="string">&quot;(N, M0 + {#a#}) &#8712; ?R&quot;</span><span class="">
</span><span class="">      </span><span class="keyword1">then</span><span class=""> </span><span class="keyword1">consider</span><span class=""> </span><span class="">M</span><span class=""> </span><span class="keyword2">where</span><span class=""> </span><span class="string">&quot;(M, M0) &#8712; ?R&quot;</span><span class=""> </span><span class="string">&quot;N = M + {#a#}&quot;</span><span class="">
</span><span class="">        </span><span class="delimiter">|</span><span class=""> </span><span class="">K</span><span class=""> </span><span class="keyword2">where</span><span class=""> </span><span class="string">&quot;&#8704;b. b &#8712;# K &#10230; (b, a) &#8712; r&quot;</span><span class=""> </span><span class="string">&quot;N = M0 + K&quot;</span><span class="">
</span><span class="">        </span><span class="keyword1">by</span><span class=""> </span><span class="">atomize_elim</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">less_add</span><span class="delimiter">)</span><span class="">
</span><span class="">      </span><span class="keyword1">then</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;N &#8712; ?W&quot;</span><span class="">
</span><span class="">      </span><span class="keyword1">proof</span><span class=""> </span><span class="">cases</span><span class="">
</span><span class="">        </span><span class="keyword3">case</span><span class=""> </span><span class="">1</span><span class="">
</span><span class="">        </span><span class="keyword1">from</span><span class=""> </span><span class="">acc_hyp</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;(M, M0) &#8712; ?R &#10230; M + {#a#} &#8712; ?W&quot;</span><span class=""> </span><span class="keyword1">..</span><span class="">
</span><span class="">        </span><span class="keyword1">from</span><span class=""> </span><span class="">this</span><span class=""> </span><span class="keyword2">and</span><span class=""> </span><span class="cartouche">&#8249;(M, M0) &#8712; ?R&#8250;</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;M + {#a#} &#8712; ?W&quot;</span><span class=""> </span><span class="keyword1">..</span><span class="">
</span><span class="">        </span><span class="keyword1">then</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;N &#8712; ?W&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">only</span><span class="delimiter">:</span><span class=""> </span><span class="cartouche">&#8249;N = M + {#a#}&#8250;</span><span class="delimiter">)</span><span class="">
</span><span class="">      </span><span class="keyword1">next</span><span class="">
</span><span class="">        </span><span class="keyword3">case</span><span class=""> </span><span class="">2</span><span class="">
</span><span class="">        </span><span class="keyword1">from</span><span class=""> </span><span class="">this</span><span class="delimiter">(</span><span class="">1</span><span class="delimiter">)</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;M0 + K &#8712; ?W&quot;</span><span class="">
</span><span class="">        </span><span class="keyword1">proof</span><span class=""> </span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">K</span><span class="delimiter">)</span><span class="">
</span><span class="">          </span><span class="keyword3">case</span><span class=""> </span><span class="">empty</span><span class="">
</span><span class="">          </span><span class="keyword1">from</span><span class=""> </span><span class="">M0</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;M0 + {#} &#8712; ?W&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">        </span><span class="keyword1">next</span><span class="">
</span><span class="">          </span><span class="keyword3">case</span><span class=""> </span><span class="delimiter">(</span><span class="">add</span><span class=""> </span><span class="">K</span><span class=""> </span><span class="">x</span><span class="delimiter">)</span><span class="">
</span><span class="">          </span><span class="keyword1">from</span><span class=""> </span><span class="">add.prems</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;(x, a) &#8712; r&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">          </span><span class="keyword1">with</span><span class=""> </span><span class="">wf_hyp</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;&#8704;M &#8712; ?W. M + {#x#} &#8712; ?W&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">blast</span><span class="">
</span><span class="">          </span><span class="keyword1">moreover</span><span class=""> </span><span class="keyword1">from</span><span class=""> </span><span class="">add</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;M0 + K &#8712; ?W&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">          </span><span class="keyword1">ultimately</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;(M0 + K) + {#x#} &#8712; ?W&quot;</span><span class=""> </span><span class="keyword1">..</span><span class="">
</span><span class="">          </span><span class="keyword1">then</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;M0 + (K + {#x#}) &#8712; ?W&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">only</span><span class="delimiter">:</span><span class=""> </span><span class="">add.assoc</span><span class="delimiter">)</span><span class="">
</span><span class="">        </span><span class="keyword1">qed</span><span class="">
</span><span class="">        </span><span class="keyword1">then</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;N &#8712; ?W&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">only</span><span class="delimiter">:</span><span class=""> </span><span class="">2</span><span class="delimiter">(</span><span class="">2</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="">
</span><span class="">      </span><span class="keyword1">qed</span><span class="">
</span><span class="">    </span><span class="keyword1">qed</span><span class="">
</span><span class="">  </span><span class="keyword1">}</span><span class=""> </span><span class="keyword1">note</span><span class=""> </span><span class="">tedious_reasoning</span><span class=""> </span><span class="delimiter">=</span><span class=""> </span><span class="">this</span><span class="">
</span><span class="">
</span><span class="">  </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;M &#8712; ?W&quot;</span><span class=""> </span><span class="keyword2">for</span><span class=""> </span><span class="">M</span><span class="">
</span><span class="">  </span><span class="keyword1">proof</span><span class=""> </span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">M</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;{#} &#8712; ?W&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">proof</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">accI</span><span class="delimiter">)</span><span class="">
</span><span class="">      </span><span class="keyword3">fix</span><span class=""> </span><span class="">b</span><span class=""> </span><span class="keyword3">assume</span><span class=""> </span><span class="string">&quot;(b, {#}) &#8712; ?R&quot;</span><span class="">
</span><span class="">      </span><span class="keyword1">with</span><span class=""> </span><span class="">not_less_empty</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;b &#8712; ?W&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">contradiction</span><span class="">
</span><span class="">    </span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="">    </span><span class="keyword3">fix</span><span class=""> </span><span class="">M</span><span class=""> </span><span class="">a</span><span class=""> </span><span class="keyword3">assume</span><span class=""> </span><span class="string">&quot;M &#8712; ?W&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">from</span><span class=""> </span><span class="cartouche">&#8249;wf r&#8250;</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;&#8704;M &#8712; ?W. M + {#a#} &#8712; ?W&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">proof</span><span class=""> </span><span class="">induct</span><span class="">
</span><span class="">      </span><span class="keyword3">fix</span><span class=""> </span><span class="">a</span><span class="">
</span><span class="">      </span><span class="keyword3">assume</span><span class=""> </span><span class="">r</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;&#8896;b. (b, a) &#8712; r &#10233; (&#8704;M &#8712; ?W. M + {#b#} &#8712; ?W)&quot;</span><span class="">
</span><span class="">      </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;&#8704;M &#8712; ?W. M + {#a#} &#8712; ?W&quot;</span><span class="">
</span><span class="">      </span><span class="keyword1">proof</span><span class="">
</span><span class="">        </span><span class="keyword3">fix</span><span class=""> </span><span class="">M</span><span class=""> </span><span class="keyword3">assume</span><span class=""> </span><span class="string">&quot;M &#8712; ?W&quot;</span><span class="">
</span><span class="">        </span><span class="keyword1">then</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;M + {#a#} &#8712; ?W&quot;</span><span class="">
</span><span class="">          </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">acc_induct</span><span class="delimiter">)</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">tedious_reasoning</span><span class=""> </span><span class="delimiter">[</span><span class="">OF</span><span class=""> </span><span class="">_</span><span class=""> </span><span class="">r</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="">
</span><span class="">      </span><span class="keyword1">qed</span><span class="">
</span><span class="">    </span><span class="keyword1">qed</span><span class="">
</span><span class="">    </span><span class="keyword1">from</span><span class=""> </span><span class="">this</span><span class=""> </span><span class="keyword2">and</span><span class=""> </span><span class="cartouche">&#8249;M &#8712; ?W&#8250;</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;M + {#a#} &#8712; ?W&quot;</span><span class=""> </span><span class="keyword1">..</span><span class="">
</span><span class="">  </span><span class="keyword1">qed</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="keyword1">theorem</span><span class=""> </span><span class="">wf_mult1</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;wf r &#10233; wf (mult1 r)&quot;</span><span class="">
</span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">acc_wfI</span><span class="delimiter">)</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">all_accessible</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">theorem</span><span class=""> </span><span class="">wf_mult</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;wf r &#10233; wf (mult r)&quot;</span><span class="">
</span><span class="keyword1">unfolding</span><span class=""> </span><span class="">mult_def</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">wf_trancl</span><span class="delimiter">)</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">wf_mult1</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="">
</span><span class="keyword1">subsubsection</span><span class=""> </span><span class="cartouche">&#8249;Closure-free presentation&#8250;</span><span class="">
</span><span class="">
</span><span class="keyword1">text</span><span class=""> </span><span class="cartouche">&#8249;One direction.&#8250;</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">mult_implies_one_step</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="string">&quot;trans r &#10233; (M, N) &#8712; mult r &#10233;
    &#8707;I J K. N = I + J &#8743; M = I + K &#8743; J &#8800; {#} &#8743;
    (&#8704;k &#8712; set_mset K. &#8707;j &#8712; set_mset J. (k, j) &#8712; r)&quot;</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">unfold</span><span class=""> </span><span class="">mult_def</span><span class=""> </span><span class="">mult1_def</span><span class=""> </span><span class="">set_mset_def</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">erule</span><span class=""> </span><span class="">converse_trancl_induct</span><span class="delimiter">,</span><span class=""> </span><span class="">clarify</span><span class="delimiter">)</span><span class="">
</span><span class=""> </span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">rule_tac</span><span class=""> </span><span class="">x</span><span class=""> </span><span class="delimiter">=</span><span class=""> </span><span class="">M0</span><span class=""> </span><span class="keyword2">in</span><span class=""> </span><span class="">exI</span><span class="delimiter">,</span><span class=""> </span><span class="">simp</span><span class="delimiter">,</span><span class=""> </span><span class="">clarify</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">case_tac</span><span class=""> </span><span class="string">&quot;a &#8712;# K&quot;</span><span class="delimiter">)</span><span class="">
</span><span class=""> </span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">rule_tac</span><span class=""> </span><span class="">x</span><span class=""> </span><span class="delimiter">=</span><span class=""> </span><span class="">I</span><span class=""> </span><span class="keyword2">in</span><span class=""> </span><span class="">exI</span><span class="delimiter">)</span><span class="">
</span><span class=""> </span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="delimiter">(</span><span class="">no_asm</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="">
</span><span class=""> </span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">rule_tac</span><span class=""> </span><span class="">x</span><span class=""> </span><span class="delimiter">=</span><span class=""> </span><span class="string">&quot;(K - {#a#}) + Ka&quot;</span><span class=""> </span><span class="keyword2">in</span><span class=""> </span><span class="">exI</span><span class="delimiter">)</span><span class="">
</span><span class=""> </span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="delimiter">(</span><span class="">no_asm_simp</span><span class="delimiter">)</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">add.assoc</span><span class=""> </span><span class="delimiter">[</span><span class="">symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="">
</span><span class=""> </span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">drule_tac</span><span class=""> </span><span class="">f</span><span class=""> </span><span class="delimiter">=</span><span class=""> </span><span class="string">&quot;&#955;M. M - {#a#}&quot;</span><span class=""> </span><span class="keyword2">and</span><span class=""> </span><span class="">x</span><span class="delimiter">=</span><span class="string">&quot;S + T&quot;</span><span class=""> </span><span class="keyword2">for</span><span class=""> </span><span class="">S</span><span class=""> </span><span class="">T</span><span class=""> </span><span class="keyword2">in</span><span class=""> </span><span class="">arg_cong</span><span class="delimiter">)</span><span class="">
</span><span class=""> </span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">diff_union_single_conv</span><span class="delimiter">)</span><span class="">
</span><span class=""> </span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="delimiter">(</span><span class="">no_asm_use</span><span class="delimiter">)</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">trans_def</span><span class="delimiter">)</span><span class="">
</span><span class=""> </span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="">blast</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">subgoal_tac</span><span class=""> </span><span class="string">&quot;a &#8712;# I&quot;</span><span class="delimiter">)</span><span class="">
</span><span class=""> </span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">rule_tac</span><span class=""> </span><span class="">x</span><span class=""> </span><span class="delimiter">=</span><span class=""> </span><span class="string">&quot;I - {#a#}&quot;</span><span class=""> </span><span class="keyword2">in</span><span class=""> </span><span class="">exI</span><span class="delimiter">)</span><span class="">
</span><span class=""> </span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">rule_tac</span><span class=""> </span><span class="">x</span><span class=""> </span><span class="delimiter">=</span><span class=""> </span><span class="string">&quot;J + {#a#}&quot;</span><span class=""> </span><span class="keyword2">in</span><span class=""> </span><span class="">exI</span><span class="delimiter">)</span><span class="">
</span><span class=""> </span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">rule_tac</span><span class=""> </span><span class="">x</span><span class=""> </span><span class="delimiter">=</span><span class=""> </span><span class="string">&quot;K + Ka&quot;</span><span class=""> </span><span class="keyword2">in</span><span class=""> </span><span class="">exI</span><span class="delimiter">)</span><span class="">
</span><span class=""> </span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">conjI</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">multiset_eq_iff</span><span class=""> </span><span class="">split</span><span class="delimiter">:</span><span class=""> </span><span class="">nat_diff_split</span><span class="delimiter">)</span><span class="">
</span><span class=""> </span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">conjI</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">drule_tac</span><span class=""> </span><span class="">f</span><span class=""> </span><span class="delimiter">=</span><span class=""> </span><span class="string">&quot;&#955;M. M - {#a#}&quot;</span><span class=""> </span><span class="keyword2">and</span><span class=""> </span><span class="">x</span><span class="delimiter">=</span><span class="string">&quot;S + T&quot;</span><span class=""> </span><span class="keyword2">for</span><span class=""> </span><span class="">S</span><span class=""> </span><span class="">T</span><span class=""> </span><span class="keyword2">in</span><span class=""> </span><span class="">arg_cong</span><span class="delimiter">,</span><span class=""> </span><span class="">simp</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">multiset_eq_iff</span><span class=""> </span><span class="">split</span><span class="delimiter">:</span><span class=""> </span><span class="">nat_diff_split</span><span class="delimiter">)</span><span class="">
</span><span class=""> </span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="delimiter">(</span><span class="">no_asm_use</span><span class="delimiter">)</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">trans_def</span><span class="delimiter">)</span><span class="">
</span><span class=""> </span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="">blast</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">subgoal_tac</span><span class=""> </span><span class="string">&quot;a &#8712;# (M0 + {#a#})&quot;</span><span class="delimiter">)</span><span class="">
</span><span class=""> </span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="delimiter">(</span><span class="">no_asm</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">done</span></span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">one_step_implies_mult_aux</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="string">&quot;&#8704;I J K. size J = n &#8743; J &#8800; {#} &#8743; (&#8704;k &#8712; set_mset K. &#8707;j &#8712; set_mset J. (k, j) &#8712; r)
    &#10230; (I + K, I + J) &#8712; mult r&quot;</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">n</span><span class="delimiter">)</span><span class="">
</span><span class=""> </span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">frule</span><span class=""> </span><span class="">size_eq_Suc_imp_eq_union</span><span class="delimiter">,</span><span class=""> </span><span class="">clarify</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">rename_tac</span><span class=""> </span><span class="string">&quot;J&#39;&quot;</span><span class="delimiter">,</span><span class=""> </span><span class="">simp</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">erule</span><span class=""> </span><span class="">notE</span><span class="delimiter">,</span><span class=""> </span><span class="">auto</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">case_tac</span><span class=""> </span><span class="string">&quot;J&#39; = {#}&quot;</span><span class="delimiter">)</span><span class="">
</span><span class=""> </span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">mult_def</span><span class="delimiter">)</span><span class="">
</span><span class=""> </span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">r_into_trancl</span><span class="delimiter">)</span><span class="">
</span><span class=""> </span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">mult1_def</span><span class=""> </span><span class="">set_mset_def</span><span class="delimiter">,</span><span class=""> </span><span class="">blast</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1">txt</span><span class=""> </span><span class="cartouche">&#8249;Now we know @{term &quot;J&#39; &#8800; {#}&quot;}.&#8250;</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">cut_tac</span><span class=""> </span><span class="">M</span><span class=""> </span><span class="delimiter">=</span><span class=""> </span><span class="">K</span><span class=""> </span><span class="keyword2">and</span><span class=""> </span><span class="">P</span><span class=""> </span><span class="delimiter">=</span><span class=""> </span><span class="string">&quot;&#955;x. (x, a) &#8712; r&quot;</span><span class=""> </span><span class="keyword2">in</span><span class=""> </span><span class="">multiset_partition</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">erule_tac</span><span class=""> </span><span class="">P</span><span class=""> </span><span class="delimiter">=</span><span class=""> </span><span class="string">&quot;&#8704;k &#8712; set_mset K. P k&quot;</span><span class=""> </span><span class="keyword2">for</span><span class=""> </span><span class="">P</span><span class=""> </span><span class="keyword2">in</span><span class=""> </span><span class="">rev_mp</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">erule</span><span class=""> </span><span class="">ssubst</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">Ball_def</span><span class="delimiter">,</span><span class=""> </span><span class="">auto</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">subgoal_tac</span><span class="">
</span><span class="">  </span><span class="string">&quot;((I + {# x &#8712;# K. (x, a) &#8712; r #}) + {# x &#8712;# K. (x, a) &#8713; r #},
    (I + {# x &#8712;# K. (x, a) &#8712; r #}) + J&#39;) &#8712; mult r&quot;</span><span class="delimiter">)</span><span class="">
</span><span class=""> </span><span class="keyword1"><span class="improper">prefer</span></span><span class=""> </span><span class="">2</span><span class="">
</span><span class=""> </span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="">force</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="delimiter">(</span><span class="">no_asm_use</span><span class="delimiter">)</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">add.assoc</span><span class=""> </span><span class="delimiter">[</span><span class="">symmetric</span><span class="delimiter">]</span><span class=""> </span><span class="">mult_def</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">erule</span><span class=""> </span><span class="">trancl_trans</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">r_into_trancl</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">mult1_def</span><span class=""> </span><span class="">set_mset_def</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">rule_tac</span><span class=""> </span><span class="">x</span><span class=""> </span><span class="delimiter">=</span><span class=""> </span><span class="">a</span><span class=""> </span><span class="keyword2">in</span><span class=""> </span><span class="">exI</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">rule_tac</span><span class=""> </span><span class="">x</span><span class=""> </span><span class="delimiter">=</span><span class=""> </span><span class="string">&quot;I + J&#39;&quot;</span><span class=""> </span><span class="keyword2">in</span><span class=""> </span><span class="">exI</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">ac_simps</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">done</span></span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">one_step_implies_mult</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="string">&quot;trans r &#10233; J &#8800; {#} &#10233; &#8704;k &#8712; set_mset K. &#8707;j &#8712; set_mset J. (k, j) &#8712; r
    &#10233; (I + K, I + J) &#8712; mult r&quot;</span><span class="">
</span><span class="keyword1">using</span><span class=""> </span><span class="">one_step_implies_mult_aux</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">blast</span><span class="">
</span><span class="">
</span><span class="">
</span><span class="keyword1">subsubsection</span><span class=""> </span><span class="cartouche">&#8249;Partial-order properties&#8250;</span><span class="">
</span><span class="">
</span><span class="keyword1">definition</span><span class=""> </span><span class="">less_multiset</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;&#39;a::order multiset &#8658; &#39;a multiset &#8658; bool&quot;</span><span class="">  </span><span class="delimiter">(</span><span class="keyword2">infix</span><span class=""> </span><span class="string">&quot;#&#8834;#&quot;</span><span class=""> </span><span class="">50</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword2">where</span><span class=""> </span><span class="string">&quot;M&#39; #&#8834;# M &#10231; (M&#39;, M) &#8712; mult {(x&#39;, x). x&#39; &lt; x}&quot;</span><span class="">
</span><span class="">
</span><span class="keyword1">definition</span><span class=""> </span><span class="">le_multiset</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;&#39;a::order multiset &#8658; &#39;a multiset &#8658; bool&quot;</span><span class="">  </span><span class="delimiter">(</span><span class="keyword2">infix</span><span class=""> </span><span class="string">&quot;#&#8838;#&quot;</span><span class=""> </span><span class="">50</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword2">where</span><span class=""> </span><span class="string">&quot;M&#39; #&#8838;# M &#10231; M&#39; #&#8834;# M &#8744; M&#39; = M&quot;</span><span class="">
</span><span class="">
</span><span class="keyword1">notation</span><span class=""> </span><span class="delimiter">(</span><span class="">ASCII</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="">less_multiset</span><span class=""> </span><span class="delimiter">(</span><span class="keyword2">infix</span><span class=""> </span><span class="string">&quot;#&lt;#&quot;</span><span class=""> </span><span class="">50</span><span class="delimiter">)</span><span class=""> </span><span class="keyword2">and</span><span class="">
</span><span class="">  </span><span class="">le_multiset</span><span class=""> </span><span class="delimiter">(</span><span class="keyword2">infix</span><span class=""> </span><span class="string">&quot;#&lt;=#&quot;</span><span class=""> </span><span class="">50</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">interpretation</span><span class=""> </span><span class="">multiset_order</span><span class="delimiter">:</span><span class=""> </span><span class="">order</span><span class=""> </span><span class="">le_multiset</span><span class=""> </span><span class="">less_multiset</span><span class="">
</span><span class="keyword1">proof</span><span class=""> </span><span class="">-</span><span class="">
</span><span class="">  </span><span class="keyword1">have</span><span class=""> </span><span class="">irrefl</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;&#172; M #&#8834;# M&quot;</span><span class=""> </span><span class="keyword2">for</span><span class=""> </span><span class="">M</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;&#39;a multiset&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">proof</span><span class="">
</span><span class="">    </span><span class="keyword3">assume</span><span class=""> </span><span class="string">&quot;M #&#8834;# M&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">then</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="">MM</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;(M, M) &#8712; mult {(x, y). x &lt; y}&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">less_multiset_def</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;trans {(x&#39;::&#39;a, x). x&#39; &lt; x}&quot;</span><span class="">
</span><span class="">      </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">transI</span><span class="delimiter">)</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">    </span><span class="keyword1">moreover</span><span class=""> </span><span class="keyword1">note</span><span class=""> </span><span class="">MM</span><span class="">
</span><span class="">    </span><span class="keyword1">ultimately</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;&#8707;I J K. M = I + J &#8743; M = I + K
      &#8743; J &#8800; {#} &#8743; (&#8704;k&#8712;set_mset K. &#8707;j&#8712;set_mset J. (k, j) &#8712; {(x, y). x &lt; y})&quot;</span><span class="">
</span><span class="">      </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">mult_implies_one_step</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1">then</span><span class=""> </span><span class="keyword3">obtain</span><span class=""> </span><span class="">I</span><span class=""> </span><span class="">J</span><span class=""> </span><span class="">K</span><span class=""> </span><span class="keyword2">where</span><span class=""> </span><span class="string">&quot;M = I + J&quot;</span><span class=""> </span><span class="keyword2">and</span><span class=""> </span><span class="string">&quot;M = I + K&quot;</span><span class="">
</span><span class="">      </span><span class="keyword2">and</span><span class=""> </span><span class="string">&quot;J &#8800; {#}&quot;</span><span class=""> </span><span class="keyword2">and</span><span class=""> </span><span class="string">&quot;(&#8704;k&#8712;set_mset K. &#8707;j&#8712;set_mset J. (k, j) &#8712; {(x, y). x &lt; y})&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">blast</span><span class="">
</span><span class="">    </span><span class="keyword1">then</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="">*</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;K &#8800; {#}&quot;</span><span class=""> </span><span class="keyword2">and</span><span class=""> </span><span class="">**</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;&#8704;k&#8712;set_mset K. &#8707;j&#8712;set_mset K. k &lt; j&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">    </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;finite (set_mset K)&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">    </span><span class="keyword1">moreover</span><span class=""> </span><span class="keyword1">note</span><span class=""> </span><span class="">**</span><span class="">
</span><span class="">    </span><span class="keyword1">ultimately</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;set_mset K = {}&quot;</span><span class="">
</span><span class="">      </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">rule</span><span class="delimiter">:</span><span class=""> </span><span class="">finite_induct</span><span class="delimiter">)</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">intro</span><span class="delimiter">:</span><span class=""> </span><span class="">order_less_trans</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1">with</span><span class=""> </span><span class="">*</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="">False</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">  </span><span class="keyword1">qed</span><span class="">
</span><span class="">  </span><span class="keyword1">have</span><span class=""> </span><span class="">trans</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;K #&#8834;# M &#10233; M #&#8834;# N &#10233; K #&#8834;# N&quot;</span><span class=""> </span><span class="keyword2">for</span><span class=""> </span><span class="">K</span><span class=""> </span><span class="">M</span><span class=""> </span><span class="">N</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;&#39;a multiset&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">less_multiset_def</span><span class=""> </span><span class="">mult_def</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">blast</span><span class=""> </span><span class="">intro</span><span class="delimiter">:</span><span class=""> </span><span class="">trancl_trans</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;class.order (le_multiset :: &#39;a multiset &#8658; _) less_multiset&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">by</span><span class=""> </span><span class="">standard</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">le_multiset_def</span><span class=""> </span><span class="">irrefl</span><span class=""> </span><span class="">dest</span><span class="delimiter">:</span><span class=""> </span><span class="">trans</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">mult_less_irrefl</span><span class=""> </span><span class="delimiter">[</span><span class="">elim</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">fixes</span><span class=""> </span><span class="">M</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;&#39;a::order multiset&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;M #&#8834;# M &#10233; R&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">
</span><span class="">
</span><span class="keyword1">subsubsection</span><span class=""> </span><span class="cartouche">&#8249;Monotonicity of multiset union&#8250;</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">mult1_union</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;(B, D) &#8712; mult1 r &#10233; (C + B, C + D) &#8712; mult1 r&quot;</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">unfold</span><span class=""> </span><span class="">mult1_def</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">rule_tac</span><span class=""> </span><span class="">x</span><span class=""> </span><span class="delimiter">=</span><span class=""> </span><span class="">a</span><span class=""> </span><span class="keyword2">in</span><span class=""> </span><span class="">exI</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">rule_tac</span><span class=""> </span><span class="">x</span><span class=""> </span><span class="delimiter">=</span><span class=""> </span><span class="string">&quot;C + M0&quot;</span><span class=""> </span><span class="keyword2">in</span><span class=""> </span><span class="">exI</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">add.assoc</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">done</span></span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">union_less_mono2</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;B #&#8834;# D &#10233; C + B #&#8834;# C + (D::&#39;a::order multiset)&quot;</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">unfold</span><span class=""> </span><span class="">less_multiset_def</span><span class=""> </span><span class="">mult_def</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">erule</span><span class=""> </span><span class="">trancl_induct</span><span class="delimiter">)</span><span class="">
</span><span class=""> </span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">blast</span><span class=""> </span><span class="">intro</span><span class="delimiter">:</span><span class=""> </span><span class="">mult1_union</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">blast</span><span class=""> </span><span class="">intro</span><span class="delimiter">:</span><span class=""> </span><span class="">mult1_union</span><span class=""> </span><span class="">trancl_trans</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">done</span></span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">union_less_mono1</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;B #&#8834;# D &#10233; B + C #&#8834;# D + (C::&#39;a::order multiset)&quot;</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">subst</span><span class=""> </span><span class="">add.commute</span><span class=""> </span><span class="delimiter">[</span><span class="">of</span><span class=""> </span><span class="">B</span><span class=""> </span><span class="">C</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">subst</span><span class=""> </span><span class="">add.commute</span><span class=""> </span><span class="delimiter">[</span><span class="">of</span><span class=""> </span><span class="">D</span><span class=""> </span><span class="">C</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">erule</span><span class=""> </span><span class="">union_less_mono2</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">done</span></span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">union_less_mono</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">fixes</span><span class=""> </span><span class="">A</span><span class=""> </span><span class="">B</span><span class=""> </span><span class="">C</span><span class=""> </span><span class="">D</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;&#39;a::order multiset&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;A #&#8834;# C &#10233; B #&#8834;# D &#10233; A + B #&#8834;# C + D&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">blast</span><span class=""> </span><span class="">intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span class=""> </span><span class="">union_less_mono1</span><span class=""> </span><span class="">union_less_mono2</span><span class=""> </span><span class="">multiset_order.less_trans</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">interpretation</span><span class=""> </span><span class="">multiset_order</span><span class="delimiter">:</span><span class=""> </span><span class="">ordered_ab_semigroup_add</span><span class=""> </span><span class="">plus</span><span class=""> </span><span class="">le_multiset</span><span class=""> </span><span class="">less_multiset</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="">standard</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">le_multiset_def</span><span class=""> </span><span class="">intro</span><span class="delimiter">:</span><span class=""> </span><span class="">union_less_mono2</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="">
</span><span class="keyword1">subsubsection</span><span class=""> </span><span class="cartouche">&#8249;Termination proofs with multiset orders&#8250;</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">multi_member_skip</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;x &#8712;# XS &#10233; x &#8712;# {# y #} + XS&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">and</span><span class=""> </span><span class="">multi_member_this</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;x &#8712;# {# x #} + XS&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">and</span><span class=""> </span><span class="">multi_member_last</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;x &#8712;# {# x #}&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">
</span><span class="keyword1">definition</span><span class=""> </span><span class="string">&quot;ms_strict = mult pair_less&quot;</span><span class="">
</span><span class="keyword1">definition</span><span class=""> </span><span class="string">&quot;ms_weak = ms_strict &#8746; Id&quot;</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">ms_reduction_pair</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;reduction_pair (ms_strict, ms_weak)&quot;</span><span class="">
</span><span class="keyword1">unfolding</span><span class=""> </span><span class="">reduction_pair_def</span><span class=""> </span><span class="">ms_strict_def</span><span class=""> </span><span class="">ms_weak_def</span><span class=""> </span><span class="">pair_less_def</span><span class="">
</span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">intro</span><span class="delimiter">:</span><span class=""> </span><span class="">wf_mult1</span><span class=""> </span><span class="">wf_trancl</span><span class=""> </span><span class="">simp</span><span class="delimiter">:</span><span class=""> </span><span class="">mult_def</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">smsI</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="string">&quot;(set_mset A, set_mset B) &#8712; max_strict &#10233; (Z + A, Z + B) &#8712; ms_strict&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">ms_strict_def</span><span class="">
</span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">one_step_implies_mult</span><span class="delimiter">)</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">max_strict_def</span><span class=""> </span><span class="">pair_less_def</span><span class=""> </span><span class="">elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span class="">max_ext.cases</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">wmsI</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="string">&quot;(set_mset A, set_mset B) &#8712; max_strict &#8744; A = {#} &#8743; B = {#}
  &#10233; (Z + A, Z + B) &#8712; ms_weak&quot;</span><span class="">
</span><span class="keyword1">unfolding</span><span class=""> </span><span class="">ms_weak_def</span><span class=""> </span><span class="">ms_strict_def</span><span class="">
</span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">pair_less_def</span><span class=""> </span><span class="">max_strict_def</span><span class=""> </span><span class="">elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span class="">max_ext.cases</span><span class=""> </span><span class="">intro</span><span class="delimiter">:</span><span class=""> </span><span class="">one_step_implies_mult</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">inductive</span><span class=""> </span><span class="">pw_leq</span><span class="">
</span><span class="keyword2">where</span><span class="">
</span><span class="">  </span><span class="">pw_leq_empty</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;pw_leq {#} {#}&quot;</span><span class="">
</span><span class="delimiter">|</span><span class=""> </span><span class="">pw_leq_step</span><span class="delimiter">:</span><span class="">  </span><span class="string">&quot;&#10214;(x,y) &#8712; pair_leq; pw_leq X Y &#10215; &#10233; pw_leq ({#x#} + X) ({#y#} + Y)&quot;</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">pw_leq_lstep</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="string">&quot;(x, y) &#8712; pair_leq &#10233; pw_leq {#x#} {#y#}&quot;</span><span class="">
</span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">drule</span><span class=""> </span><span class="">pw_leq_step</span><span class="delimiter">)</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">pw_leq_empty</span><span class="delimiter">,</span><span class=""> </span><span class="">simp</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">pw_leq_split</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="string">&quot;pw_leq X Y&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;&#8707;A B Z. X = A + Z &#8743; Y = B + Z &#8743; ((set_mset A, set_mset B) &#8712; max_strict &#8744; (B = {#} &#8743; A = {#}))&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">using</span><span class=""> </span><span class="">assms</span><span class="">
</span><span class="keyword1">proof</span><span class=""> </span><span class="">induct</span><span class="">
</span><span class="">  </span><span class="keyword3">case</span><span class=""> </span><span class="">pw_leq_empty</span><span class=""> </span><span class="keyword3">thus</span><span class=""> </span><span class="var">?case</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="keyword1">next</span><span class="">
</span><span class="">  </span><span class="keyword3">case</span><span class=""> </span><span class="delimiter">(</span><span class="">pw_leq_step</span><span class=""> </span><span class="">x</span><span class=""> </span><span class="">y</span><span class=""> </span><span class="">X</span><span class=""> </span><span class="">Y</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">then</span><span class=""> </span><span class="keyword3">obtain</span><span class=""> </span><span class="">A</span><span class=""> </span><span class="">B</span><span class=""> </span><span class="">Z</span><span class=""> </span><span class="keyword2">where</span><span class="">
</span><span class="">    </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;X = A + Z&quot;</span><span class=""> </span><span class="string">&quot;Y = B + Z&quot;</span><span class="">
</span><span class="">      </span><span class="keyword2">and</span><span class=""> </span><span class="">1</span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;(set_mset A, set_mset B) &#8712; max_strict &#8744; (B = {#} &#8743; A = {#})&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">  </span><span class="keyword1">from</span><span class=""> </span><span class="">pw_leq_step</span><span class=""> </span><span class="keyword1">consider</span><span class=""> </span><span class="string">&quot;x = y&quot;</span><span class=""> </span><span class="delimiter">|</span><span class=""> </span><span class="string">&quot;(x, y) &#8712; pair_less&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">pair_leq_def</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">  </span><span class="keyword3">thus</span><span class=""> </span><span class="var">?case</span><span class="">
</span><span class="">  </span><span class="keyword1">proof</span><span class=""> </span><span class="">cases</span><span class="">
</span><span class="">    </span><span class="keyword3">case</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="">1</span><span class="">
</span><span class="">    </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;{#x#} + X = A + ({#y#}+Z) &#8743; {#y#} + Y = B + ({#y#}+Z) &#8743;
      ((set_mset A, set_mset B) &#8712; max_strict &#8744; (B = {#} &#8743; A = {#}))&quot;</span><span class="">
</span><span class="">      </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class="delimiter">:</span><span class=""> </span><span class="">ac_simps</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword3">thus</span><span class=""> </span><span class="var">?thesis</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">blast</span><span class="">
</span><span class="">  </span><span class="keyword1">next</span><span class="">
</span><span class="">    </span><span class="keyword3">case</span><span class=""> </span><span class="">2</span><span class="">
</span><span class="">    </span><span class="keyword1">let</span><span class=""> </span><span class="var">?A&#39;</span><span class=""> </span><span class="delimiter">=</span><span class=""> </span><span class="string">&quot;{#x#} + A&quot;</span><span class=""> </span><span class="keyword2">and</span><span class=""> </span><span class="var">?B&#39;</span><span class=""> </span><span class="delimiter">=</span><span class=""> </span><span class="string">&quot;{#y#} + B&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;{#x#} + X = ?A&#39; + Z&quot;</span><span class="">
</span><span class="">      </span><span class="string">&quot;{#y#} + Y = ?B&#39; + Z&quot;</span><span class="">
</span><span class="">      </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">ac_simps</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1">moreover</span><span class=""> </span><span class="keyword1">have</span><span class="">
</span><span class="">      </span><span class="string">&quot;(set_mset ?A&#39;, set_mset ?B&#39;) &#8712; max_strict&quot;</span><span class="">
</span><span class="">      </span><span class="keyword1">using</span><span class=""> </span><span class="">1</span><span class=""> </span><span class="">2</span><span class=""> </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">max_strict_def</span><span class="">
</span><span class="">      </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span class=""> </span><span class="">max_ext.cases</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1">ultimately</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="var">?thesis</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">blast</span><span class="">
</span><span class="">  </span><span class="keyword1">qed</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="">pwleq</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;pw_leq Z Z&#39;&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="">ms_strictI</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;(set_mset A, set_mset B) &#8712; max_strict &#10233; (Z + A, Z&#39; + B) &#8712; ms_strict&quot;</span><span class="">
</span><span class="">    </span><span class="keyword2">and</span><span class=""> </span><span class="">ms_weakI1</span><span class="delimiter">:</span><span class="">  </span><span class="string">&quot;(set_mset A, set_mset B) &#8712; max_strict &#10233; (Z + A, Z&#39; + B) &#8712; ms_weak&quot;</span><span class="">
</span><span class="">    </span><span class="keyword2">and</span><span class=""> </span><span class="">ms_weakI2</span><span class="delimiter">:</span><span class="">  </span><span class="string">&quot;(Z + {#}, Z&#39; + {#}) &#8712; ms_weak&quot;</span><span class="">
</span><span class="keyword1">proof</span><span class=""> </span><span class="">-</span><span class="">
</span><span class="">  </span><span class="keyword1">from</span><span class=""> </span><span class="">pw_leq_split</span><span class="delimiter">[</span><span class="">OF</span><span class=""> </span><span class="">pwleq</span><span class="delimiter">]</span><span class="">
</span><span class="">  </span><span class="keyword3">obtain</span><span class=""> </span><span class="">A&#39;</span><span class=""> </span><span class="">B&#39;</span><span class=""> </span><span class="">Z&#39;&#39;</span><span class="">
</span><span class="">    </span><span class="keyword2">where</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;Z = A&#39; + Z&#39;&#39;&quot;</span><span class=""> </span><span class="string">&quot;Z&#39; = B&#39; + Z&#39;&#39;&quot;</span><span class="">
</span><span class="">    </span><span class="keyword2">and</span><span class=""> </span><span class="">mx_or_empty</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;(set_mset A&#39;, set_mset B&#39;) &#8712; max_strict &#8744; (A&#39; = {#} &#8743; B&#39; = {#})&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">by</span><span class=""> </span><span class="">blast</span><span class="">
</span><span class="">  </span><span class="keyword1">{</span><span class="">
</span><span class="">    </span><span class="keyword3">assume</span><span class=""> </span><span class="">max</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;(set_mset A, set_mset B) &#8712; max_strict&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">from</span><span class=""> </span><span class="">mx_or_empty</span><span class="">
</span><span class="">    </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;(Z&#39;&#39; + (A + A&#39;), Z&#39;&#39; + (B + B&#39;)) &#8712; ms_strict&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">proof</span><span class="">
</span><span class="">      </span><span class="keyword3">assume</span><span class=""> </span><span class="">max&#39;</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;(set_mset A&#39;, set_mset B&#39;) &#8712; max_strict&quot;</span><span class="">
</span><span class="">      </span><span class="keyword1">with</span><span class=""> </span><span class="">max</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;(set_mset (A + A&#39;), set_mset (B + B&#39;)) &#8712; max_strict&quot;</span><span class="">
</span><span class="">        </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class="delimiter">:</span><span class=""> </span><span class="">max_strict_def</span><span class=""> </span><span class="">intro</span><span class="delimiter">:</span><span class=""> </span><span class="">max_ext_additive</span><span class="delimiter">)</span><span class="">
</span><span class="">      </span><span class="keyword3">thus</span><span class=""> </span><span class="var">?thesis</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">smsI</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1">next</span><span class="">
</span><span class="">      </span><span class="keyword3">assume</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;A&#39; = {#} &#8743; B&#39; = {#}&quot;</span><span class="">
</span><span class="">      </span><span class="keyword3">show</span><span class=""> </span><span class="var">?thesis</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">smsI</span><span class="delimiter">)</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">intro</span><span class="delimiter">:</span><span class=""> </span><span class="">max</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1">qed</span><span class="">
</span><span class="">    </span><span class="keyword3">thus</span><span class=""> </span><span class="string">&quot;(Z + A, Z&#39; + B) &#8712; ms_strict&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">ac_simps</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword3">thus</span><span class=""> </span><span class="string">&quot;(Z + A, Z&#39; + B) &#8712; ms_weak&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">ms_weak_def</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">}</span><span class="">
</span><span class="">  </span><span class="keyword1">from</span><span class=""> </span><span class="">mx_or_empty</span><span class="">
</span><span class="">  </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;(Z&#39;&#39; + A&#39;, Z&#39;&#39; + B&#39;) &#8712; ms_weak&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">wmsI</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword3">thus</span><span class=""> </span><span class="string">&quot;(Z + {#}, Z&#39; + {#}) &#8712; ms_weak&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class="">ac_simps</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">empty_neutral</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;{#} + x = x&quot;</span><span class=""> </span><span class="string">&quot;x + {#} = x&quot;</span><span class="">
</span><span class="keyword2">and</span><span class=""> </span><span class="">nonempty_plus</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;{# x #} + rs &#8800; {#}&quot;</span><span class="">
</span><span class="keyword2">and</span><span class=""> </span><span class="">nonempty_single</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;{# x #} &#8800; {#}&quot;</span><span class="">
</span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">
</span><span class="keyword1">setup</span><span class=""> </span><span class="cartouche">&#8249;
  let
    fun msetT T = Type (@{type_name multiset}, [T]);

    fun mk_mset T [] = Const (@{const_abbrev Mempty}, msetT T)
      | mk_mset T [x] = Const (@{const_name single}, T --&gt; msetT T) $ x
      | mk_mset T (x :: xs) =
            Const (@{const_name plus}, msetT T --&gt; msetT T --&gt; msetT T) $
                  mk_mset T [x] $ mk_mset T xs

    fun mset_member_tac ctxt m i =
      if m &lt;= 0 then
        resolve_tac ctxt @{thms multi_member_this} i ORELSE
        resolve_tac ctxt @{thms multi_member_last} i
      else
        resolve_tac ctxt @{thms multi_member_skip} i THEN mset_member_tac ctxt (m - 1) i

    fun mset_nonempty_tac ctxt =
      resolve_tac ctxt @{thms nonempty_plus} ORELSE&#39;
      resolve_tac ctxt @{thms nonempty_single}

    fun regroup_munion_conv ctxt =
      Function_Lib.regroup_conv ctxt @{const_abbrev Mempty} @{const_name plus}
        (map (fn t =&gt; t RS eq_reflection) (@{thms ac_simps} @ @{thms empty_neutral}))

    fun unfold_pwleq_tac ctxt i =
      (resolve_tac ctxt @{thms pw_leq_step} i THEN (fn st =&gt; unfold_pwleq_tac ctxt (i + 1) st))
        ORELSE (resolve_tac ctxt @{thms pw_leq_lstep} i)
        ORELSE (resolve_tac ctxt @{thms pw_leq_empty} i)

    val set_mset_simps = [@{thm set_mset_empty}, @{thm set_mset_single}, @{thm set_mset_union},
                        @{thm Un_insert_left}, @{thm Un_empty_left}]
  in
    ScnpReconstruct.multiset_setup (ScnpReconstruct.Multiset
    {
      msetT=msetT, mk_mset=mk_mset, mset_regroup_conv=regroup_munion_conv,
      mset_member_tac=mset_member_tac, mset_nonempty_tac=mset_nonempty_tac,
      mset_pwleq_tac=unfold_pwleq_tac, set_of_simps=set_mset_simps,
      smsI&#39;= @{thm ms_strictI}, wmsI2&#39;&#39;= @{thm ms_weakI2}, wmsI1= @{thm ms_weakI1},
      reduction_pair = @{thm ms_reduction_pair}
    })
  end
&#8250;</span><span class="">
</span><span class="">
</span><span class="">
</span><span class="keyword1">subsection</span><span class=""> </span><span class="cartouche">&#8249;Legacy theorem bindings&#8250;</span><span class="">
</span><span class="">
</span><span class="keyword1">lemmas</span><span class=""> </span><span class="">multi_count_eq</span><span class=""> </span><span class="delimiter">=</span><span class=""> </span><span class="">multiset_eq_iff</span><span class=""> </span><span class="delimiter">[</span><span class="">symmetric</span><span class="delimiter">]</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">union_commute</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;M + N = N + (M::&#39;a multiset)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">fact</span><span class=""> </span><span class="">add.commute</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">union_assoc</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;(M + N) + K = M + (N + (K::&#39;a multiset))&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">fact</span><span class=""> </span><span class="">add.assoc</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">union_lcomm</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;M + (N + K) = N + (M + (K::&#39;a multiset))&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">fact</span><span class=""> </span><span class="">add.left_commute</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemmas</span><span class=""> </span><span class="">union_ac</span><span class=""> </span><span class="delimiter">=</span><span class=""> </span><span class="">union_assoc</span><span class=""> </span><span class="">union_commute</span><span class=""> </span><span class="">union_lcomm</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">union_right_cancel</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;M + K = N + K &#10231; M = (N::&#39;a multiset)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">fact</span><span class=""> </span><span class="">add_right_cancel</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">union_left_cancel</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;K + M = K + N &#10231; M = (N::&#39;a multiset)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">fact</span><span class=""> </span><span class="">add_left_cancel</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">multi_union_self_other_eq</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;(A::&#39;a multiset) + X = A + Y &#10233; X = Y&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">fact</span><span class=""> </span><span class="">add_left_imp_eq</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">mset_less_trans</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;(M::&#39;a multiset) &lt;# K &#10233; K &lt;# N &#10233; M &lt;# N&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">fact</span><span class=""> </span><span class="">subset_mset.less_trans</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">multiset_inter_commute</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;A #&#8745; B = B #&#8745; A&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">fact</span><span class=""> </span><span class="">subset_mset.inf.commute</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">multiset_inter_assoc</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;A #&#8745; (B #&#8745; C) = A #&#8745; B #&#8745; C&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">fact</span><span class=""> </span><span class="">subset_mset.inf.assoc</span><span class=""> </span><span class="delimiter">[</span><span class="">symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">multiset_inter_left_commute</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;A #&#8745; (B #&#8745; C) = B #&#8745; (A #&#8745; C)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">fact</span><span class=""> </span><span class="">subset_mset.inf.left_commute</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemmas</span><span class=""> </span><span class="">multiset_inter_ac</span><span class=""> </span><span class="delimiter">=</span><span class="">
</span><span class="">  </span><span class="">multiset_inter_commute</span><span class="">
</span><span class="">  </span><span class="">multiset_inter_assoc</span><span class="">
</span><span class="">  </span><span class="">multiset_inter_left_commute</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">mult_less_not_refl</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;&#172; M #&#8834;# (M::&#39;a::order multiset)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">fact</span><span class=""> </span><span class="">multiset_order.less_irrefl</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">mult_less_trans</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;K #&#8834;# M &#10233; M #&#8834;# N &#10233; K #&#8834;# (N::&#39;a::order multiset)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">fact</span><span class=""> </span><span class="">multiset_order.less_trans</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">mult_less_not_sym</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;M #&#8834;# N &#10233; &#172; N #&#8834;# (M::&#39;a::order multiset)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">fact</span><span class=""> </span><span class="">multiset_order.less_not_sym</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">mult_less_asym</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;M #&#8834;# N &#10233; (&#172; P &#10233; N #&#8834;# (M::&#39;a::order multiset)) &#10233; P&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">fact</span><span class=""> </span><span class="">multiset_order.less_asym</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">declaration</span><span class=""> </span><span class="cartouche">&#8249;
  let
    fun multiset_postproc _ maybe_name all_values (T as Type (_, [elem_T])) (Const _ $ t&#39;) =
          let
            val (maybe_opt, ps) =
              Nitpick_Model.dest_plain_fun t&#39;
              ||&gt; op ~~
              ||&gt; map (apsnd (snd o HOLogic.dest_number))
            fun elems_for t =
              (case AList.lookup (op =) ps t of
                SOME n =&gt; replicate n t
              | NONE =&gt; [Const (maybe_name, elem_T --&gt; elem_T) $ t])
          in
            (case maps elems_for (all_values elem_T) @
                 (if maybe_opt then [Const (Nitpick_Model.unrep_mixfix (), elem_T)] else []) of
              [] =&gt; Const (@{const_name zero_class.zero}, T)
            | ts =&gt;
                foldl1 (fn (t1, t2) =&gt;
                    Const (@{const_name plus_class.plus}, T --&gt; T --&gt; T) $ t1 $ t2)
                  (map (curry (op $) (Const (@{const_name single}, elem_T --&gt; T))) ts))
          end
      | multiset_postproc _ _ _ _ t = t
  in Nitpick_Model.register_term_postprocessor @{typ &quot;&#39;a multiset&quot;} multiset_postproc end
&#8250;</span><span class="">
</span><span class="">
</span><span class="">
</span><span class="keyword1">subsection</span><span class=""> </span><span class="cartouche">&#8249;Naive implementation using lists&#8250;</span><span class="">
</span><span class="">
</span><span class="keyword1">code_datatype</span><span class=""> </span><span class="">mset</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="delimiter">[</span><span class="">code</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;{#} = mset []&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="delimiter">[</span><span class="">code</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;{#x#} = mset [x]&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">union_code</span><span class=""> </span><span class="delimiter">[</span><span class="">code</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;mset xs + mset ys = mset (xs @ ys)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="delimiter">[</span><span class="">code</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;image_mset f (mset xs) = mset (map f xs)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">mset_map</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="delimiter">[</span><span class="">code</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;filter_mset f (mset xs) = mset (filter f xs)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">mset_filter</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="delimiter">[</span><span class="">code</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;mset xs - mset ys = mset (fold remove1 ys xs)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">sym</span><span class="delimiter">,</span><span class=""> </span><span class="">induct</span><span class=""> </span><span class="">ys</span><span class=""> </span><span class="">arbitrary</span><span class="delimiter">:</span><span class=""> </span><span class="">xs</span><span class="delimiter">)</span><span class=""> </span><span class="delimiter">(</span><span class="">simp_all</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">diff_add</span><span class=""> </span><span class="">diff_right_commute</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="delimiter">[</span><span class="">code</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="string">&quot;mset xs #&#8745; mset ys =
    mset (snd (fold (&#955;x (ys, zs).
      if x &#8712; set ys then (remove1 x ys, x # zs) else (ys, zs)) xs (ys, [])))&quot;</span><span class="">
</span><span class="keyword1">proof</span><span class=""> </span><span class="">-</span><span class="">
</span><span class="">  </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;&#8896;zs. mset (snd (fold (&#955;x (ys, zs).
    if x &#8712; set ys then (remove1 x ys, x # zs) else (ys, zs)) xs (ys, zs))) =
      (mset xs #&#8745; mset ys) + mset zs&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">xs</span><span class=""> </span><span class="">arbitrary</span><span class="delimiter">:</span><span class=""> </span><span class="">ys</span><span class="delimiter">)</span><span class="">
</span><span class="">      </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">mem_set_multiset_eq</span><span class=""> </span><span class="">inter_add_right1</span><span class=""> </span><span class="">inter_add_right2</span><span class=""> </span><span class="">ac_simps</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">then</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="var">?thesis</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="delimiter">[</span><span class="">code</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="string">&quot;mset xs #&#8746; mset ys =
    mset (case_prod append (fold (&#955;x (ys, zs). (remove1 x ys, x # zs)) xs (ys, [])))&quot;</span><span class="">
</span><span class="keyword1">proof</span><span class=""> </span><span class="">-</span><span class="">
</span><span class="">  </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;&#8896;zs. mset (case_prod append (fold (&#955;x (ys, zs). (remove1 x ys, x # zs)) xs (ys, zs))) =
      (mset xs #&#8746; mset ys) + mset zs&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">xs</span><span class=""> </span><span class="">arbitrary</span><span class="delimiter">:</span><span class=""> </span><span class="">ys</span><span class="delimiter">)</span><span class=""> </span><span class="delimiter">(</span><span class="">simp_all</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">multiset_eq_iff</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">then</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="var">?thesis</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="keyword1">declare</span><span class=""> </span><span class="">in_multiset_in_set</span><span class=""> </span><span class="delimiter">[</span><span class="">code_unfold</span><span class="delimiter">]</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="delimiter">[</span><span class="">code</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;count (mset xs) x = fold (&#955;y. if x = y then Suc else id) xs 0&quot;</span><span class="">
</span><span class="keyword1">proof</span><span class=""> </span><span class="">-</span><span class="">
</span><span class="">  </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;&#8896;n. fold (&#955;y. if x = y then Suc else id) xs n = count (mset xs) x + n&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">xs</span><span class="delimiter">)</span><span class=""> </span><span class="">simp_all</span><span class="">
</span><span class="">  </span><span class="keyword1">then</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="var">?thesis</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="keyword1">declare</span><span class=""> </span><span class="">set_mset_mset</span><span class=""> </span><span class="delimiter">[</span><span class="">code</span><span class="delimiter">]</span><span class="">
</span><span class="">
</span><span class="keyword1">declare</span><span class=""> </span><span class="">sorted_list_of_multiset_mset</span><span class=""> </span><span class="delimiter">[</span><span class="">code</span><span class="delimiter">]</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="delimiter">[</span><span class="">code</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="delimiter">&#8213;</span><span class=""> </span><span class="cartouche">&#8249;not very efficient, but representation-ignorant!&#8250;</span><span class="">
</span><span class="">  </span><span class="string">&quot;mset_set A = mset (sorted_list_of_set A)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">cases</span><span class=""> </span><span class="string">&quot;finite A&quot;</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="">simp_all</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">A</span><span class=""> </span><span class="">rule</span><span class="delimiter">:</span><span class=""> </span><span class="">finite_induct</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">simp_all</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">add.commute</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">done</span></span><span class="">
</span><span class="">
</span><span class="keyword1">declare</span><span class=""> </span><span class="">size_mset</span><span class=""> </span><span class="delimiter">[</span><span class="">code</span><span class="delimiter">]</span><span class="">
</span><span class="">
</span><span class="keyword1">fun</span><span class=""> </span><span class="">ms_lesseq_impl</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;&#39;a list &#8658; &#39;a list &#8658; bool option&quot;</span><span class=""> </span><span class="keyword2">where</span><span class="">
</span><span class="">  </span><span class="string">&quot;ms_lesseq_impl [] ys = Some (ys &#8800; [])&quot;</span><span class="">
</span><span class="delimiter">|</span><span class=""> </span><span class="string">&quot;ms_lesseq_impl (Cons x xs) ys = (case List.extract (op = x) ys of
     None &#8658; None
   | Some (ys1,_,ys2) &#8658; ms_lesseq_impl xs (ys1 @ ys2))&quot;</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">ms_lesseq_impl</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;(ms_lesseq_impl xs ys = None &#10231; &#172; mset xs &#8804;# mset ys) &#8743;
  (ms_lesseq_impl xs ys = Some True &#10231; mset xs &lt;# mset ys) &#8743;
  (ms_lesseq_impl xs ys = Some False &#10230; mset xs = mset ys)&quot;</span><span class="">
</span><span class="keyword1">proof</span><span class=""> </span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">xs</span><span class=""> </span><span class="">arbitrary</span><span class="delimiter">:</span><span class=""> </span><span class="">ys</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword3">case</span><span class=""> </span><span class="delimiter">(</span><span class="">Nil</span><span class=""> </span><span class="">ys</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword3">show</span><span class=""> </span><span class="var">?case</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class="delimiter">:</span><span class=""> </span><span class="">mset_less_empty_nonempty</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1">next</span><span class="">
</span><span class="">  </span><span class="keyword3">case</span><span class=""> </span><span class="delimiter">(</span><span class="">Cons</span><span class=""> </span><span class="">x</span><span class=""> </span><span class="">xs</span><span class=""> </span><span class="">ys</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword3">show</span><span class=""> </span><span class="var">?case</span><span class="">
</span><span class="">  </span><span class="keyword1">proof</span><span class=""> </span><span class="delimiter">(</span><span class="">cases</span><span class=""> </span><span class="string">&quot;List.extract (op = x) ys&quot;</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword3">case</span><span class=""> </span><span class="">None</span><span class="">
</span><span class="">    </span><span class="keyword1">hence</span><span class=""> </span><span class="">x</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;x &#8713; set ys&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">extract_None_iff</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1">{</span><span class="">
</span><span class="">      </span><span class="keyword3">assume</span><span class=""> </span><span class="string">&quot;mset (x # xs) &#8804;# mset ys&quot;</span><span class="">
</span><span class="">      </span><span class="keyword1">from</span><span class=""> </span><span class="">set_mset_mono</span><span class="delimiter">[</span><span class="">OF</span><span class=""> </span><span class="">this</span><span class="delimiter">]</span><span class=""> </span><span class="">x</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="">False</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">    </span><span class="keyword1">}</span><span class=""> </span><span class="keyword1">note</span><span class=""> </span><span class="">nle</span><span class=""> </span><span class="delimiter">=</span><span class=""> </span><span class="">this</span><span class="">
</span><span class="">    </span><span class="keyword1">moreover</span><span class="">
</span><span class="">    </span><span class="keyword1">{</span><span class="">
</span><span class="">      </span><span class="keyword3">assume</span><span class=""> </span><span class="string">&quot;mset (x # xs) &lt;# mset ys&quot;</span><span class="">
</span><span class="">      </span><span class="keyword1">hence</span><span class=""> </span><span class="string">&quot;mset (x # xs) &#8804;# mset ys&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">      </span><span class="keyword1">from</span><span class=""> </span><span class="">nle</span><span class="delimiter">[</span><span class="">OF</span><span class=""> </span><span class="">this</span><span class="delimiter">]</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="">False</span><span class=""> </span><span class="keyword1">.</span><span class="">
</span><span class="">    </span><span class="keyword1">}</span><span class="">
</span><span class="">    </span><span class="keyword1">ultimately</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="var">?thesis</span><span class=""> </span><span class="keyword1">using</span><span class=""> </span><span class="">None</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">  </span><span class="keyword1">next</span><span class="">
</span><span class="">    </span><span class="keyword3">case</span><span class=""> </span><span class="delimiter">(</span><span class="">Some</span><span class=""> </span><span class="">res</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword3">obtain</span><span class=""> </span><span class="">ys1</span><span class=""> </span><span class="">y</span><span class=""> </span><span class="">ys2</span><span class=""> </span><span class="keyword2">where</span><span class=""> </span><span class="">res</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;res = (ys1,y,ys2)&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">cases</span><span class=""> </span><span class="">res</span><span class="delimiter">,</span><span class=""> </span><span class="">auto</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1">note</span><span class=""> </span><span class="">Some</span><span class=""> </span><span class="delimiter">=</span><span class=""> </span><span class="">Some</span><span class="delimiter">[</span><span class="">unfolded</span><span class=""> </span><span class="">res</span><span class="delimiter">]</span><span class="">
</span><span class="">    </span><span class="keyword1">from</span><span class=""> </span><span class="">extract_SomeE</span><span class="delimiter">[</span><span class="">OF</span><span class=""> </span><span class="">Some</span><span class="delimiter">]</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;ys = ys1 @ x # ys2&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">    </span><span class="keyword1">hence</span><span class=""> </span><span class="">id</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;mset ys = mset (ys1 @ ys2) + {#x#}&quot;</span><span class="">
</span><span class="">      </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class="delimiter">:</span><span class=""> </span><span class="">ac_simps</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword3">show</span><span class=""> </span><span class="var">?thesis</span><span class=""> </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">ms_lesseq_impl.simps</span><span class="">
</span><span class="">      </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">Some</span><span class=""> </span><span class="">option.simps</span><span class=""> </span><span class="">split</span><span class="">
</span><span class="">      </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">id</span><span class="">
</span><span class="">      </span><span class="keyword1">using</span><span class=""> </span><span class="">Cons</span><span class="delimiter">[</span><span class="">of</span><span class=""> </span><span class="string">&quot;ys1 @ ys2&quot;</span><span class="delimiter">]</span><span class="">
</span><span class="">      </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">subset_mset_def</span><span class=""> </span><span class="">subseteq_mset_def</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">  </span><span class="keyword1">qed</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="delimiter">[</span><span class="">code</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;mset xs &#8804;# mset ys &#10231; ms_lesseq_impl xs ys &#8800; None&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">using</span><span class=""> </span><span class="">ms_lesseq_impl</span><span class="delimiter">[</span><span class="">of</span><span class=""> </span><span class="">xs</span><span class=""> </span><span class="">ys</span><span class="delimiter">]</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">cases</span><span class=""> </span><span class="string">&quot;ms_lesseq_impl xs ys&quot;</span><span class="delimiter">,</span><span class=""> </span><span class="">auto</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="delimiter">[</span><span class="">code</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;mset xs &lt;# mset ys &#10231; ms_lesseq_impl xs ys = Some True&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">using</span><span class=""> </span><span class="">ms_lesseq_impl</span><span class="delimiter">[</span><span class="">of</span><span class=""> </span><span class="">xs</span><span class=""> </span><span class="">ys</span><span class="delimiter">]</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">cases</span><span class=""> </span><span class="string">&quot;ms_lesseq_impl xs ys&quot;</span><span class="delimiter">,</span><span class=""> </span><span class="">auto</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">instantiation</span><span class=""> </span><span class="">multiset</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="delimiter">(</span><span class="">equal</span><span class="delimiter">)</span><span class=""> </span><span class="">equal</span><span class="">
</span><span class="keyword2">begin</span><span class="">
</span><span class="">
</span><span class="keyword1">definition</span><span class="">
</span><span class="">  </span><span class="delimiter">[</span><span class="">code</span><span class=""> </span><span class="">del</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;HOL.equal A (B :: &#39;a multiset) &#10231; A = B&quot;</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="delimiter">[</span><span class="">code</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;HOL.equal (mset xs) (mset ys) &#10231; ms_lesseq_impl xs ys = Some False&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">equal_multiset_def</span><span class="">
</span><span class="">  </span><span class="keyword1">using</span><span class=""> </span><span class="">ms_lesseq_impl</span><span class="delimiter">[</span><span class="">of</span><span class=""> </span><span class="">xs</span><span class=""> </span><span class="">ys</span><span class="delimiter">]</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">cases</span><span class=""> </span><span class="string">&quot;ms_lesseq_impl xs ys&quot;</span><span class="delimiter">,</span><span class=""> </span><span class="">auto</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">instance</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="">standard</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">equal_multiset_def</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword2">end</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="delimiter">[</span><span class="">code</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;msetsum (mset xs) = listsum xs&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">xs</span><span class="delimiter">)</span><span class=""> </span><span class="delimiter">(</span><span class="">simp_all</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">add.commute</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="delimiter">[</span><span class="">code</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;msetprod (mset xs) = fold times xs 1&quot;</span><span class="">
</span><span class="keyword1">proof</span><span class=""> </span><span class="">-</span><span class="">
</span><span class="">  </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;&#8896;x. fold times xs x = msetprod (mset xs) * x&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">xs</span><span class="delimiter">)</span><span class=""> </span><span class="delimiter">(</span><span class="">simp_all</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">mult.assoc</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">then</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="var">?thesis</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="keyword1">text</span><span class=""> </span><span class="cartouche">&#8249;
  Exercise for the casual reader: add implementations for @{const le_multiset}
  and @{const less_multiset} (multiset order).
&#8250;</span><span class="">
</span><span class="">
</span><span class="keyword1">text</span><span class=""> </span><span class="cartouche">&#8249;Quickcheck generators&#8250;</span><span class="">
</span><span class="">
</span><span class="keyword1">definition</span><span class=""> </span><span class="delimiter">(</span><span class="keyword2">in</span><span class=""> </span><span class="">term_syntax</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="">msetify</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;&#39;a::typerep list &#215; (unit &#8658; Code_Evaluation.term)
    &#8658; &#39;a multiset &#215; (unit &#8658; Code_Evaluation.term)&quot;</span><span class=""> </span><span class="keyword2">where</span><span class="">
</span><span class="">  </span><span class="delimiter">[</span><span class="">code_unfold</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;msetify xs = Code_Evaluation.valtermify mset {&#8901;} xs&quot;</span><span class="">
</span><span class="">
</span><span class="keyword1">notation</span><span class=""> </span><span class="">fcomp</span><span class=""> </span><span class="delimiter">(</span><span class="keyword2">infixl</span><span class=""> </span><span class="string">&quot;&#8728;&gt;&quot;</span><span class=""> </span><span class="">60</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1">notation</span><span class=""> </span><span class="">scomp</span><span class=""> </span><span class="delimiter">(</span><span class="keyword2">infixl</span><span class=""> </span><span class="string">&quot;&#8728;&#8594;&quot;</span><span class=""> </span><span class="">60</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">instantiation</span><span class=""> </span><span class="">multiset</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="delimiter">(</span><span class="">random</span><span class="delimiter">)</span><span class=""> </span><span class="">random</span><span class="">
</span><span class="keyword2">begin</span><span class="">
</span><span class="">
</span><span class="keyword1">definition</span><span class="">
</span><span class="">  </span><span class="string">&quot;Quickcheck_Random.random i = Quickcheck_Random.random i &#8728;&#8594; (&#955;xs. Pair (msetify xs))&quot;</span><span class="">
</span><span class="">
</span><span class="keyword1">instance</span><span class=""> </span><span class="keyword1">..</span><span class="">
</span><span class="">
</span><span class="keyword2">end</span><span class="">
</span><span class="">
</span><span class="keyword1">no_notation</span><span class=""> </span><span class="">fcomp</span><span class=""> </span><span class="delimiter">(</span><span class="keyword2">infixl</span><span class=""> </span><span class="string">&quot;&#8728;&gt;&quot;</span><span class=""> </span><span class="">60</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1">no_notation</span><span class=""> </span><span class="">scomp</span><span class=""> </span><span class="delimiter">(</span><span class="keyword2">infixl</span><span class=""> </span><span class="string">&quot;&#8728;&#8594;&quot;</span><span class=""> </span><span class="">60</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">instantiation</span><span class=""> </span><span class="">multiset</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="delimiter">(</span><span class="">full_exhaustive</span><span class="delimiter">)</span><span class=""> </span><span class="">full_exhaustive</span><span class="">
</span><span class="keyword2">begin</span><span class="">
</span><span class="">
</span><span class="keyword1">definition</span><span class=""> </span><span class="">full_exhaustive_multiset</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;(&#39;a multiset &#215; (unit &#8658; term) &#8658; (bool &#215; term list) option) &#8658; natural &#8658; (bool &#215; term list) option&quot;</span><span class="">
</span><span class="keyword2">where</span><span class="">
</span><span class="">  </span><span class="string">&quot;full_exhaustive_multiset f i = Quickcheck_Exhaustive.full_exhaustive (&#955;xs. f (msetify xs)) i&quot;</span><span class="">
</span><span class="">
</span><span class="keyword1">instance</span><span class=""> </span><span class="keyword1">..</span><span class="">
</span><span class="">
</span><span class="keyword2">end</span><span class="">
</span><span class="">
</span><span class="keyword1">hide_const</span><span class=""> </span><span class="delimiter">(</span><span class="keyword2">open</span><span class="delimiter">)</span><span class=""> </span><span class="">msetify</span><span class="">
</span><span class="">
</span><span class="">
</span><span class="keyword1">subsection</span><span class=""> </span><span class="cartouche">&#8249;BNF setup&#8250;</span><span class="">
</span><span class="">
</span><span class="keyword1">definition</span><span class=""> </span><span class="">rel_mset</span><span class=""> </span><span class="keyword2">where</span><span class="">
</span><span class="">  </span><span class="string">&quot;rel_mset R X Y &#10231; (&#8707;xs ys. mset xs = X &#8743; mset ys = Y &#8743; list_all2 R xs ys)&quot;</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">mset_zip_take_Cons_drop_twice</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="string">&quot;length xs = length ys&quot;</span><span class=""> </span><span class="string">&quot;j &#8804; length xs&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;mset (zip (take j xs @ x # drop j xs) (take j ys @ y # drop j ys)) =
    mset (zip xs ys) + {#(x, y)#}&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">using</span><span class=""> </span><span class="">assms</span><span class="">
</span><span class="keyword1">proof</span><span class=""> </span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">xs</span><span class=""> </span><span class="">ys</span><span class=""> </span><span class="">arbitrary</span><span class="delimiter">:</span><span class=""> </span><span class="">x</span><span class=""> </span><span class="">y</span><span class=""> </span><span class="">j</span><span class=""> </span><span class="">rule</span><span class="delimiter">:</span><span class=""> </span><span class="">list_induct2</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword3">case</span><span class=""> </span><span class="">Nil</span><span class="">
</span><span class="">  </span><span class="keyword3">thus</span><span class=""> </span><span class="var">?case</span><span class="">
</span><span class="">    </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="keyword1">next</span><span class="">
</span><span class="">  </span><span class="keyword3">case</span><span class=""> </span><span class="delimiter">(</span><span class="">Cons</span><span class=""> </span><span class="">x</span><span class=""> </span><span class="">xs</span><span class=""> </span><span class="">y</span><span class=""> </span><span class="">ys</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword3">thus</span><span class=""> </span><span class="var">?case</span><span class="">
</span><span class="">  </span><span class="keyword1">proof</span><span class=""> </span><span class="delimiter">(</span><span class="">cases</span><span class=""> </span><span class="string">&quot;j = 0&quot;</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword3">case</span><span class=""> </span><span class="">True</span><span class="">
</span><span class="">    </span><span class="keyword3">thus</span><span class=""> </span><span class="var">?thesis</span><span class="">
</span><span class="">      </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">  </span><span class="keyword1">next</span><span class="">
</span><span class="">    </span><span class="keyword3">case</span><span class=""> </span><span class="">False</span><span class="">
</span><span class="">    </span><span class="keyword1">then</span><span class=""> </span><span class="keyword3">obtain</span><span class=""> </span><span class="">k</span><span class=""> </span><span class="keyword2">where</span><span class=""> </span><span class="">k</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;j = Suc k&quot;</span><span class="">
</span><span class="">      </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">cases</span><span class=""> </span><span class="">j</span><span class="delimiter">)</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">    </span><span class="keyword1">hence</span><span class=""> </span><span class="string">&quot;k &#8804; length xs&quot;</span><span class="">
</span><span class="">      </span><span class="keyword1">using</span><span class=""> </span><span class="">Cons.prems</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">    </span><span class="keyword1">hence</span><span class=""> </span><span class="string">&quot;mset (zip (take k xs @ x # drop k xs) (take k ys @ y # drop k ys)) =
      mset (zip xs ys) + {#(x, y)#}&quot;</span><span class="">
</span><span class="">      </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">Cons.hyps</span><span class="delimiter">(</span><span class="">2</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword3">thus</span><span class=""> </span><span class="var">?thesis</span><span class="">
</span><span class="">      </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">k</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class="delimiter">:</span><span class=""> </span><span class="">add.commute</span><span class=""> </span><span class="">union_lcomm</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">qed</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">ex_mset_zip_left</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="string">&quot;length xs = length ys&quot;</span><span class=""> </span><span class="string">&quot;mset xs&#39; = mset xs&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;&#8707;ys&#39;. length ys&#39; = length xs&#39; &#8743; mset (zip xs&#39; ys&#39;) = mset (zip xs ys)&quot;</span><span class="">
</span><span class="keyword1">using</span><span class=""> </span><span class="">assms</span><span class="">
</span><span class="keyword1">proof</span><span class=""> </span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">xs</span><span class=""> </span><span class="">ys</span><span class=""> </span><span class="">arbitrary</span><span class="delimiter">:</span><span class=""> </span><span class="">xs&#39;</span><span class=""> </span><span class="">rule</span><span class="delimiter">:</span><span class=""> </span><span class="">list_induct2</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword3">case</span><span class=""> </span><span class="">Nil</span><span class="">
</span><span class="">  </span><span class="keyword3">thus</span><span class=""> </span><span class="var">?case</span><span class="">
</span><span class="">    </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="keyword1">next</span><span class="">
</span><span class="">  </span><span class="keyword3">case</span><span class=""> </span><span class="delimiter">(</span><span class="">Cons</span><span class=""> </span><span class="">x</span><span class=""> </span><span class="">xs</span><span class=""> </span><span class="">y</span><span class=""> </span><span class="">ys</span><span class=""> </span><span class="">xs&#39;</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword3">obtain</span><span class=""> </span><span class="">j</span><span class=""> </span><span class="keyword2">where</span><span class=""> </span><span class="">j_len</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;j &lt; length xs&#39;&quot;</span><span class=""> </span><span class="keyword2">and</span><span class=""> </span><span class="">nth_j</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;xs&#39; ! j = x&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">metis</span><span class=""> </span><span class="">Cons.prems</span><span class=""> </span><span class="">in_set_conv_nth</span><span class=""> </span><span class="">list.set_intros</span><span class="delimiter">(</span><span class="">1</span><span class="delimiter">)</span><span class=""> </span><span class="">mset_eq_setD</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="">  </span><span class="keyword3">def</span><span class=""> </span><span class="">xsa</span><span class=""> </span><span class="delimiter">&#8801;</span><span class=""> </span><span class="string">&quot;take j xs&#39; @ drop (Suc j) xs&#39;&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;mset xs&#39; = {#x#} + mset xsa&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">xsa_def</span><span class=""> </span><span class="keyword1">using</span><span class=""> </span><span class="">j_len</span><span class=""> </span><span class="">nth_j</span><span class="">
</span><span class="">    </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">metis</span><span class=""> </span><span class="delimiter">(</span><span class="">no_types</span><span class="delimiter">)</span><span class=""> </span><span class="">ab_semigroup_add_class.add_ac</span><span class="delimiter">(</span><span class="">1</span><span class="delimiter">)</span><span class=""> </span><span class="">append_take_drop_id</span><span class=""> </span><span class="">Cons_nth_drop_Suc</span><span class="">
</span><span class="">      </span><span class="">mset.simps</span><span class="delimiter">(</span><span class="">2</span><span class="delimiter">)</span><span class=""> </span><span class="">union_code</span><span class=""> </span><span class="">add.commute</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">hence</span><span class=""> </span><span class="">ms_x</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;mset xsa = mset xs&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">metis</span><span class=""> </span><span class="">Cons.prems</span><span class=""> </span><span class="">add.commute</span><span class=""> </span><span class="">add_right_imp_eq</span><span class=""> </span><span class="">mset.simps</span><span class="delimiter">(</span><span class="">2</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">then</span><span class=""> </span><span class="keyword3">obtain</span><span class=""> </span><span class="">ysa</span><span class=""> </span><span class="keyword2">where</span><span class="">
</span><span class="">    </span><span class="">len_a</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;length ysa = length xsa&quot;</span><span class=""> </span><span class="keyword2">and</span><span class=""> </span><span class="">ms_a</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;mset (zip xsa ysa) = mset (zip xs ys)&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">using</span><span class=""> </span><span class="">Cons.hyps</span><span class="delimiter">(</span><span class="">2</span><span class="delimiter">)</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">blast</span><span class="">
</span><span class="">
</span><span class="">  </span><span class="keyword3">def</span><span class=""> </span><span class="">ys&#39;</span><span class=""> </span><span class="delimiter">&#8801;</span><span class=""> </span><span class="string">&quot;take j ysa @ y # drop j ysa&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">have</span><span class=""> </span><span class="">xs&#39;</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;xs&#39; = take j xsa @ x # drop j xsa&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">using</span><span class=""> </span><span class="">ms_x</span><span class=""> </span><span class="">j_len</span><span class=""> </span><span class="">nth_j</span><span class=""> </span><span class="">Cons.prems</span><span class=""> </span><span class="">xsa_def</span><span class="">
</span><span class="">    </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">metis</span><span class=""> </span><span class="">append_eq_append_conv</span><span class=""> </span><span class="">append_take_drop_id</span><span class=""> </span><span class="">diff_Suc_Suc</span><span class=""> </span><span class="">Cons_nth_drop_Suc</span><span class=""> </span><span class="">length_Cons</span><span class="">
</span><span class="">      </span><span class="">length_drop</span><span class=""> </span><span class="">size_mset</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">have</span><span class=""> </span><span class="">j_len&#39;</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;j &#8804; length xsa&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">using</span><span class=""> </span><span class="">j_len</span><span class=""> </span><span class="">xs&#39;</span><span class=""> </span><span class="">xsa_def</span><span class="">
</span><span class="">    </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">metis</span><span class=""> </span><span class="">add_Suc_right</span><span class=""> </span><span class="">append_take_drop_id</span><span class=""> </span><span class="">length_Cons</span><span class=""> </span><span class="">length_append</span><span class=""> </span><span class="">less_eq_Suc_le</span><span class=""> </span><span class="">not_less</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;length ys&#39; = length xs&#39;&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">ys&#39;_def</span><span class=""> </span><span class="keyword1">using</span><span class=""> </span><span class="">Cons.prems</span><span class=""> </span><span class="">len_a</span><span class=""> </span><span class="">ms_x</span><span class="">
</span><span class="">    </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">metis</span><span class=""> </span><span class="">add_Suc_right</span><span class=""> </span><span class="">append_take_drop_id</span><span class=""> </span><span class="">length_Cons</span><span class=""> </span><span class="">length_append</span><span class=""> </span><span class="">mset_eq_length</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">moreover</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;mset (zip xs&#39; ys&#39;) = mset (zip (x # xs) (y # ys))&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">xs&#39;</span><span class=""> </span><span class="">ys&#39;_def</span><span class="">
</span><span class="">    </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">trans</span><span class="delimiter">[</span><span class="">OF</span><span class=""> </span><span class="">mset_zip_take_Cons_drop_twice</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="">
</span><span class="">      </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class="delimiter">:</span><span class=""> </span><span class="">len_a</span><span class=""> </span><span class="">ms_a</span><span class=""> </span><span class="">j_len&#39;</span><span class=""> </span><span class="">add.commute</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">ultimately</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="var">?case</span><span class="">
</span><span class="">    </span><span class="keyword1">by</span><span class=""> </span><span class="">blast</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">list_all2_reorder_left_invariance</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="">rel</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;list_all2 R xs ys&quot;</span><span class=""> </span><span class="keyword2">and</span><span class=""> </span><span class="">ms_x</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;mset xs&#39; = mset xs&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;&#8707;ys&#39;. list_all2 R xs&#39; ys&#39; &#8743; mset ys&#39; = mset ys&quot;</span><span class="">
</span><span class="keyword1">proof</span><span class=""> </span><span class="">-</span><span class="">
</span><span class="">  </span><span class="keyword1">have</span><span class=""> </span><span class="">len</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;length xs = length ys&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">using</span><span class=""> </span><span class="">rel</span><span class=""> </span><span class="">list_all2_conv_all_nth</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">  </span><span class="keyword3">obtain</span><span class=""> </span><span class="">ys&#39;</span><span class=""> </span><span class="keyword2">where</span><span class="">
</span><span class="">    </span><span class="">len&#39;</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;length xs&#39; = length ys&#39;&quot;</span><span class=""> </span><span class="keyword2">and</span><span class=""> </span><span class="">ms_xy</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;mset (zip xs&#39; ys&#39;) = mset (zip xs ys)&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">using</span><span class=""> </span><span class="">len</span><span class=""> </span><span class="">ms_x</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">metis</span><span class=""> </span><span class="">ex_mset_zip_left</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;list_all2 R xs&#39; ys&#39;&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">using</span><span class=""> </span><span class="">assms</span><span class="delimiter">(</span><span class="">1</span><span class="delimiter">)</span><span class=""> </span><span class="">len&#39;</span><span class=""> </span><span class="">ms_xy</span><span class=""> </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">list_all2_iff</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">blast</span><span class=""> </span><span class="">dest</span><span class="delimiter">:</span><span class=""> </span><span class="">mset_eq_setD</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">moreover</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;mset ys&#39; = mset ys&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">using</span><span class=""> </span><span class="">len</span><span class=""> </span><span class="">len&#39;</span><span class=""> </span><span class="">ms_xy</span><span class=""> </span><span class="">map_snd_zip</span><span class=""> </span><span class="">mset_map</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">metis</span><span class="">
</span><span class="">  </span><span class="keyword1">ultimately</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="var">?thesis</span><span class="">
</span><span class="">    </span><span class="keyword1">by</span><span class=""> </span><span class="">blast</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">ex_mset</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;&#8707;xs. mset xs = X&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">X</span><span class="delimiter">)</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class="delimiter">,</span><span class=""> </span><span class="">metis</span><span class=""> </span><span class="">mset.simps</span><span class="delimiter">(</span><span class="">2</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">bnf</span><span class=""> </span><span class="string">&quot;&#39;a multiset&quot;</span><span class="">
</span><span class="">  </span><span class="">map</span><span class="delimiter">:</span><span class=""> </span><span class="">image_mset</span><span class="">
</span><span class="">  </span><span class="">sets</span><span class="delimiter">:</span><span class=""> </span><span class="">set_mset</span><span class="">
</span><span class="">  </span><span class="">bd</span><span class="delimiter">:</span><span class=""> </span><span class="">natLeq</span><span class="">
</span><span class="">  </span><span class="">wits</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;{#}&quot;</span><span class="">
</span><span class="">  </span><span class="">rel</span><span class="delimiter">:</span><span class=""> </span><span class="">rel_mset</span><span class="">
</span><span class="keyword1">proof</span><span class=""> </span><span class="">-</span><span class="">
</span><span class="">  </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;image_mset id = id&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">image_mset.id</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;image_mset (g &#8728; f) = image_mset g &#8728; image_mset f&quot;</span><span class=""> </span><span class="keyword2">for</span><span class=""> </span><span class="">f</span><span class=""> </span><span class="">g</span><span class="">
</span><span class="">    </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">comp_def</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">ext</span><span class="delimiter">)</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">comp_def</span><span class=""> </span><span class="">image_mset.compositionality</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;(&#8896;z. z &#8712; set_mset X &#10233; f z = g z) &#10233; image_mset f X = image_mset g X&quot;</span><span class=""> </span><span class="keyword2">for</span><span class=""> </span><span class="">f</span><span class=""> </span><span class="">g</span><span class=""> </span><span class="">X</span><span class="">
</span><span class="">    </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">X</span><span class="delimiter">)</span><span class=""> </span><span class="delimiter">(</span><span class="">simp_all</span><span class=""> </span><span class="delimiter">(</span><span class="">no_asm</span><span class="delimiter">)</span><span class="delimiter">,</span><span class="">
</span><span class="">      </span><span class="">metis</span><span class=""> </span><span class="">One_nat_def</span><span class=""> </span><span class="">Un_iff</span><span class=""> </span><span class="">count_single</span><span class=""> </span><span class="">mem_set_mset_iff</span><span class=""> </span><span class="">set_mset_union</span><span class=""> </span><span class="">zero_less_Suc</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;set_mset &#8728; image_mset f = op ` f &#8728; set_mset&quot;</span><span class=""> </span><span class="keyword2">for</span><span class=""> </span><span class="">f</span><span class="">
</span><span class="">    </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">  </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;card_order natLeq&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">natLeq_card_order</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;BNF_Cardinal_Arithmetic.cinfinite natLeq&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">natLeq_cinfinite</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;ordLeq3 (card_of (set_mset X)) natLeq&quot;</span><span class=""> </span><span class="keyword2">for</span><span class=""> </span><span class="">X</span><span class="">
</span><span class="">    </span><span class="keyword1">by</span><span class=""> </span><span class="">transfer</span><span class="">
</span><span class="">      </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span class=""> </span><span class="">ordLess_imp_ordLeq</span><span class=""> </span><span class="">simp</span><span class="delimiter">:</span><span class=""> </span><span class="">finite_iff_ordLess_natLeq</span><span class="delimiter">[</span><span class="">symmetric</span><span class="delimiter">]</span><span class=""> </span><span class="">multiset_def</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;rel_mset R OO rel_mset S &#8804; rel_mset (R OO S)&quot;</span><span class=""> </span><span class="keyword2">for</span><span class=""> </span><span class="">R</span><span class=""> </span><span class="">S</span><span class="">
</span><span class="">    </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">rel_mset_def</span><span class="delimiter">[</span><span class="">abs_def</span><span class="delimiter">]</span><span class=""> </span><span class="">OO_def</span><span class="">
</span><span class="">    </span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="">clarify</span><span class="">
</span><span class="">    </span><span class="keyword1"><span class="improper">subgoal</span></span><span class=""> </span><span class="keyword2">for</span><span class=""> </span><span class="">X</span><span class=""> </span><span class="">Z</span><span class=""> </span><span class="">Y</span><span class=""> </span><span class="">xs</span><span class=""> </span><span class="">ys&#39;</span><span class=""> </span><span class="">ys</span><span class=""> </span><span class="">zs</span><span class="">
</span><span class="">      </span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">drule</span><span class=""> </span><span class="">list_all2_reorder_left_invariance</span><span class=""> </span><span class="delimiter">[</span><span class="keyword2">where</span><span class=""> </span><span class="">xs</span><span class=""> </span><span class="delimiter">=</span><span class=""> </span><span class="">ys&#39;</span><span class=""> </span><span class="keyword2">and</span><span class=""> </span><span class="">ys</span><span class=""> </span><span class="delimiter">=</span><span class=""> </span><span class="">zs</span><span class=""> </span><span class="keyword2">and</span><span class=""> </span><span class="">xs&#39;</span><span class=""> </span><span class="delimiter">=</span><span class=""> </span><span class="">ys</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="">
</span><span class="">      </span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">intro</span><span class="delimiter">:</span><span class=""> </span><span class="">list_all2_trans</span><span class="delimiter">)</span><span class="">
</span><span class="">      </span><span class="keyword1"><span class="improper">done</span></span><span class="">
</span><span class="">    </span><span class="keyword1"><span class="improper">done</span></span><span class="">
</span><span class="">  </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;rel_mset R =
    (BNF_Def.Grp {x. set_mset x &#8838; {(x, y). R x y}} (image_mset fst))&#175;&#175; OO
    BNF_Def.Grp {x. set_mset x &#8838; {(x, y). R x y}} (image_mset snd)&quot;</span><span class=""> </span><span class="keyword2">for</span><span class=""> </span><span class="">R</span><span class="">
</span><span class="">    </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">rel_mset_def</span><span class="delimiter">[</span><span class="">abs_def</span><span class="delimiter">]</span><span class=""> </span><span class="">BNF_Def.Grp_def</span><span class=""> </span><span class="">OO_def</span><span class="">
</span><span class="">    </span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">ext</span><span class="delimiter">)</span><span class="delimiter">+</span><span class="">
</span><span class="">    </span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">     </span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">rule_tac</span><span class=""> </span><span class="">x</span><span class=""> </span><span class="delimiter">=</span><span class=""> </span><span class="string">&quot;mset (zip xs ys)&quot;</span><span class=""> </span><span class="keyword2">in</span><span class=""> </span><span class="">exI</span><span class="delimiter">;</span><span class=""> </span><span class="">auto</span><span class="delimiter">)</span><span class="">
</span><span class="">        </span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">metis</span><span class=""> </span><span class="">list_all2_lengthD</span><span class=""> </span><span class="">map_fst_zip</span><span class=""> </span><span class="">mset_map</span><span class="delimiter">)</span><span class="">
</span><span class="">       </span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class="delimiter">:</span><span class=""> </span><span class="">list_all2_iff</span><span class="delimiter">)</span><span class="delimiter">[</span><span class="">1</span><span class="delimiter">]</span><span class="">
</span><span class="">      </span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">metis</span><span class=""> </span><span class="">list_all2_lengthD</span><span class=""> </span><span class="">map_snd_zip</span><span class=""> </span><span class="">mset_map</span><span class="delimiter">)</span><span class="">
</span><span class="">     </span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class="delimiter">:</span><span class=""> </span><span class="">list_all2_iff</span><span class="delimiter">)</span><span class="delimiter">[</span><span class="">1</span><span class="delimiter">]</span><span class="">
</span><span class="">    </span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">rename_tac</span><span class=""> </span><span class="">XY</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">cut_tac</span><span class=""> </span><span class="">X</span><span class=""> </span><span class="delimiter">=</span><span class=""> </span><span class="">XY</span><span class=""> </span><span class="keyword2">in</span><span class=""> </span><span class="">ex_mset</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">erule</span><span class=""> </span><span class="">exE</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">rename_tac</span><span class=""> </span><span class="">xys</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">rule_tac</span><span class=""> </span><span class="">x</span><span class=""> </span><span class="delimiter">=</span><span class=""> </span><span class="string">&quot;map fst xys&quot;</span><span class=""> </span><span class="keyword2">in</span><span class=""> </span><span class="">exI</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class="delimiter">:</span><span class=""> </span><span class="">mset_map</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">rule_tac</span><span class=""> </span><span class="">x</span><span class=""> </span><span class="delimiter">=</span><span class=""> </span><span class="string">&quot;map snd xys&quot;</span><span class=""> </span><span class="keyword2">in</span><span class=""> </span><span class="">exI</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class="delimiter">:</span><span class=""> </span><span class="">mset_map</span><span class=""> </span><span class="">list_all2I</span><span class=""> </span><span class="">subset_eq</span><span class=""> </span><span class="">zip_map_fst_snd</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1"><span class="improper">done</span></span><span class="">
</span><span class="">  </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;z &#8712; set_mset {#} &#10233; False&quot;</span><span class=""> </span><span class="keyword2">for</span><span class=""> </span><span class="">z</span><span class="">
</span><span class="">    </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="keyword1">inductive</span><span class=""> </span><span class="">rel_mset&#39;</span><span class="">
</span><span class="keyword2">where</span><span class="">
</span><span class="">  </span><span class="">Zero</span><span class="delimiter">[</span><span class="">intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;rel_mset&#39; R {#} {#}&quot;</span><span class="">
</span><span class="delimiter">|</span><span class=""> </span><span class="">Plus</span><span class="delimiter">[</span><span class="">intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;&#10214;R a b; rel_mset&#39; R M N&#10215; &#10233; rel_mset&#39; R (M + {#a#}) (N + {#b#})&quot;</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">rel_mset_Zero</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;rel_mset R {#} {#}&quot;</span><span class="">
</span><span class="keyword1">unfolding</span><span class=""> </span><span class="">rel_mset_def</span><span class=""> </span><span class="">Grp_def</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">
</span><span class="keyword1">declare</span><span class=""> </span><span class="">multiset.count</span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="">
</span><span class="keyword1">declare</span><span class=""> </span><span class="">Abs_multiset_inverse</span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="">
</span><span class="keyword1">declare</span><span class=""> </span><span class="">multiset.count_inverse</span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="">
</span><span class="keyword1">declare</span><span class=""> </span><span class="">union_preserves_multiset</span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">rel_mset_Plus</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="">ab</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;R a b&quot;</span><span class="">
</span><span class="">    </span><span class="keyword2">and</span><span class=""> </span><span class="">MN</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;rel_mset R M N&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;rel_mset R (M + {#a#}) (N + {#b#})&quot;</span><span class="">
</span><span class="keyword1">proof</span><span class=""> </span><span class="">-</span><span class="">
</span><span class="">  </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;&#8707;ya. image_mset fst y + {#a#} = image_mset fst ya &#8743;
    image_mset snd y + {#b#} = image_mset snd ya &#8743;
    set_mset ya &#8838; {(x, y). R x y}&quot;</span><span class="">
</span><span class="">    </span><span class="keyword2">if</span><span class=""> </span><span class="string">&quot;R a b&quot;</span><span class=""> </span><span class="keyword2">and</span><span class=""> </span><span class="string">&quot;set_mset y &#8838; {(x, y). R x y}&quot;</span><span class=""> </span><span class="keyword2">for</span><span class=""> </span><span class="">y</span><span class="">
</span><span class="">    </span><span class="keyword1">using</span><span class=""> </span><span class="">that</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">intro</span><span class=""> </span><span class="">exI</span><span class="delimiter">[</span><span class="">of</span><span class=""> </span><span class="">_</span><span class=""> </span><span class="string">&quot;y + {#(a,b)#}&quot;</span><span class="delimiter">]</span><span class="delimiter">)</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">  </span><span class="keyword3">thus</span><span class=""> </span><span class="var">?thesis</span><span class="">
</span><span class="">  </span><span class="keyword1">using</span><span class=""> </span><span class="">assms</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">multiset.rel_compp_Grp</span><span class=""> </span><span class="">Grp_def</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">blast</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">rel_mset&#39;_imp_rel_mset</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;rel_mset&#39; R M N &#10233; rel_mset R M N&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">rule</span><span class="delimiter">:</span><span class=""> </span><span class="">rel_mset&#39;.induct</span><span class="delimiter">)</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class="delimiter">:</span><span class=""> </span><span class="">rel_mset_Zero</span><span class=""> </span><span class="">rel_mset_Plus</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">rel_mset_size</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;rel_mset R M N &#10233; size M = size N&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">multiset.rel_compp_Grp</span><span class=""> </span><span class="">Grp_def</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">multiset_induct2</span><span class="delimiter">[</span><span class="">case_names</span><span class=""> </span><span class="">empty</span><span class=""> </span><span class="">addL</span><span class=""> </span><span class="">addR</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="">empty</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;P {#} {#}&quot;</span><span class="">
</span><span class="">    </span><span class="keyword2">and</span><span class=""> </span><span class="">addL</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;&#8896;M N a. P M N &#10233; P (M + {#a#}) N&quot;</span><span class="">
</span><span class="">    </span><span class="keyword2">and</span><span class=""> </span><span class="">addR</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;&#8896;M N a. P M N &#10233; P M (N + {#a#})&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;P M N&quot;</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">N</span><span class=""> </span><span class="">rule</span><span class="delimiter">:</span><span class=""> </span><span class="">multiset_induct</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">M</span><span class=""> </span><span class="">rule</span><span class="delimiter">:</span><span class=""> </span><span class="">multiset_induct</span><span class="delimiter">,</span><span class=""> </span><span class="">rule</span><span class=""> </span><span class="">empty</span><span class="delimiter">,</span><span class=""> </span><span class="">erule</span><span class=""> </span><span class="">addL</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">M</span><span class=""> </span><span class="">rule</span><span class="delimiter">:</span><span class=""> </span><span class="">multiset_induct</span><span class="delimiter">,</span><span class=""> </span><span class="">erule</span><span class=""> </span><span class="">addR</span><span class="delimiter">,</span><span class=""> </span><span class="">erule</span><span class=""> </span><span class="">addR</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">done</span></span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">multiset_induct2_size</span><span class="delimiter">[</span><span class="">consumes</span><span class=""> </span><span class="">1</span><span class="delimiter">,</span><span class=""> </span><span class="">case_names</span><span class=""> </span><span class="">empty</span><span class=""> </span><span class="">add</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="">c</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;size M = size N&quot;</span><span class="">
</span><span class="">    </span><span class="keyword2">and</span><span class=""> </span><span class="">empty</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;P {#} {#}&quot;</span><span class="">
</span><span class="">    </span><span class="keyword2">and</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;&#8896;M N a b. P M N &#10233; P (M + {#a#}) (N + {#b#})&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;P M N&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">using</span><span class=""> </span><span class="">c</span><span class="">
</span><span class="keyword1">proof</span><span class=""> </span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">M</span><span class=""> </span><span class="">arbitrary</span><span class="delimiter">:</span><span class=""> </span><span class="">N</span><span class=""> </span><span class="">rule</span><span class="delimiter">:</span><span class=""> </span><span class="">measure_induct_rule</span><span class="delimiter">[</span><span class="">of</span><span class=""> </span><span class="">size</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword3">case</span><span class=""> </span><span class="delimiter">(</span><span class="">less</span><span class=""> </span><span class="">M</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword3">show</span><span class=""> </span><span class="var">?case</span><span class="">
</span><span class="">  </span><span class="keyword1">proof</span><span class="delimiter">(</span><span class="">cases</span><span class=""> </span><span class="string">&quot;M = {#}&quot;</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword3">case</span><span class=""> </span><span class="">True</span><span class=""> </span><span class="keyword1">hence</span><span class=""> </span><span class="string">&quot;N = {#}&quot;</span><span class=""> </span><span class="keyword1">using</span><span class=""> </span><span class="">less.prems</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">    </span><span class="keyword3">thus</span><span class=""> </span><span class="var">?thesis</span><span class=""> </span><span class="keyword1">using</span><span class=""> </span><span class="">True</span><span class=""> </span><span class="">empty</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">  </span><span class="keyword1">next</span><span class="">
</span><span class="">    </span><span class="keyword3">case</span><span class=""> </span><span class="">False</span><span class=""> </span><span class="keyword1">then</span><span class=""> </span><span class="keyword3">obtain</span><span class=""> </span><span class="">M1</span><span class=""> </span><span class="">a</span><span class=""> </span><span class="keyword2">where</span><span class=""> </span><span class="">M</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;M = M1 + {#a#}&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">metis</span><span class=""> </span><span class="">multi_nonempty_split</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;N &#8800; {#}&quot;</span><span class=""> </span><span class="keyword1">using</span><span class=""> </span><span class="">False</span><span class=""> </span><span class="">less.prems</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">    </span><span class="keyword1">then</span><span class=""> </span><span class="keyword3">obtain</span><span class=""> </span><span class="">N1</span><span class=""> </span><span class="">b</span><span class=""> </span><span class="keyword2">where</span><span class=""> </span><span class="">N</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;N = N1 + {#b#}&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">metis</span><span class=""> </span><span class="">multi_nonempty_split</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;size M1 = size N1&quot;</span><span class=""> </span><span class="keyword1">using</span><span class=""> </span><span class="">less.prems</span><span class=""> </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">M</span><span class=""> </span><span class="">N</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">    </span><span class="keyword3">thus</span><span class=""> </span><span class="var">?thesis</span><span class=""> </span><span class="keyword1">using</span><span class=""> </span><span class="">M</span><span class=""> </span><span class="">N</span><span class=""> </span><span class="">less.hyps</span><span class=""> </span><span class="">add</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">  </span><span class="keyword1">qed</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">msed_map_invL</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="string">&quot;image_mset f (M + {#a#}) = N&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;&#8707;N1. N = N1 + {#f a#} &#8743; image_mset f M = N1&quot;</span><span class="">
</span><span class="keyword1">proof</span><span class=""> </span><span class="">-</span><span class="">
</span><span class="">  </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;f a &#8712;# N&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">using</span><span class=""> </span><span class="">assms</span><span class=""> </span><span class="">multiset.set_map</span><span class="delimiter">[</span><span class="">of</span><span class=""> </span><span class="">f</span><span class=""> </span><span class="string">&quot;M + {#a#}&quot;</span><span class="delimiter">]</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">  </span><span class="keyword1">then</span><span class=""> </span><span class="keyword3">obtain</span><span class=""> </span><span class="">N1</span><span class=""> </span><span class="keyword2">where</span><span class=""> </span><span class="">N</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;N = N1 + {#f a#}&quot;</span><span class=""> </span><span class="keyword1">using</span><span class=""> </span><span class="">multi_member_split</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">metis</span><span class="">
</span><span class="">  </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;image_mset f M = N1&quot;</span><span class=""> </span><span class="keyword1">using</span><span class=""> </span><span class="">assms</span><span class=""> </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">N</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">  </span><span class="keyword3">thus</span><span class=""> </span><span class="var">?thesis</span><span class=""> </span><span class="keyword1">using</span><span class=""> </span><span class="">N</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">blast</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">msed_map_invR</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="string">&quot;image_mset f M = N + {#b#}&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;&#8707;M1 a. M = M1 + {#a#} &#8743; f a = b &#8743; image_mset f M1 = N&quot;</span><span class="">
</span><span class="keyword1">proof</span><span class=""> </span><span class="">-</span><span class="">
</span><span class="">  </span><span class="keyword3">obtain</span><span class=""> </span><span class="">a</span><span class=""> </span><span class="keyword2">where</span><span class=""> </span><span class="">a</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;a &#8712;# M&quot;</span><span class=""> </span><span class="keyword2">and</span><span class=""> </span><span class="">fa</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;f a = b&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">using</span><span class=""> </span><span class="">multiset.set_map</span><span class="delimiter">[</span><span class="">of</span><span class=""> </span><span class="">f</span><span class=""> </span><span class="">M</span><span class="delimiter">]</span><span class=""> </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">assms</span><span class="">
</span><span class="">    </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">metis</span><span class=""> </span><span class="">image_iff</span><span class=""> </span><span class="">mem_set_mset_iff</span><span class=""> </span><span class="">union_single_eq_member</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">then</span><span class=""> </span><span class="keyword3">obtain</span><span class=""> </span><span class="">M1</span><span class=""> </span><span class="keyword2">where</span><span class=""> </span><span class="">M</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;M = M1 + {#a#}&quot;</span><span class=""> </span><span class="keyword1">using</span><span class=""> </span><span class="">multi_member_split</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">metis</span><span class="">
</span><span class="">  </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;image_mset f M1 = N&quot;</span><span class=""> </span><span class="keyword1">using</span><span class=""> </span><span class="">assms</span><span class=""> </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">M</span><span class=""> </span><span class="">fa</span><span class="delimiter">[</span><span class="">symmetric</span><span class="delimiter">]</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">  </span><span class="keyword3">thus</span><span class=""> </span><span class="var">?thesis</span><span class=""> </span><span class="keyword1">using</span><span class=""> </span><span class="">M</span><span class=""> </span><span class="">fa</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">blast</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">msed_rel_invL</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="string">&quot;rel_mset R (M + {#a#}) N&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;&#8707;N1 b. N = N1 + {#b#} &#8743; R a b &#8743; rel_mset R M N1&quot;</span><span class="">
</span><span class="keyword1">proof</span><span class=""> </span><span class="">-</span><span class="">
</span><span class="">  </span><span class="keyword3">obtain</span><span class=""> </span><span class="">K</span><span class=""> </span><span class="keyword2">where</span><span class=""> </span><span class="">KM</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;image_mset fst K = M + {#a#}&quot;</span><span class="">
</span><span class="">    </span><span class="keyword2">and</span><span class=""> </span><span class="">KN</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;image_mset snd K = N&quot;</span><span class=""> </span><span class="keyword2">and</span><span class=""> </span><span class="">sK</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;set_mset K &#8838; {(a, b). R a b}&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">using</span><span class=""> </span><span class="">assms</span><span class="">
</span><span class="">    </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">multiset.rel_compp_Grp</span><span class=""> </span><span class="">Grp_def</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">  </span><span class="keyword3">obtain</span><span class=""> </span><span class="">K1</span><span class=""> </span><span class="">ab</span><span class=""> </span><span class="keyword2">where</span><span class=""> </span><span class="">K</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;K = K1 + {#ab#}&quot;</span><span class=""> </span><span class="keyword2">and</span><span class=""> </span><span class="">a</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;fst ab = a&quot;</span><span class="">
</span><span class="">    </span><span class="keyword2">and</span><span class=""> </span><span class="">K1M</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;image_mset fst K1 = M&quot;</span><span class=""> </span><span class="keyword1">using</span><span class=""> </span><span class="">msed_map_invR</span><span class="delimiter">[</span><span class="">OF</span><span class=""> </span><span class="">KM</span><span class="delimiter">]</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">  </span><span class="keyword3">obtain</span><span class=""> </span><span class="">N1</span><span class=""> </span><span class="keyword2">where</span><span class=""> </span><span class="">N</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;N = N1 + {#snd ab#}&quot;</span><span class=""> </span><span class="keyword2">and</span><span class=""> </span><span class="">K1N1</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;image_mset snd K1 = N1&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">using</span><span class=""> </span><span class="">msed_map_invL</span><span class="delimiter">[</span><span class="">OF</span><span class=""> </span><span class="">KN</span><span class="delimiter">[</span><span class="">unfolded</span><span class=""> </span><span class="">K</span><span class="delimiter">]</span><span class="delimiter">]</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">  </span><span class="keyword1">have</span><span class=""> </span><span class="">Rab</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;R a (snd ab)&quot;</span><span class=""> </span><span class="keyword1">using</span><span class=""> </span><span class="">sK</span><span class=""> </span><span class="">a</span><span class=""> </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">K</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">  </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;rel_mset R M N1&quot;</span><span class=""> </span><span class="keyword1">using</span><span class=""> </span><span class="">sK</span><span class=""> </span><span class="">K1M</span><span class=""> </span><span class="">K1N1</span><span class="">
</span><span class="">    </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">K</span><span class=""> </span><span class="">multiset.rel_compp_Grp</span><span class=""> </span><span class="">Grp_def</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">  </span><span class="keyword3">thus</span><span class=""> </span><span class="var">?thesis</span><span class=""> </span><span class="keyword1">using</span><span class=""> </span><span class="">N</span><span class=""> </span><span class="">Rab</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">msed_rel_invR</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="string">&quot;rel_mset R M (N + {#b#})&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;&#8707;M1 a. M = M1 + {#a#} &#8743; R a b &#8743; rel_mset R M1 N&quot;</span><span class="">
</span><span class="keyword1">proof</span><span class=""> </span><span class="">-</span><span class="">
</span><span class="">  </span><span class="keyword3">obtain</span><span class=""> </span><span class="">K</span><span class=""> </span><span class="keyword2">where</span><span class=""> </span><span class="">KN</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;image_mset snd K = N + {#b#}&quot;</span><span class="">
</span><span class="">    </span><span class="keyword2">and</span><span class=""> </span><span class="">KM</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;image_mset fst K = M&quot;</span><span class=""> </span><span class="keyword2">and</span><span class=""> </span><span class="">sK</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;set_mset K &#8838; {(a, b). R a b}&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">using</span><span class=""> </span><span class="">assms</span><span class="">
</span><span class="">    </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">multiset.rel_compp_Grp</span><span class=""> </span><span class="">Grp_def</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">  </span><span class="keyword3">obtain</span><span class=""> </span><span class="">K1</span><span class=""> </span><span class="">ab</span><span class=""> </span><span class="keyword2">where</span><span class=""> </span><span class="">K</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;K = K1 + {#ab#}&quot;</span><span class=""> </span><span class="keyword2">and</span><span class=""> </span><span class="">b</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;snd ab = b&quot;</span><span class="">
</span><span class="">    </span><span class="keyword2">and</span><span class=""> </span><span class="">K1N</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;image_mset snd K1 = N&quot;</span><span class=""> </span><span class="keyword1">using</span><span class=""> </span><span class="">msed_map_invR</span><span class="delimiter">[</span><span class="">OF</span><span class=""> </span><span class="">KN</span><span class="delimiter">]</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">  </span><span class="keyword3">obtain</span><span class=""> </span><span class="">M1</span><span class=""> </span><span class="keyword2">where</span><span class=""> </span><span class="">M</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;M = M1 + {#fst ab#}&quot;</span><span class=""> </span><span class="keyword2">and</span><span class=""> </span><span class="">K1M1</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;image_mset fst K1 = M1&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">using</span><span class=""> </span><span class="">msed_map_invL</span><span class="delimiter">[</span><span class="">OF</span><span class=""> </span><span class="">KM</span><span class="delimiter">[</span><span class="">unfolded</span><span class=""> </span><span class="">K</span><span class="delimiter">]</span><span class="delimiter">]</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">  </span><span class="keyword1">have</span><span class=""> </span><span class="">Rab</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;R (fst ab) b&quot;</span><span class=""> </span><span class="keyword1">using</span><span class=""> </span><span class="">sK</span><span class=""> </span><span class="">b</span><span class=""> </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">K</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">  </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;rel_mset R M1 N&quot;</span><span class=""> </span><span class="keyword1">using</span><span class=""> </span><span class="">sK</span><span class=""> </span><span class="">K1N</span><span class=""> </span><span class="">K1M1</span><span class="">
</span><span class="">    </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">K</span><span class=""> </span><span class="">multiset.rel_compp_Grp</span><span class=""> </span><span class="">Grp_def</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">  </span><span class="keyword3">thus</span><span class=""> </span><span class="var">?thesis</span><span class=""> </span><span class="keyword1">using</span><span class=""> </span><span class="">M</span><span class=""> </span><span class="">Rab</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">rel_mset_imp_rel_mset&#39;</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="string">&quot;rel_mset R M N&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;rel_mset&#39; R M N&quot;</span><span class="">
</span><span class="keyword1">using</span><span class=""> </span><span class="">assms</span><span class=""> </span><span class="keyword1">proof</span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">M</span><span class=""> </span><span class="">arbitrary</span><span class="delimiter">:</span><span class=""> </span><span class="">N</span><span class=""> </span><span class="">rule</span><span class="delimiter">:</span><span class=""> </span><span class="">measure_induct_rule</span><span class="delimiter">[</span><span class="">of</span><span class=""> </span><span class="">size</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword3">case</span><span class=""> </span><span class="delimiter">(</span><span class="">less</span><span class=""> </span><span class="">M</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">have</span><span class=""> </span><span class="">c</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;size M = size N&quot;</span><span class=""> </span><span class="keyword1">using</span><span class=""> </span><span class="">rel_mset_size</span><span class="delimiter">[</span><span class="">OF</span><span class=""> </span><span class="">less.prems</span><span class="delimiter">]</span><span class=""> </span><span class="keyword1">.</span><span class="">
</span><span class="">  </span><span class="keyword3">show</span><span class=""> </span><span class="var">?case</span><span class="">
</span><span class="">  </span><span class="keyword1">proof</span><span class="delimiter">(</span><span class="">cases</span><span class=""> </span><span class="string">&quot;M = {#}&quot;</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword3">case</span><span class=""> </span><span class="">True</span><span class=""> </span><span class="keyword1">hence</span><span class=""> </span><span class="string">&quot;N = {#}&quot;</span><span class=""> </span><span class="keyword1">using</span><span class=""> </span><span class="">c</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">    </span><span class="keyword3">thus</span><span class=""> </span><span class="var">?thesis</span><span class=""> </span><span class="keyword1">using</span><span class=""> </span><span class="">True</span><span class=""> </span><span class="">rel_mset&#39;.Zero</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">  </span><span class="keyword1">next</span><span class="">
</span><span class="">    </span><span class="keyword3">case</span><span class=""> </span><span class="">False</span><span class=""> </span><span class="keyword1">then</span><span class=""> </span><span class="keyword3">obtain</span><span class=""> </span><span class="">M1</span><span class=""> </span><span class="">a</span><span class=""> </span><span class="keyword2">where</span><span class=""> </span><span class="">M</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;M = M1 + {#a#}&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">metis</span><span class=""> </span><span class="">multi_nonempty_split</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword3">obtain</span><span class=""> </span><span class="">N1</span><span class=""> </span><span class="">b</span><span class=""> </span><span class="keyword2">where</span><span class=""> </span><span class="">N</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;N = N1 + {#b#}&quot;</span><span class=""> </span><span class="keyword2">and</span><span class=""> </span><span class="">R</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;R a b&quot;</span><span class=""> </span><span class="keyword2">and</span><span class=""> </span><span class="">ms</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;rel_mset R M1 N1&quot;</span><span class="">
</span><span class="">      </span><span class="keyword1">using</span><span class=""> </span><span class="">msed_rel_invL</span><span class="delimiter">[</span><span class="">OF</span><span class=""> </span><span class="">less.prems</span><span class="delimiter">[</span><span class="">unfolded</span><span class=""> </span><span class="">M</span><span class="delimiter">]</span><span class="delimiter">]</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">    </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;rel_mset&#39; R M1 N1&quot;</span><span class=""> </span><span class="keyword1">using</span><span class=""> </span><span class="">less.hyps</span><span class="delimiter">[</span><span class="">of</span><span class=""> </span><span class="">M1</span><span class=""> </span><span class="">N1</span><span class="delimiter">]</span><span class=""> </span><span class="">ms</span><span class=""> </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">M</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">    </span><span class="keyword3">thus</span><span class=""> </span><span class="var">?thesis</span><span class=""> </span><span class="keyword1">using</span><span class=""> </span><span class="">rel_mset&#39;.Plus</span><span class="delimiter">[</span><span class="">of</span><span class=""> </span><span class="">R</span><span class=""> </span><span class="">a</span><span class=""> </span><span class="">b</span><span class="delimiter">,</span><span class=""> </span><span class="">OF</span><span class=""> </span><span class="">R</span><span class="delimiter">]</span><span class=""> </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">M</span><span class=""> </span><span class="">N</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">  </span><span class="keyword1">qed</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">rel_mset_rel_mset&#39;</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;rel_mset R M N = rel_mset&#39; R M N&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">using</span><span class=""> </span><span class="">rel_mset_imp_rel_mset&#39;</span><span class=""> </span><span class="">rel_mset&#39;_imp_rel_mset</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">
</span><span class="keyword1">text</span><span class=""> </span><span class="cartouche">&#8249;The main end product for @{const rel_mset}: inductive characterization:&#8250;</span><span class="">
</span><span class="keyword1">lemmas</span><span class=""> </span><span class="">rel_mset_induct</span><span class="delimiter">[</span><span class="">case_names</span><span class=""> </span><span class="">empty</span><span class=""> </span><span class="">add</span><span class="delimiter">,</span><span class=""> </span><span class="">induct</span><span class=""> </span><span class="">pred</span><span class="delimiter">:</span><span class=""> </span><span class="">rel_mset</span><span class="delimiter">]</span><span class=""> </span><span class="delimiter">=</span><span class="">
</span><span class="">  </span><span class="">rel_mset&#39;.induct</span><span class="delimiter">[</span><span class="">unfolded</span><span class=""> </span><span class="">rel_mset_rel_mset&#39;</span><span class="delimiter">[</span><span class="">symmetric</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="">
</span><span class="">
</span><span class="">
</span><span class="keyword1">subsection</span><span class=""> </span><span class="cartouche">&#8249;Size setup&#8250;</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">multiset_size_o_map</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;size_multiset g &#8728; image_mset f = size_multiset (g &#8728; f)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">ext</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">subgoal</span></span><span class=""> </span><span class="keyword2">for</span><span class=""> </span><span class="">x</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">x</span><span class="delimiter">)</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">done</span></span><span class="">
</span><span class="">
</span><span class="keyword1">setup</span><span class=""> </span><span class="cartouche">&#8249;
  BNF_LFP_Size.register_size_global @{type_name multiset} @{const_name size_multiset}
    @{thm size_multiset_overloaded_def}
    @{thms size_multiset_empty size_multiset_single size_multiset_union size_empty size_single
      size_union}
    @{thms multiset_size_o_map}
&#8250;</span><span class="">
</span><span class="">
</span><span class="keyword1">hide_const</span><span class=""> </span><span class="delimiter">(</span><span class="keyword2">open</span><span class="delimiter">)</span><span class=""> </span><span class="">wcount</span><span class="">
</span><span class="">
</span><span class="keyword2">end</span><span class="">
</span></pre>

</div>
</body>
</html>
