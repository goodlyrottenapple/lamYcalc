<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>Theory FinFun (Isabelle2016: February 2016)</title>
<link media="all" rel="stylesheet" type="text/css" href="isabelle.css"/>
</head>

<body>
<div class="head"><h1>Theory FinFun</h1>

<span class="command">theory</span> <span class="name">FinFun</span><br/>
<span class="keyword">imports</span> <a href="Cardinality.html"><span class="name">Cardinality</span></a><br/>

</div>
<div class="source">
<pre class="source"><span class="comment">(* Author: Andreas Lochbihler, Uni Karlsruhe *)</span><span class="">
</span><span class="">
</span><span class="keyword1">section</span><span class=""> </span><span class="cartouche">&#8249;Almost everywhere constant functions&#8250;</span><span class="">
</span><span class="">
</span><span class="keyword1">theory</span><span class=""> </span><span class="">FinFun</span><span class="">
</span><span class="keyword2">imports</span><span class=""> </span><span class="">Cardinality</span><span class="">
</span><span class="keyword2">begin</span><span class="">
</span><span class="">
</span><span class="keyword1">text</span><span class=""> </span><span class="cartouche">&#8249;
  This theory defines functions which are constant except for finitely
  many points (FinFun) and introduces a type finfin along with a
  number of operators for them. The code generator is set up such that
  such functions can be represented as data in the generated code and
  all operators are executable.

  For details, see Formalising FinFuns - Generating Code for Functions as Data by A. Lochbihler in TPHOLs 2009.
&#8250;</span><span class="">
</span><span class="">
</span><span class="">
</span><span class="keyword1">subsection</span><span class=""> </span><span class="cartouche">&#8249;The &#8249;map_default&#8250; operation&#8250;</span><span class="">
</span><span class="">
</span><span class="keyword1">definition</span><span class=""> </span><span class="">map_default</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;&#39;b &#8658; (&#39;a &#8640; &#39;b) &#8658; &#39;a &#8658; &#39;b&quot;</span><span class="">
</span><span class="keyword2">where</span><span class=""> </span><span class="string">&quot;map_default b f a &#8801; case f a of None &#8658; b | Some b&#39; &#8658; b&#39;&quot;</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">map_default_delete</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="string">&quot;map_default b (f(a := None)) = (map_default b f)(a := b)&quot;</span><span class="">
</span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">map_default_def</span><span class=""> </span><span class="">fun_eq_iff</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">map_default_insert</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="string">&quot;map_default b (f(a &#8614; b&#39;)) = (map_default b f)(a := b&#39;)&quot;</span><span class="">
</span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">map_default_def</span><span class=""> </span><span class="">fun_eq_iff</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">map_default_empty</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;map_default b empty = (&#955;a. b)&quot;</span><span class="">
</span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">fun_eq_iff</span><span class=""> </span><span class="">map_default_def</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">map_default_inject</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">fixes</span><span class=""> </span><span class="">g</span><span class=""> </span><span class="">g&#39;</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;&#39;a &#8640; &#39;b&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="">infin_eq</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;&#172; finite (UNIV :: &#39;a set) &#8744; b = b&#39;&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">and</span><span class=""> </span><span class="">fin</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;finite (dom g)&quot;</span><span class=""> </span><span class="keyword2">and</span><span class=""> </span><span class="">b</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;b &#8713; ran g&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">and</span><span class=""> </span><span class="">fin&#39;</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;finite (dom g&#39;)&quot;</span><span class=""> </span><span class="keyword2">and</span><span class=""> </span><span class="">b&#39;</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;b&#39; &#8713; ran g&#39;&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">and</span><span class=""> </span><span class="">eq&#39;</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;map_default b g = map_default b&#39; g&#39;&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;b = b&#39;&quot;</span><span class=""> </span><span class="string">&quot;g = g&#39;&quot;</span><span class="">
</span><span class="keyword1">proof</span><span class=""> </span><span class="">-</span><span class="">
</span><span class="">  </span><span class="keyword1">from</span><span class=""> </span><span class="">infin_eq</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="">bb&#39;</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;b = b&#39;&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">proof</span><span class="">
</span><span class="">    </span><span class="keyword3">assume</span><span class=""> </span><span class="">infin</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;&#172; finite (UNIV :: &#39;a set)&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">from</span><span class=""> </span><span class="">fin</span><span class=""> </span><span class="">fin&#39;</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;finite (dom g &#8746; dom g&#39;)&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">    </span><span class="keyword1">with</span><span class=""> </span><span class="">infin</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;UNIV - (dom g &#8746; dom g&#39;) &#8800; {}&quot;</span><span class=""> </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">dest</span><span class="delimiter">:</span><span class=""> </span><span class="">finite_subset</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1">then</span><span class=""> </span><span class="keyword3">obtain</span><span class=""> </span><span class="">a</span><span class=""> </span><span class="keyword2">where</span><span class=""> </span><span class="">a</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;a &#8713; dom g &#8746; dom g&#39;&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">    </span><span class="keyword1">hence</span><span class=""> </span><span class="string">&quot;map_default b g a = b&quot;</span><span class=""> </span><span class="string">&quot;map_default b&#39; g&#39; a = b&#39;&quot;</span><span class=""> </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">map_default_def</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1">with</span><span class=""> </span><span class="">eq&#39;</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;b = b&#39;&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">  </span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="">  </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;g = g&#39;&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">proof</span><span class="">
</span><span class="">    </span><span class="keyword3">fix</span><span class=""> </span><span class="">x</span><span class="">
</span><span class="">    </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;g x = g&#39; x&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">proof</span><span class="delimiter">(</span><span class="">cases</span><span class=""> </span><span class="string">&quot;g x&quot;</span><span class="delimiter">)</span><span class="">
</span><span class="">      </span><span class="keyword3">case</span><span class=""> </span><span class="">None</span><span class="">
</span><span class="">      </span><span class="keyword1">hence</span><span class=""> </span><span class="string">&quot;map_default b g x = b&quot;</span><span class=""> </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">map_default_def</span><span class="delimiter">)</span><span class="">
</span><span class="">      </span><span class="keyword1">with</span><span class=""> </span><span class="">bb&#39;</span><span class=""> </span><span class="">eq&#39;</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;map_default b&#39; g&#39; x = b&#39;&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">      </span><span class="keyword1">with</span><span class=""> </span><span class="">b&#39;</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;g&#39; x = None&quot;</span><span class=""> </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">map_default_def</span><span class=""> </span><span class="">ran_def</span><span class=""> </span><span class="">split</span><span class="delimiter">:</span><span class=""> </span><span class="">option.split_asm</span><span class="delimiter">)</span><span class="">
</span><span class="">      </span><span class="keyword1">with</span><span class=""> </span><span class="">None</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="var">?thesis</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">    </span><span class="keyword1">next</span><span class="">
</span><span class="">      </span><span class="keyword3">case</span><span class=""> </span><span class="delimiter">(</span><span class="">Some</span><span class=""> </span><span class="">c</span><span class="delimiter">)</span><span class="">
</span><span class="">      </span><span class="keyword1">with</span><span class=""> </span><span class="">b</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="">cb</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;c &#8800; b&quot;</span><span class=""> </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">ran_def</span><span class="delimiter">)</span><span class="">
</span><span class="">      </span><span class="keyword1">moreover</span><span class=""> </span><span class="keyword1">from</span><span class=""> </span><span class="">Some</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;map_default b g x = c&quot;</span><span class=""> </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">map_default_def</span><span class="delimiter">)</span><span class="">
</span><span class="">      </span><span class="keyword1">with</span><span class=""> </span><span class="">eq&#39;</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;map_default b&#39; g&#39; x = c&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">      </span><span class="keyword1">ultimately</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;g&#39; x = Some c&quot;</span><span class=""> </span><span class="keyword1">using</span><span class=""> </span><span class="">b&#39;</span><span class=""> </span><span class="">bb&#39;</span><span class=""> </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">map_default_def</span><span class=""> </span><span class="">split</span><span class="delimiter">:</span><span class=""> </span><span class="">option.splits</span><span class="delimiter">)</span><span class="">
</span><span class="">      </span><span class="keyword1">with</span><span class=""> </span><span class="">Some</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="var">?thesis</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">    </span><span class="keyword1">qed</span><span class="">
</span><span class="">  </span><span class="keyword1">qed</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="keyword1">subsection</span><span class=""> </span><span class="cartouche">&#8249;The finfun type&#8250;</span><span class="">
</span><span class="">
</span><span class="keyword1">definition</span><span class=""> </span><span class="string">&quot;finfun = {f::&#39;a&#8658;&#39;b. &#8707;b. finite {a. f a &#8800; b}}&quot;</span><span class="">
</span><span class="">
</span><span class="keyword1">typedef</span><span class=""> </span><span class="delimiter">(</span><span class="tfree">&#39;a</span><span class="delimiter">,</span><span class="tfree">&#39;b</span><span class="delimiter">)</span><span class=""> </span><span class="">finfun</span><span class="">  </span><span class="delimiter">(</span><span class="string">&quot;(_ &#8658;f /_)&quot;</span><span class=""> </span><span class="delimiter">[</span><span class="">22</span><span class="delimiter">,</span><span class=""> </span><span class="">21</span><span class="delimiter">]</span><span class=""> </span><span class="">21</span><span class="delimiter">)</span><span class=""> </span><span class="delimiter">=</span><span class=""> </span><span class="string">&quot;finfun :: (&#39;a =&gt; &#39;b) set&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">morphisms</span><span class=""> </span><span class="">finfun_apply</span><span class=""> </span><span class="">Abs_finfun</span><span class="">
</span><span class="keyword1">proof</span><span class=""> </span><span class="">-</span><span class="">
</span><span class="">  </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;&#8707;f. finite {x. f x &#8800; undefined}&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">proof</span><span class="">
</span><span class="">    </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;finite {x. (&#955;y. undefined) x &#8800; undefined}&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">  </span><span class="keyword1">qed</span><span class="">
</span><span class="">  </span><span class="keyword1">then</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="var">?thesis</span><span class=""> </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">finfun_def</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="keyword1">type_notation</span><span class=""> </span><span class="">finfun</span><span class=""> </span><span class="delimiter">(</span><span class="string">&quot;(_ &#8658;f /_)&quot;</span><span class=""> </span><span class="delimiter">[</span><span class="">22</span><span class="delimiter">,</span><span class=""> </span><span class="">21</span><span class="delimiter">]</span><span class=""> </span><span class="">21</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">setup_lifting</span><span class=""> </span><span class="">type_definition_finfun</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">fun_upd_finfun</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;y(a := b) &#8712; finfun &#10231; y &#8712; finfun&quot;</span><span class="">
</span><span class="keyword1">proof</span><span class=""> </span><span class="">-</span><span class="">
</span><span class="">  </span><span class="keyword1">{</span><span class=""> </span><span class="keyword3">fix</span><span class=""> </span><span class="">b&#39;</span><span class="">
</span><span class="">    </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;finite {a&#39;. (y(a := b)) a&#39; &#8800; b&#39;} = finite {a&#39;. y a&#39; &#8800; b&#39;}&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">proof</span><span class="delimiter">(</span><span class="">cases</span><span class=""> </span><span class="string">&quot;b = b&#39;&quot;</span><span class="delimiter">)</span><span class="">
</span><span class="">      </span><span class="keyword3">case</span><span class=""> </span><span class="">True</span><span class="">
</span><span class="">      </span><span class="keyword1">hence</span><span class=""> </span><span class="string">&quot;{a&#39;. (y(a := b)) a&#39; &#8800; b&#39;} = {a&#39;. y a&#39; &#8800; b&#39;} - {a}&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">      </span><span class="keyword3">thus</span><span class=""> </span><span class="var">?thesis</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">    </span><span class="keyword1">next</span><span class="">
</span><span class="">      </span><span class="keyword3">case</span><span class=""> </span><span class="">False</span><span class="">
</span><span class="">      </span><span class="keyword1">hence</span><span class=""> </span><span class="string">&quot;{a&#39;. (y(a := b)) a&#39; &#8800; b&#39;} = insert a {a&#39;. y a&#39; &#8800; b&#39;}&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">      </span><span class="keyword3">thus</span><span class=""> </span><span class="var">?thesis</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">    </span><span class="keyword1">qed</span><span class=""> </span><span class="keyword1">}</span><span class="">
</span><span class="">  </span><span class="keyword3">thus</span><span class=""> </span><span class="var">?thesis</span><span class=""> </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">finfun_def</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">blast</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">const_finfun</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;(&#955;x. a) &#8712; finfun&quot;</span><span class="">
</span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_def</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">finfun_left_compose</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="string">&quot;y &#8712; finfun&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;g &#8728; y &#8712; finfun&quot;</span><span class="">
</span><span class="keyword1">proof</span><span class=""> </span><span class="">-</span><span class="">
</span><span class="">  </span><span class="keyword1">from</span><span class=""> </span><span class="">assms</span><span class=""> </span><span class="keyword3">obtain</span><span class=""> </span><span class="">b</span><span class=""> </span><span class="keyword2">where</span><span class=""> </span><span class="string">&quot;finite {a. y a &#8800; b}&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">finfun_def</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">blast</span><span class="">
</span><span class="">  </span><span class="keyword1">hence</span><span class=""> </span><span class="string">&quot;finite {c. g (y c) &#8800; g b}&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">proof</span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="string">&quot;{a. y a &#8800; b}&quot;</span><span class=""> </span><span class="">arbitrary</span><span class="delimiter">:</span><span class=""> </span><span class="">y</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword3">case</span><span class=""> </span><span class="">empty</span><span class="">
</span><span class="">    </span><span class="keyword1">hence</span><span class=""> </span><span class="string">&quot;y = (&#955;a. b)&quot;</span><span class=""> </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">auto</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword3">thus</span><span class=""> </span><span class="var">?case</span><span class=""> </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">simp</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">next</span><span class="">
</span><span class="">    </span><span class="keyword3">case</span><span class=""> </span><span class="delimiter">(</span><span class="">insert</span><span class=""> </span><span class="">x</span><span class=""> </span><span class="">F</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1">note</span><span class=""> </span><span class="">IH</span><span class=""> </span><span class="delimiter">=</span><span class=""> </span><span class="cartouche">&#8249;&#8896;y. F = {a. y a &#8800; b} &#10233; finite {c. g (y c) &#8800; g b}&#8250;</span><span class="">
</span><span class="">    </span><span class="keyword1">from</span><span class=""> </span><span class="cartouche">&#8249;insert x F = {a. y a &#8800; b}&#8250;</span><span class=""> </span><span class="cartouche">&#8249;x &#8713; F&#8250;</span><span class="">
</span><span class="">    </span><span class="keyword1">have</span><span class=""> </span><span class="">F</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;F = {a. (y(x := b)) a &#8800; b}&quot;</span><span class=""> </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">auto</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword3">show</span><span class=""> </span><span class="var">?case</span><span class="">
</span><span class="">    </span><span class="keyword1">proof</span><span class="delimiter">(</span><span class="">cases</span><span class=""> </span><span class="string">&quot;g (y x) = g b&quot;</span><span class="delimiter">)</span><span class="">
</span><span class="">      </span><span class="keyword3">case</span><span class=""> </span><span class="">True</span><span class="">
</span><span class="">      </span><span class="keyword1">hence</span><span class=""> </span><span class="string">&quot;{c. g ((y(x := b)) c) &#8800; g b} = {c. g (y c) &#8800; g b}&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">      </span><span class="keyword1">with</span><span class=""> </span><span class="">IH</span><span class="delimiter">[</span><span class="">OF</span><span class=""> </span><span class="">F</span><span class="delimiter">]</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="var">?thesis</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">    </span><span class="keyword1">next</span><span class="">
</span><span class="">      </span><span class="keyword3">case</span><span class=""> </span><span class="">False</span><span class="">
</span><span class="">      </span><span class="keyword1">hence</span><span class=""> </span><span class="string">&quot;{c. g (y c) &#8800; g b} = insert x {c. g ((y(x := b)) c) &#8800; g b}&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">      </span><span class="keyword1">with</span><span class=""> </span><span class="">IH</span><span class="delimiter">[</span><span class="">OF</span><span class=""> </span><span class="">F</span><span class="delimiter">]</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="var">?thesis</span><span class=""> </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">simp</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1">qed</span><span class="">
</span><span class="">  </span><span class="keyword1">qed</span><span class="">
</span><span class="">  </span><span class="keyword3">thus</span><span class=""> </span><span class="var">?thesis</span><span class=""> </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">finfun_def</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="keyword2">assumes</span><span class=""> </span><span class="string">&quot;y &#8712; finfun&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="">fst_finfun</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;fst &#8728; y &#8712; finfun&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">and</span><span class=""> </span><span class="">snd_finfun</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;snd &#8728; y &#8712; finfun&quot;</span><span class="">
</span><span class="keyword1">proof</span><span class=""> </span><span class="">-</span><span class="">
</span><span class="">  </span><span class="keyword1">from</span><span class=""> </span><span class="">assms</span><span class=""> </span><span class="keyword3">obtain</span><span class=""> </span><span class="">b</span><span class=""> </span><span class="">c</span><span class=""> </span><span class="keyword2">where</span><span class=""> </span><span class="">bc</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;finite {a. y a &#8800; (b, c)}&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">finfun_def</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">  </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;{a. fst (y a) &#8800; b} &#8838; {a. y a &#8800; (b, c)}&quot;</span><span class="">
</span><span class="">    </span><span class="keyword2">and</span><span class=""> </span><span class="string">&quot;{a. snd (y a) &#8800; c} &#8838; {a. y a &#8800; (b, c)}&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">  </span><span class="keyword1">hence</span><span class=""> </span><span class="string">&quot;finite {a. fst (y a) &#8800; b}&quot;</span><span class=""> 
</span><span class="">    </span><span class="keyword2">and</span><span class=""> </span><span class="string">&quot;finite {a. snd (y a) &#8800; c}&quot;</span><span class=""> </span><span class="keyword1">using</span><span class=""> </span><span class="">bc</span><span class=""> </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">intro</span><span class="delimiter">:</span><span class=""> </span><span class="">finite_subset</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword3">thus</span><span class=""> </span><span class="string">&quot;fst &#8728; y &#8712; finfun&quot;</span><span class=""> </span><span class="string">&quot;snd &#8728; y &#8712; finfun&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">finfun_def</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">map_of_finfun</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;map_of xs &#8712; finfun&quot;</span><span class="">
</span><span class="keyword1">unfolding</span><span class=""> </span><span class="">finfun_def</span><span class="">
</span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">xs</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">Collect_neg_eq</span><span class=""> </span><span class="">Collect_conj_eq</span><span class=""> </span><span class="">Collect_imp_eq</span><span class=""> </span><span class="">intro</span><span class="delimiter">:</span><span class=""> </span><span class="">finite_subset</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">Diag_finfun</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;(&#955;x. (f x, g x)) &#8712; finfun &#10231; f &#8712; finfun &#8743; g &#8712; finfun&quot;</span><span class="">
</span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">intro</span><span class="delimiter">:</span><span class=""> </span><span class="">finite_subset</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">Collect_neg_eq</span><span class=""> </span><span class="">Collect_imp_eq</span><span class=""> </span><span class="">Collect_conj_eq</span><span class=""> </span><span class="">finfun_def</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">finfun_right_compose</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="">g</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;g &#8712; finfun&quot;</span><span class=""> </span><span class="keyword2">and</span><span class=""> </span><span class="">inj</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;inj f&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;g o f &#8712; finfun&quot;</span><span class="">
</span><span class="keyword1">proof</span><span class=""> </span><span class="">-</span><span class="">
</span><span class="">  </span><span class="keyword1">from</span><span class=""> </span><span class="">g</span><span class=""> </span><span class="keyword3">obtain</span><span class=""> </span><span class="">b</span><span class=""> </span><span class="keyword2">where</span><span class=""> </span><span class="">b</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;finite {a. g a &#8800; b}&quot;</span><span class=""> </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">finfun_def</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">blast</span><span class="">
</span><span class="">  </span><span class="keyword1">moreover</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;f ` {a. g (f a) &#8800; b} &#8838; {a. g a &#8800; b}&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">  </span><span class="keyword1">moreover</span><span class=""> </span><span class="keyword1">from</span><span class=""> </span><span class="">inj</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;inj_on f {a.  g (f a) &#8800; b}&quot;</span><span class=""> </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">subset_inj_on</span><span class="delimiter">)</span><span class=""> </span><span class="">blast</span><span class="">
</span><span class="">  </span><span class="keyword1">ultimately</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;finite {a. g (f a) &#8800; b}&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">blast</span><span class=""> </span><span class="">intro</span><span class="delimiter">:</span><span class=""> </span><span class="">finite_imageD</span><span class="delimiter">[</span><span class="keyword2">where</span><span class=""> </span><span class="">f</span><span class="delimiter">=</span><span class="">f</span><span class="delimiter">]</span><span class=""> </span><span class="">finite_subset</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword3">thus</span><span class=""> </span><span class="var">?thesis</span><span class=""> </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">finfun_def</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">finfun_curry</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="">fin</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;f &#8712; finfun&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;curry f &#8712; finfun&quot;</span><span class=""> </span><span class="string">&quot;curry f a &#8712; finfun&quot;</span><span class="">
</span><span class="keyword1">proof</span><span class=""> </span><span class="">-</span><span class="">
</span><span class="">  </span><span class="keyword1">from</span><span class=""> </span><span class="">fin</span><span class=""> </span><span class="keyword3">obtain</span><span class=""> </span><span class="">c</span><span class=""> </span><span class="keyword2">where</span><span class=""> </span><span class="">c</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;finite {ab. f ab &#8800; c}&quot;</span><span class=""> </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">finfun_def</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">blast</span><span class="">
</span><span class="">  </span><span class="keyword1">moreover</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;{a. &#8707;b. f (a, b) &#8800; c} = fst ` {ab. f ab &#8800; c}&quot;</span><span class=""> </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">force</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">hence</span><span class=""> </span><span class="string">&quot;{a. curry f a &#8800; (&#955;b. c)} = fst ` {ab. f ab &#8800; c}&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">curry_def</span><span class=""> </span><span class="">fun_eq_iff</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">ultimately</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;finite {a. curry f a &#8800; (&#955;b. c)}&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">  </span><span class="keyword3">thus</span><span class=""> </span><span class="string">&quot;curry f &#8712; finfun&quot;</span><span class=""> </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">finfun_def</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">blast</span><span class="">
</span><span class="">  
</span><span class="">  </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;snd ` {ab. f ab &#8800; c} = {b. &#8707;a. f (a, b) &#8800; c}&quot;</span><span class=""> </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">force</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">hence</span><span class=""> </span><span class="string">&quot;{b. f (a, b) &#8800; c} &#8838; snd ` {ab. f ab &#8800; c}&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">  </span><span class="keyword1">hence</span><span class=""> </span><span class="string">&quot;finite {b. f (a, b) &#8800; c}&quot;</span><span class=""> </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">finite_subset</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">finite_imageI</span><span class="delimiter">[</span><span class="">OF</span><span class=""> </span><span class="">c</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword3">thus</span><span class=""> </span><span class="string">&quot;curry f a &#8712; finfun&quot;</span><span class=""> </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">finfun_def</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="keyword1">bundle</span><span class=""> </span><span class="">finfun</span><span class=""> </span><span class="delimiter">=</span><span class="">
</span><span class="">  </span><span class="">fst_finfun</span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class=""> </span><span class="">snd_finfun</span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class=""> </span><span class="">Abs_finfun_inverse</span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class=""> 
</span><span class="">  </span><span class="">finfun_apply_inverse</span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class=""> </span><span class="">Abs_finfun_inject</span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class=""> </span><span class="">finfun_apply_inject</span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="">
</span><span class="">  </span><span class="">Diag_finfun</span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class=""> </span><span class="">finfun_curry</span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="">
</span><span class="">  </span><span class="">const_finfun</span><span class="delimiter">[</span><span class="">iff</span><span class="delimiter">]</span><span class=""> </span><span class="">fun_upd_finfun</span><span class="delimiter">[</span><span class="">iff</span><span class="delimiter">]</span><span class=""> </span><span class="">finfun_apply</span><span class="delimiter">[</span><span class="">iff</span><span class="delimiter">]</span><span class=""> </span><span class="">map_of_finfun</span><span class="delimiter">[</span><span class="">iff</span><span class="delimiter">]</span><span class="">
</span><span class="">  </span><span class="">finfun_left_compose</span><span class="delimiter">[</span><span class="">intro</span><span class="delimiter">]</span><span class=""> </span><span class="">fst_finfun</span><span class="delimiter">[</span><span class="">intro</span><span class="delimiter">]</span><span class=""> </span><span class="">snd_finfun</span><span class="delimiter">[</span><span class="">intro</span><span class="delimiter">]</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">Abs_finfun_inject_finite</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">fixes</span><span class=""> </span><span class="">x</span><span class=""> </span><span class="">y</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;&#39;a &#8658; &#39;b&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="">fin</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;finite (UNIV :: &#39;a set)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;Abs_finfun x = Abs_finfun y &#10231; x = y&quot;</span><span class="">
</span><span class="keyword1">proof</span><span class="">
</span><span class="">  </span><span class="keyword3">assume</span><span class=""> </span><span class="string">&quot;Abs_finfun x = Abs_finfun y&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">moreover</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;x &#8712; finfun&quot;</span><span class=""> </span><span class="string">&quot;y &#8712; finfun&quot;</span><span class=""> </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">finfun_def</span><span class="">
</span><span class="">    </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">intro</span><span class="delimiter">:</span><span class=""> </span><span class="">finite_subset</span><span class="delimiter">[</span><span class="">OF</span><span class=""> </span><span class="">_</span><span class=""> </span><span class="">fin</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">ultimately</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;x = y&quot;</span><span class=""> </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">Abs_finfun_inject</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1">qed</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">Abs_finfun_inject_finite_class</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">fixes</span><span class=""> </span><span class="">x</span><span class=""> </span><span class="">y</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;(&#39;a :: finite) &#8658; &#39;b&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;Abs_finfun x = Abs_finfun y &#10231; x = y&quot;</span><span class="">
</span><span class="keyword1">using</span><span class=""> </span><span class="">finite_UNIV</span><span class="">
</span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">Abs_finfun_inject_finite</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">Abs_finfun_inj_finite</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="">fin</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;finite (UNIV :: &#39;a set)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;inj (Abs_finfun :: (&#39;a &#8658; &#39;b) &#8658; &#39;a &#8658;f &#39;b)&quot;</span><span class="">
</span><span class="keyword1">proof</span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">inj_onI</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword3">fix</span><span class=""> </span><span class="">x</span><span class=""> </span><span class="">y</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;&#39;a &#8658; &#39;b&quot;</span><span class="">
</span><span class="">  </span><span class="keyword3">assume</span><span class=""> </span><span class="string">&quot;Abs_finfun x = Abs_finfun y&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">moreover</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;x &#8712; finfun&quot;</span><span class=""> </span><span class="string">&quot;y &#8712; finfun&quot;</span><span class=""> </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">finfun_def</span><span class="">
</span><span class="">    </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">intro</span><span class="delimiter">:</span><span class=""> </span><span class="">finite_subset</span><span class="delimiter">[</span><span class="">OF</span><span class=""> </span><span class="">_</span><span class=""> </span><span class="">fin</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">ultimately</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;x = y&quot;</span><span class=""> </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">Abs_finfun_inject</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">Abs_finfun_inverse_finite</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">fixes</span><span class=""> </span><span class="">x</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;&#39;a &#8658; &#39;b&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="">fin</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;finite (UNIV :: &#39;a set)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;finfun_apply (Abs_finfun x) = x&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">including</span><span class=""> </span><span class="">finfun</span><span class="">
</span><span class="keyword1">proof</span><span class=""> </span><span class="">-</span><span class="">
</span><span class="">  </span><span class="keyword1">from</span><span class=""> </span><span class="">fin</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;x &#8712; finfun&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_def</span><span class=""> </span><span class="">intro</span><span class="delimiter">:</span><span class=""> </span><span class="">finite_subset</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword3">thus</span><span class=""> </span><span class="var">?thesis</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">Abs_finfun_inverse_finite_class</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">fixes</span><span class=""> </span><span class="">x</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;(&#39;a :: finite) &#8658; &#39;b&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;finfun_apply (Abs_finfun x) = x&quot;</span><span class="">
</span><span class="keyword1">using</span><span class=""> </span><span class="">finite_UNIV</span><span class=""> </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">Abs_finfun_inverse_finite</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">finfun_eq_finite_UNIV</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;finite (UNIV :: &#39;a set) &#10233; (finfun :: (&#39;a &#8658; &#39;b) set) = UNIV&quot;</span><span class="">
</span><span class="keyword1">unfolding</span><span class=""> </span><span class="">finfun_def</span><span class=""> </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">intro</span><span class="delimiter">:</span><span class=""> </span><span class="">finite_subset</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">finfun_finite_UNIV_class</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;finfun = (UNIV :: (&#39;a :: finite &#8658; &#39;b) set)&quot;</span><span class="">
</span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_eq_finite_UNIV</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">map_default_in_finfun</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="">fin</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;finite (dom f)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;map_default b f &#8712; finfun&quot;</span><span class="">
</span><span class="keyword1">unfolding</span><span class=""> </span><span class="">finfun_def</span><span class="">
</span><span class="keyword1">proof</span><span class="delimiter">(</span><span class="">intro</span><span class=""> </span><span class="">CollectI</span><span class=""> </span><span class="">exI</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">from</span><span class=""> </span><span class="">fin</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;finite {a. map_default b f a &#8800; b}&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">map_default_def</span><span class=""> </span><span class="">dom_def</span><span class=""> </span><span class="">Collect_conj_eq</span><span class=""> </span><span class="">split</span><span class="delimiter">:</span><span class=""> </span><span class="">option.splits</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">finfun_cases_map_default</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">obtains</span><span class=""> </span><span class="">b</span><span class=""> </span><span class="">g</span><span class=""> </span><span class="keyword2">where</span><span class=""> </span><span class="string">&quot;f = Abs_finfun (map_default b g)&quot;</span><span class=""> </span><span class="string">&quot;finite (dom g)&quot;</span><span class=""> </span><span class="string">&quot;b &#8713; ran g&quot;</span><span class="">
</span><span class="keyword1">proof</span><span class=""> </span><span class="">-</span><span class="">
</span><span class="">  </span><span class="keyword3">obtain</span><span class=""> </span><span class="">y</span><span class=""> </span><span class="keyword2">where</span><span class=""> </span><span class="">f</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;f = Abs_finfun y&quot;</span><span class=""> </span><span class="keyword2">and</span><span class=""> </span><span class="">y</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;y &#8712; finfun&quot;</span><span class=""> </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">cases</span><span class=""> </span><span class="">f</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">from</span><span class=""> </span><span class="">y</span><span class=""> </span><span class="keyword3">obtain</span><span class=""> </span><span class="">b</span><span class=""> </span><span class="keyword2">where</span><span class=""> </span><span class="">b</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;finite {a. y a &#8800; b}&quot;</span><span class=""> </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">finfun_def</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">  </span><span class="keyword1">let</span><span class=""> </span><span class="var">?g</span><span class=""> </span><span class="delimiter">=</span><span class=""> </span><span class="string">&quot;(&#955;a. if y a = b then None else Some (y a))&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;map_default b ?g = y&quot;</span><span class=""> </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">fun_eq_iff</span><span class=""> </span><span class="">map_default_def</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">with</span><span class=""> </span><span class="">f</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;f = Abs_finfun (map_default b ?g)&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">  </span><span class="keyword1">moreover</span><span class=""> </span><span class="keyword1">from</span><span class=""> </span><span class="">b</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;finite (dom ?g)&quot;</span><span class=""> </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">dom_def</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">moreover</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;b &#8713; ran ?g&quot;</span><span class=""> </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">ran_def</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">ultimately</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="var">?thesis</span><span class=""> </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">that</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="">
</span><span class="keyword1">subsection</span><span class=""> </span><span class="cartouche">&#8249;Kernel functions for type @{typ &quot;&#39;a &#8658;f &#39;b&quot;}&#8250;</span><span class="">
</span><span class="">
</span><span class="keyword1">lift_definition</span><span class=""> </span><span class="">finfun_const</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;&#39;b &#8658; &#39;a &#8658;f &#39;b&quot;</span><span class=""> </span><span class="delimiter">(</span><span class="string">&quot;K$/ _&quot;</span><span class=""> </span><span class="delimiter">[</span><span class="">0</span><span class="delimiter">]</span><span class=""> </span><span class="">1</span><span class="delimiter">)</span><span class="">
</span><span class="keyword2">is</span><span class=""> </span><span class="string">&quot;&#955; b x. b&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">const_finfun</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lift_definition</span><span class=""> </span><span class="">finfun_update</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;&#39;a &#8658;f &#39;b &#8658; &#39;a &#8658; &#39;b &#8658; &#39;a &#8658;f &#39;b&quot;</span><span class=""> </span><span class="delimiter">(</span><span class="string">&quot;_&#39;(_ $:= _&#39;)&quot;</span><span class=""> </span><span class="delimiter">[</span><span class="">1000</span><span class="delimiter">,</span><span class="">0</span><span class="delimiter">,</span><span class="">0</span><span class="delimiter">]</span><span class=""> </span><span class="">1000</span><span class="delimiter">)</span><span class=""> </span><span class="keyword2">is</span><span class=""> </span><span class="string">&quot;fun_upd&quot;</span><span class="">
</span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">fun_upd_finfun</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">finfun_update_twist</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;a &#8800; a&#39; &#10233; f(a $:= b)(a&#39; $:= b&#39;) = f(a&#39; $:= b&#39;)(a $:= b)&quot;</span><span class="">
</span><span class="keyword1">by</span><span class=""> </span><span class="">transfer</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">fun_upd_twist</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">finfun_update_twice</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="string">&quot;f(a $:= b)(a $:= b&#39;) = f(a $:= b&#39;)&quot;</span><span class="">
</span><span class="keyword1">by</span><span class=""> </span><span class="">transfer</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">finfun_update_const_same</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;(K$ b)(a $:= b) = (K$ b)&quot;</span><span class="">
</span><span class="keyword1">by</span><span class=""> </span><span class="">transfer</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">fun_eq_iff</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">subsection</span><span class=""> </span><span class="cartouche">&#8249;Code generator setup&#8250;</span><span class="">
</span><span class="">
</span><span class="keyword1">definition</span><span class=""> </span><span class="">finfun_update_code</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;&#39;a &#8658;f &#39;b &#8658; &#39;a &#8658; &#39;b &#8658; &#39;a &#8658;f &#39;b&quot;</span><span class="">
</span><span class="keyword2">where</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">,</span><span class=""> </span><span class="">code</span><span class=""> </span><span class="">del</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;finfun_update_code = finfun_update&quot;</span><span class="">
</span><span class="">
</span><span class="keyword1">code_datatype</span><span class=""> </span><span class="">finfun_const</span><span class=""> </span><span class="">finfun_update_code</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">finfun_update_const_code</span><span class=""> </span><span class="delimiter">[</span><span class="">code</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="string">&quot;(K$ b)(a $:= b&#39;) = (if b = b&#39; then (K$ b) else finfun_update_code (K$ b) a b&#39;)&quot;</span><span class="">
</span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_update_const_same</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">finfun_update_update_code</span><span class=""> </span><span class="delimiter">[</span><span class="">code</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="string">&quot;(finfun_update_code f a b)(a&#39; $:= b&#39;) = (if a = a&#39; then f(a $:= b&#39;) else finfun_update_code (f(a&#39; $:= b&#39;)) a b)&quot;</span><span class="">
</span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_update_twist</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="">
</span><span class="keyword1">subsection</span><span class=""> </span><span class="cartouche">&#8249;Setup for quickcheck&#8250;</span><span class="">
</span><span class="">
</span><span class="keyword1">quickcheck_generator</span><span class=""> </span><span class="">finfun</span><span class=""> </span><span class="">constructors</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_update_code</span><span class="delimiter">,</span><span class=""> </span><span class="string">&quot;finfun_const :: &#39;b &#8658; &#39;a &#8658;f &#39;b&quot;</span><span class="">
</span><span class="">
</span><span class="keyword1">subsection</span><span class=""> </span><span class="cartouche">&#8249;&#8249;finfun_update&#8250; as instance of &#8249;comp_fun_commute&#8250;&#8250;</span><span class="">
</span><span class="">
</span><span class="keyword1">interpretation</span><span class=""> </span><span class="">finfun_update</span><span class="delimiter">:</span><span class=""> </span><span class="">comp_fun_commute</span><span class=""> </span><span class="string">&quot;&#955;a f. f(a :: &#39;a $:= b&#39;)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">including</span><span class=""> </span><span class="">finfun</span><span class="">
</span><span class="keyword1">proof</span><span class="">
</span><span class="">  </span><span class="keyword3">fix</span><span class=""> </span><span class="">a</span><span class=""> </span><span class="">a&#39;</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="tfree">&#39;a</span><span class="">
</span><span class="">  </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;(&#955;f. f(a $:= b&#39;)) &#8728; (&#955;f. f(a&#39; $:= b&#39;)) = (&#955;f. f(a&#39; $:= b&#39;)) &#8728; (&#955;f. f(a $:= b&#39;))&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">proof</span><span class="">
</span><span class="">    </span><span class="keyword3">fix</span><span class=""> </span><span class="">b</span><span class="">
</span><span class="">    </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;(finfun_apply b)(a := b&#39;, a&#39; := b&#39;) = (finfun_apply b)(a&#39; := b&#39;, a := b&#39;)&quot;</span><span class="">
</span><span class="">      </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">cases</span><span class=""> </span><span class="string">&quot;a = a&#39;&quot;</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">fun_upd_twist</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1">then</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;b(a $:= b&#39;)(a&#39; $:= b&#39;) = b(a&#39; $:= b&#39;)(a $:= b&#39;)&quot;</span><span class="">
</span><span class="">      </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_update_def</span><span class=""> </span><span class="">fun_upd_twist</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1">then</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;((&#955;f. f(a $:= b&#39;)) &#8728; (&#955;f. f(a&#39; $:= b&#39;))) b = ((&#955;f. f(a&#39; $:= b&#39;)) &#8728; (&#955;f. f(a $:= b&#39;))) b&quot;</span><span class="">
</span><span class="">      </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">fun_eq_iff</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">qed</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">fold_finfun_update_finite_univ</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="">fin</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;finite (UNIV :: &#39;a set)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;Finite_Set.fold (&#955;a f. f(a $:= b&#39;)) (K$ b) (UNIV :: &#39;a set) = (K$ b&#39;)&quot;</span><span class="">
</span><span class="keyword1">proof</span><span class=""> </span><span class="">-</span><span class="">
</span><span class="">  </span><span class="keyword1">{</span><span class=""> </span><span class="keyword3">fix</span><span class=""> </span><span class="">A</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;&#39;a set&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">from</span><span class=""> </span><span class="">fin</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;finite A&quot;</span><span class=""> </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">intro</span><span class="delimiter">:</span><span class=""> </span><span class="">finite_subset</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1">hence</span><span class=""> </span><span class="string">&quot;Finite_Set.fold (&#955;a f. f(a $:= b&#39;)) (K$ b) A = Abs_finfun (&#955;a. if a &#8712; A then b&#39; else b)&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">proof</span><span class="delimiter">(</span><span class="">induct</span><span class="delimiter">)</span><span class="">
</span><span class="">      </span><span class="keyword3">case</span><span class=""> </span><span class="delimiter">(</span><span class="">insert</span><span class=""> </span><span class="">x</span><span class=""> </span><span class="">F</span><span class="delimiter">)</span><span class="">
</span><span class="">      </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;(&#955;a. if a = x then b&#39; else (if a &#8712; F then b&#39; else b)) = (&#955;a. if a = x &#8744; a &#8712; F then b&#39; else b)&quot;</span><span class="">
</span><span class="">        </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">auto</span><span class="delimiter">)</span><span class="">
</span><span class="">      </span><span class="keyword1">with</span><span class=""> </span><span class="">insert</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="var">?case</span><span class="">
</span><span class="">        </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_const_def</span><span class=""> </span><span class="">fun_upd_def</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_update_def</span><span class=""> </span><span class="">Abs_finfun_inverse_finite</span><span class="delimiter">[</span><span class="">OF</span><span class=""> </span><span class="">fin</span><span class="delimiter">]</span><span class=""> </span><span class="">fun_upd_def</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1">qed</span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_const_def</span><span class="delimiter">)</span><span class=""> </span><span class="keyword1">}</span><span class="">
</span><span class="">  </span><span class="keyword3">thus</span><span class=""> </span><span class="var">?thesis</span><span class=""> </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_const_def</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="">
</span><span class="keyword1">subsection</span><span class=""> </span><span class="cartouche">&#8249;Default value for FinFuns&#8250;</span><span class="">
</span><span class="">
</span><span class="keyword1">definition</span><span class=""> </span><span class="">finfun_default_aux</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;(&#39;a &#8658; &#39;b) &#8658; &#39;b&quot;</span><span class="">
</span><span class="keyword2">where</span><span class=""> </span><span class="delimiter">[</span><span class="">code</span><span class=""> </span><span class="">del</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;finfun_default_aux f = (if finite (UNIV :: &#39;a set) then undefined else THE b. finite {a. f a &#8800; b})&quot;</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">finfun_default_aux_infinite</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">fixes</span><span class=""> </span><span class="">f</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;&#39;a &#8658; &#39;b&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="">infin</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;&#172; finite (UNIV :: &#39;a set)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">and</span><span class=""> </span><span class="">fin</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;finite {a. f a &#8800; b}&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;finfun_default_aux f = b&quot;</span><span class="">
</span><span class="keyword1">proof</span><span class=""> </span><span class="">-</span><span class="">
</span><span class="">  </span><span class="keyword1">let</span><span class=""> </span><span class="var">?B</span><span class=""> </span><span class="delimiter">=</span><span class=""> </span><span class="string">&quot;{a. f a &#8800; b}&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">from</span><span class=""> </span><span class="">fin</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;(THE b. finite {a. f a &#8800; b}) = b&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">proof</span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">the_equality</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword3">fix</span><span class=""> </span><span class="">b&#39;</span><span class="">
</span><span class="">    </span><span class="keyword3">assume</span><span class=""> </span><span class="string">&quot;finite {a. f a &#8800; b&#39;}&quot;</span><span class=""> </span><span class="delimiter">(</span><span class="keyword2">is</span><span class=""> </span><span class="string">&quot;finite ?B&#39;&quot;</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1">with</span><span class=""> </span><span class="">infin</span><span class=""> </span><span class="">fin</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;UNIV - (?B&#39; &#8746; ?B) &#8800; {}&quot;</span><span class=""> </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">dest</span><span class="delimiter">:</span><span class=""> </span><span class="">finite_subset</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1">then</span><span class=""> </span><span class="keyword3">obtain</span><span class=""> </span><span class="">a</span><span class=""> </span><span class="keyword2">where</span><span class=""> </span><span class="">a</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;a &#8713; ?B&#39; &#8746; ?B&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">    </span><span class="keyword3">thus</span><span class=""> </span><span class="string">&quot;b&#39; = b&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">  </span><span class="keyword1">qed</span><span class="">
</span><span class="">  </span><span class="keyword3">thus</span><span class=""> </span><span class="var">?thesis</span><span class=""> </span><span class="keyword1">using</span><span class=""> </span><span class="">infin</span><span class=""> </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_default_aux_def</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">finite_finfun_default_aux</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">fixes</span><span class=""> </span><span class="">f</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;&#39;a &#8658; &#39;b&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="">fin</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;f &#8712; finfun&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;finite {a. f a &#8800; finfun_default_aux f}&quot;</span><span class="">
</span><span class="keyword1">proof</span><span class="delimiter">(</span><span class="">cases</span><span class=""> </span><span class="string">&quot;finite (UNIV :: &#39;a set)&quot;</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword3">case</span><span class=""> </span><span class="">True</span><span class=""> </span><span class="keyword3">thus</span><span class=""> </span><span class="var">?thesis</span><span class=""> </span><span class="keyword1">using</span><span class=""> </span><span class="">fin</span><span class="">
</span><span class="">    </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_def</span><span class=""> </span><span class="">finfun_default_aux_def</span><span class=""> </span><span class="">intro</span><span class="delimiter">:</span><span class=""> </span><span class="">finite_subset</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1">next</span><span class="">
</span><span class="">  </span><span class="keyword3">case</span><span class=""> </span><span class="">False</span><span class="">
</span><span class="">  </span><span class="keyword1">from</span><span class=""> </span><span class="">fin</span><span class=""> </span><span class="keyword3">obtain</span><span class=""> </span><span class="">b</span><span class=""> </span><span class="keyword2">where</span><span class=""> </span><span class="">b</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;finite {a. f a &#8800; b}&quot;</span><span class=""> </span><span class="delimiter">(</span><span class="keyword2">is</span><span class=""> </span><span class="string">&quot;finite ?B&quot;</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">finfun_def</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">blast</span><span class="">
</span><span class="">  </span><span class="keyword1">with</span><span class=""> </span><span class="">False</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="var">?thesis</span><span class=""> </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_default_aux_infinite</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">finfun_default_aux_update_const</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">fixes</span><span class=""> </span><span class="">f</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;&#39;a &#8658; &#39;b&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="">fin</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;f &#8712; finfun&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;finfun_default_aux (f(a := b)) = finfun_default_aux f&quot;</span><span class="">
</span><span class="keyword1">proof</span><span class="delimiter">(</span><span class="">cases</span><span class=""> </span><span class="string">&quot;finite (UNIV :: &#39;a set)&quot;</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword3">case</span><span class=""> </span><span class="">False</span><span class="">
</span><span class="">  </span><span class="keyword1">from</span><span class=""> </span><span class="">fin</span><span class=""> </span><span class="keyword3">obtain</span><span class=""> </span><span class="">b&#39;</span><span class=""> </span><span class="keyword2">where</span><span class=""> </span><span class="">b&#39;</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;finite {a. f a &#8800; b&#39;}&quot;</span><span class=""> </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">finfun_def</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">blast</span><span class="">
</span><span class="">  </span><span class="keyword1">hence</span><span class=""> </span><span class="string">&quot;finite {a&#39;. (f(a := b)) a&#39; &#8800; b&#39;}&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">proof</span><span class="delimiter">(</span><span class="">cases</span><span class=""> </span><span class="string">&quot;b = b&#39; &#8743; f a &#8800; b&#39;&quot;</span><span class="delimiter">)</span><span class=""> 
</span><span class="">    </span><span class="keyword3">case</span><span class=""> </span><span class="">True</span><span class="">
</span><span class="">    </span><span class="keyword1">hence</span><span class=""> </span><span class="string">&quot;{a. f a &#8800; b&#39;} = insert a {a&#39;. (f(a := b)) a&#39; &#8800; b&#39;}&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">    </span><span class="keyword3">thus</span><span class=""> </span><span class="var">?thesis</span><span class=""> </span><span class="keyword1">using</span><span class=""> </span><span class="">b&#39;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">  </span><span class="keyword1">next</span><span class="">
</span><span class="">    </span><span class="keyword3">case</span><span class=""> </span><span class="">False</span><span class="">
</span><span class="">    </span><span class="keyword1">moreover</span><span class="">
</span><span class="">    </span><span class="keyword1">{</span><span class=""> </span><span class="keyword3">assume</span><span class=""> </span><span class="string">&quot;b &#8800; b&#39;&quot;</span><span class="">
</span><span class="">      </span><span class="keyword1">hence</span><span class=""> </span><span class="string">&quot;{a&#39;. (f(a := b)) a&#39; &#8800; b&#39;} = insert a {a. f a &#8800; b&#39;}&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">      </span><span class="keyword1">hence</span><span class=""> </span><span class="var">?thesis</span><span class=""> </span><span class="keyword1">using</span><span class=""> </span><span class="">b&#39;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="keyword1">}</span><span class="">
</span><span class="">    </span><span class="keyword1">moreover</span><span class="">
</span><span class="">    </span><span class="keyword1">{</span><span class=""> </span><span class="keyword3">assume</span><span class=""> </span><span class="string">&quot;b = b&#39;&quot;</span><span class=""> </span><span class="string">&quot;f a = b&#39;&quot;</span><span class="">
</span><span class="">      </span><span class="keyword1">hence</span><span class=""> </span><span class="string">&quot;{a&#39;. (f(a := b)) a&#39; &#8800; b&#39;} = {a. f a &#8800; b&#39;}&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">      </span><span class="keyword1">hence</span><span class=""> </span><span class="var">?thesis</span><span class=""> </span><span class="keyword1">using</span><span class=""> </span><span class="">b&#39;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="keyword1">}</span><span class="">
</span><span class="">    </span><span class="keyword1">ultimately</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="var">?thesis</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">blast</span><span class="">
</span><span class="">  </span><span class="keyword1">qed</span><span class="">
</span><span class="">  </span><span class="keyword1">with</span><span class=""> </span><span class="">False</span><span class=""> </span><span class="">b&#39;</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="var">?thesis</span><span class=""> </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">del</span><span class="delimiter">:</span><span class=""> </span><span class="">fun_upd_apply</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_default_aux_infinite</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1">next</span><span class="">
</span><span class="">  </span><span class="keyword3">case</span><span class=""> </span><span class="">True</span><span class=""> </span><span class="keyword3">thus</span><span class=""> </span><span class="var">?thesis</span><span class=""> </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_default_aux_def</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="keyword1">lift_definition</span><span class=""> </span><span class="">finfun_default</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;&#39;a &#8658;f &#39;b &#8658; &#39;b&quot;</span><span class="">
</span><span class="keyword2">is</span><span class=""> </span><span class="string">&quot;finfun_default_aux&quot;</span><span class=""> </span><span class="keyword1">.</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">finite_finfun_default</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;finite {a. finfun_apply f a &#8800; finfun_default f}&quot;</span><span class="">
</span><span class="keyword1">by</span><span class=""> </span><span class="">transfer</span><span class=""> </span><span class="delimiter">(</span><span class="">erule</span><span class=""> </span><span class="">finite_finfun_default_aux</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">finfun_default_const</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;finfun_default ((K$ b) :: &#39;a &#8658;f &#39;b) = (if finite (UNIV :: &#39;a set) then undefined else b)&quot;</span><span class="">
</span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">transfer</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_default_aux_infinite</span><span class=""> </span><span class="">finfun_default_aux_def</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">finfun_default_update_const</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="string">&quot;finfun_default (f(a $:= b)) = finfun_default f&quot;</span><span class="">
</span><span class="keyword1">by</span><span class=""> </span><span class="">transfer</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_default_aux_update_const</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">finfun_default_const_code</span><span class=""> </span><span class="delimiter">[</span><span class="">code</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="string">&quot;finfun_default ((K$ c) :: &#39;a :: card_UNIV &#8658;f &#39;b) = (if CARD(&#39;a) = 0 then c else undefined)&quot;</span><span class="">
</span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_default_const</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">finfun_default_update_code</span><span class=""> </span><span class="delimiter">[</span><span class="">code</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="string">&quot;finfun_default (finfun_update_code f a b) = finfun_default f&quot;</span><span class="">
</span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_default_update_const</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">subsection</span><span class=""> </span><span class="cartouche">&#8249;Recursion combinator and well-formedness conditions&#8250;</span><span class="">
</span><span class="">
</span><span class="keyword1">definition</span><span class=""> </span><span class="">finfun_rec</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;(&#39;b &#8658; &#39;c) &#8658; (&#39;a &#8658; &#39;b &#8658; &#39;c &#8658; &#39;c) &#8658; (&#39;a &#8658;f &#39;b) &#8658; &#39;c&quot;</span><span class="">
</span><span class="keyword2">where</span><span class=""> </span><span class="delimiter">[</span><span class="">code</span><span class=""> </span><span class="">del</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="string">&quot;finfun_rec cnst upd f &#8801;
   let b = finfun_default f;
       g = THE g. f = Abs_finfun (map_default b g) &#8743; finite (dom g) &#8743; b &#8713; ran g
   in Finite_Set.fold (&#955;a. upd a (map_default b g a)) (cnst b) (dom g)&quot;</span><span class="">
</span><span class="">
</span><span class="keyword1">locale</span><span class=""> </span><span class="">finfun_rec_wf_aux</span><span class=""> </span><span class="delimiter">=</span><span class="">
</span><span class="">  </span><span class="keyword2">fixes</span><span class=""> </span><span class="">cnst</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;&#39;b &#8658; &#39;c&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">and</span><span class=""> </span><span class="">upd</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;&#39;a &#8658; &#39;b &#8658; &#39;c &#8658; &#39;c&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="">upd_const_same</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;upd a b (cnst b) = cnst b&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">and</span><span class=""> </span><span class="">upd_commute</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;a &#8800; a&#39; &#10233; upd a b (upd a&#39; b&#39; c) = upd a&#39; b&#39; (upd a b c)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">and</span><span class=""> </span><span class="">upd_idemp</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;b &#8800; b&#39; &#10233; upd a b&#39;&#39; (upd a b&#39; (cnst b)) = upd a b&#39;&#39; (cnst b)&quot;</span><span class="">
</span><span class="keyword2">begin</span><span class="">
</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">upd_left_comm</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;comp_fun_commute (&#955;a. upd a (f a))&quot;</span><span class="">
</span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">unfold_locales</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">intro</span><span class="delimiter">:</span><span class=""> </span><span class="">upd_commute</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">fun_eq_iff</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">upd_upd_twice</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;upd a b&#39;&#39; (upd a b&#39; (cnst b)) = upd a b&#39;&#39; (cnst b)&quot;</span><span class="">
</span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">cases</span><span class=""> </span><span class="string">&quot;b &#8800; b&#39;&quot;</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">fun_upd_def</span><span class=""> </span><span class="">upd_const_same</span><span class=""> </span><span class="">upd_idemp</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">map_default_update_const</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="">fin</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;finite (dom f)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">and</span><span class=""> </span><span class="">anf</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;a &#8713; dom f&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">and</span><span class=""> </span><span class="">fg</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;f &#8838;<span class="hidden">&#8681;</span><sub>m</sub> g&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;upd a d  (Finite_Set.fold (&#955;a. upd a (map_default d g a)) (cnst d) (dom f)) =
         Finite_Set.fold (&#955;a. upd a (map_default d g a)) (cnst d) (dom f)&quot;</span><span class="">
</span><span class="keyword1">proof</span><span class=""> </span><span class="">-</span><span class="">
</span><span class="">  </span><span class="keyword1">let</span><span class=""> </span><span class="var">?upd</span><span class=""> </span><span class="delimiter">=</span><span class=""> </span><span class="string">&quot;&#955;a. upd a (map_default d g a)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">let</span><span class=""> </span><span class="var">?fr</span><span class=""> </span><span class="delimiter">=</span><span class=""> </span><span class="string">&quot;&#955;A. Finite_Set.fold ?upd (cnst d) A&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">interpret</span><span class=""> </span><span class="">gwf</span><span class="delimiter">:</span><span class=""> </span><span class="">comp_fun_commute</span><span class=""> </span><span class="string">&quot;?upd&quot;</span><span class=""> </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">upd_left_comm</span><span class="delimiter">)</span><span class="">
</span><span class="">  
</span><span class="">  </span><span class="keyword1">from</span><span class=""> </span><span class="">fin</span><span class=""> </span><span class="">anf</span><span class=""> </span><span class="">fg</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="var">?thesis</span><span class="">
</span><span class="">  </span><span class="keyword1">proof</span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="string">&quot;dom f&quot;</span><span class=""> </span><span class="">arbitrary</span><span class="delimiter">:</span><span class=""> </span><span class="">f</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword3">case</span><span class=""> </span><span class="">empty</span><span class="">
</span><span class="">    </span><span class="keyword1">from</span><span class=""> </span><span class="cartouche">&#8249;{} = dom f&#8250;</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;f = empty&quot;</span><span class=""> </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">dom_def</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword3">thus</span><span class=""> </span><span class="var">?case</span><span class=""> </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_const_def</span><span class=""> </span><span class="">upd_const_same</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">next</span><span class="">
</span><span class="">    </span><span class="keyword3">case</span><span class=""> </span><span class="delimiter">(</span><span class="">insert</span><span class=""> </span><span class="">a&#39;</span><span class=""> </span><span class="">A</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1">note</span><span class=""> </span><span class="">IH</span><span class=""> </span><span class="delimiter">=</span><span class=""> </span><span class="cartouche">&#8249;&#8896;f.  &#10214; A = dom f; a &#8713; dom f; f &#8838;<span class="hidden">&#8681;</span><sub>m</sub> g &#10215; &#10233; upd a d (?fr (dom f)) = ?fr (dom f)&#8250;</span><span class="">
</span><span class="">    </span><span class="keyword1">note</span><span class=""> </span><span class="">fin</span><span class=""> </span><span class="delimiter">=</span><span class=""> </span><span class="cartouche">&#8249;finite A&#8250;</span><span class=""> </span><span class="keyword1">note</span><span class=""> </span><span class="">anf</span><span class=""> </span><span class="delimiter">=</span><span class=""> </span><span class="cartouche">&#8249;a &#8713; dom f&#8250;</span><span class=""> </span><span class="keyword1">note</span><span class=""> </span><span class="">a&#39;nA</span><span class=""> </span><span class="delimiter">=</span><span class=""> </span><span class="cartouche">&#8249;a&#39; &#8713; A&#8250;</span><span class="">
</span><span class="">    </span><span class="keyword1">note</span><span class=""> </span><span class="">domf</span><span class=""> </span><span class="delimiter">=</span><span class=""> </span><span class="cartouche">&#8249;insert a&#39; A = dom f&#8250;</span><span class=""> </span><span class="keyword1">note</span><span class=""> </span><span class="">fg</span><span class=""> </span><span class="delimiter">=</span><span class=""> </span><span class="cartouche">&#8249;f &#8838;<span class="hidden">&#8681;</span><sub>m</sub> g&#8250;</span><span class="">
</span><span class="">    
</span><span class="">    </span><span class="keyword1">from</span><span class=""> </span><span class="">domf</span><span class=""> </span><span class="keyword3">obtain</span><span class=""> </span><span class="">b</span><span class=""> </span><span class="keyword2">where</span><span class=""> </span><span class="">b</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;f a&#39; = Some b&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">    </span><span class="keyword1">let</span><span class=""> </span><span class="var">?f&#39;</span><span class=""> </span><span class="delimiter">=</span><span class=""> </span><span class="string">&quot;f(a&#39; := None)&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;upd a d (?fr (insert a&#39; A)) = upd a d (upd a&#39; (map_default d g a&#39;) (?fr A))&quot;</span><span class="">
</span><span class="">      </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">subst</span><span class=""> </span><span class="">gwf.fold_insert</span><span class="delimiter">[</span><span class="">OF</span><span class=""> </span><span class="">fin</span><span class=""> </span><span class="">a&#39;nA</span><span class="delimiter">]</span><span class="delimiter">)</span><span class=""> </span><span class="">rule</span><span class="">
</span><span class="">    </span><span class="keyword1">also</span><span class=""> </span><span class="keyword1">from</span><span class=""> </span><span class="">b</span><span class=""> </span><span class="">fg</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;g a&#39; = f a&#39;&quot;</span><span class=""> </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">map_le_def</span><span class=""> </span><span class="">intro</span><span class="delimiter">:</span><span class=""> </span><span class="">domI</span><span class=""> </span><span class="">dest</span><span class="delimiter">:</span><span class=""> </span><span class="">bspec</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1">hence</span><span class=""> </span><span class="">ga&#39;</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;map_default d g a&#39; = map_default d f a&#39;&quot;</span><span class=""> </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">map_default_def</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1">also</span><span class=""> </span><span class="keyword1">from</span><span class=""> </span><span class="">anf</span><span class=""> </span><span class="">domf</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;a &#8800; a&#39;&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class=""> </span><span class="keyword1">note</span><span class=""> </span><span class="">upd_commute</span><span class="delimiter">[</span><span class="">OF</span><span class=""> </span><span class="">this</span><span class="delimiter">]</span><span class="">
</span><span class="">    </span><span class="keyword1">also</span><span class=""> </span><span class="keyword1">from</span><span class=""> </span><span class="">domf</span><span class=""> </span><span class="">a&#39;nA</span><span class=""> </span><span class="">anf</span><span class=""> </span><span class="">fg</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;a &#8713; dom ?f&#39;&quot;</span><span class=""> </span><span class="string">&quot;?f&#39; &#8838;<span class="hidden">&#8681;</span><sub>m</sub> g&quot;</span><span class=""> </span><span class="keyword2">and</span><span class=""> </span><span class="">A</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;A = dom ?f&#39;&quot;</span><span class=""> </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">ran_def</span><span class=""> </span><span class="">map_le_def</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1">note</span><span class=""> </span><span class="">A</span><span class=""> </span><span class="keyword1">also</span><span class=""> </span><span class="keyword1">note</span><span class=""> </span><span class="">IH</span><span class="delimiter">[</span><span class="">OF</span><span class=""> </span><span class="">A</span><span class=""> </span><span class="cartouche">&#8249;a &#8713; dom ?f&#39;&#8250;</span><span class=""> </span><span class="cartouche">&#8249;?f&#39; &#8838;<span class="hidden">&#8681;</span><sub>m</sub> g&#8250;</span><span class="delimiter">]</span><span class="">
</span><span class="">    </span><span class="keyword1">also</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;upd a&#39; (map_default d f a&#39;) (?fr (dom (f(a&#39; := None)))) = ?fr (dom f)&quot;</span><span class="">
</span><span class="">      </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">domf</span><span class="delimiter">[</span><span class="">symmetric</span><span class="delimiter">]</span><span class=""> </span><span class="">gwf.fold_insert</span><span class="delimiter">[</span><span class="">OF</span><span class=""> </span><span class="">fin</span><span class=""> </span><span class="">a&#39;nA</span><span class="delimiter">]</span><span class=""> </span><span class="">ga&#39;</span><span class=""> </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">A</span><span class=""> </span><span class="keyword1">..</span><span class="">
</span><span class="">    </span><span class="keyword1">also</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;insert a&#39; (dom ?f&#39;) = dom f&quot;</span><span class=""> </span><span class="keyword1">using</span><span class=""> </span><span class="">domf</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">    </span><span class="keyword1">finally</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="var">?case</span><span class=""> </span><span class="keyword1">.</span><span class="">
</span><span class="">  </span><span class="keyword1">qed</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">map_default_update_twice</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="">fin</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;finite (dom f)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">and</span><span class=""> </span><span class="">anf</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;a &#8713; dom f&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">and</span><span class=""> </span><span class="">fg</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;f &#8838;<span class="hidden">&#8681;</span><sub>m</sub> g&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;upd a d&#39;&#39; (upd a d&#39; (Finite_Set.fold (&#955;a. upd a (map_default d g a)) (cnst d) (dom f))) =
         upd a d&#39;&#39; (Finite_Set.fold (&#955;a. upd a (map_default d g a)) (cnst d) (dom f))&quot;</span><span class="">
</span><span class="keyword1">proof</span><span class=""> </span><span class="">-</span><span class="">
</span><span class="">  </span><span class="keyword1">let</span><span class=""> </span><span class="var">?upd</span><span class=""> </span><span class="delimiter">=</span><span class=""> </span><span class="string">&quot;&#955;a. upd a (map_default d g a)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">let</span><span class=""> </span><span class="var">?fr</span><span class=""> </span><span class="delimiter">=</span><span class=""> </span><span class="string">&quot;&#955;A. Finite_Set.fold ?upd (cnst d) A&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">interpret</span><span class=""> </span><span class="">gwf</span><span class="delimiter">:</span><span class=""> </span><span class="">comp_fun_commute</span><span class=""> </span><span class="string">&quot;?upd&quot;</span><span class=""> </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">upd_left_comm</span><span class="delimiter">)</span><span class="">
</span><span class="">  
</span><span class="">  </span><span class="keyword1">from</span><span class=""> </span><span class="">fin</span><span class=""> </span><span class="">anf</span><span class=""> </span><span class="">fg</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="var">?thesis</span><span class="">
</span><span class="">  </span><span class="keyword1">proof</span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="string">&quot;dom f&quot;</span><span class=""> </span><span class="">arbitrary</span><span class="delimiter">:</span><span class=""> </span><span class="">f</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword3">case</span><span class=""> </span><span class="">empty</span><span class="">
</span><span class="">    </span><span class="keyword1">from</span><span class=""> </span><span class="cartouche">&#8249;{} = dom f&#8250;</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;f = empty&quot;</span><span class=""> </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">dom_def</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword3">thus</span><span class=""> </span><span class="var">?case</span><span class=""> </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_const_def</span><span class=""> </span><span class="">finfun_update_def</span><span class=""> </span><span class="">upd_upd_twice</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">next</span><span class="">
</span><span class="">    </span><span class="keyword3">case</span><span class=""> </span><span class="delimiter">(</span><span class="">insert</span><span class=""> </span><span class="">a&#39;</span><span class=""> </span><span class="">A</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1">note</span><span class=""> </span><span class="">IH</span><span class=""> </span><span class="delimiter">=</span><span class=""> </span><span class="cartouche">&#8249;&#8896;f. &#10214;A = dom f; a &#8713; dom f; f &#8838;<span class="hidden">&#8681;</span><sub>m</sub> g&#10215; &#10233; upd a d&#39;&#39; (upd a d&#39; (?fr (dom f))) = upd a d&#39;&#39; (?fr (dom f))&#8250;</span><span class="">
</span><span class="">    </span><span class="keyword1">note</span><span class=""> </span><span class="">fin</span><span class=""> </span><span class="delimiter">=</span><span class=""> </span><span class="cartouche">&#8249;finite A&#8250;</span><span class=""> </span><span class="keyword1">note</span><span class=""> </span><span class="">anf</span><span class=""> </span><span class="delimiter">=</span><span class=""> </span><span class="cartouche">&#8249;a &#8713; dom f&#8250;</span><span class=""> </span><span class="keyword1">note</span><span class=""> </span><span class="">a&#39;nA</span><span class=""> </span><span class="delimiter">=</span><span class=""> </span><span class="cartouche">&#8249;a&#39; &#8713; A&#8250;</span><span class="">
</span><span class="">    </span><span class="keyword1">note</span><span class=""> </span><span class="">domf</span><span class=""> </span><span class="delimiter">=</span><span class=""> </span><span class="cartouche">&#8249;insert a&#39; A = dom f&#8250;</span><span class=""> </span><span class="keyword1">note</span><span class=""> </span><span class="">fg</span><span class=""> </span><span class="delimiter">=</span><span class=""> </span><span class="cartouche">&#8249;f &#8838;<span class="hidden">&#8681;</span><sub>m</sub> g&#8250;</span><span class="">
</span><span class="">    
</span><span class="">    </span><span class="keyword1">from</span><span class=""> </span><span class="">domf</span><span class=""> </span><span class="keyword3">obtain</span><span class=""> </span><span class="">b</span><span class=""> </span><span class="keyword2">where</span><span class=""> </span><span class="">b</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;f a&#39; = Some b&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">    </span><span class="keyword1">let</span><span class=""> </span><span class="var">?f&#39;</span><span class=""> </span><span class="delimiter">=</span><span class=""> </span><span class="string">&quot;f(a&#39; := None)&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">let</span><span class=""> </span><span class="var">?b&#39;</span><span class=""> </span><span class="delimiter">=</span><span class=""> </span><span class="string">&quot;case f a&#39; of None &#8658; d | Some b &#8658; b&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">from</span><span class=""> </span><span class="">domf</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;upd a d&#39;&#39; (upd a d&#39; (?fr (dom f))) = upd a d&#39;&#39; (upd a d&#39; (?fr (insert a&#39; A)))&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">    </span><span class="keyword1">also</span><span class=""> </span><span class="keyword1">note</span><span class=""> </span><span class="">gwf.fold_insert</span><span class="delimiter">[</span><span class="">OF</span><span class=""> </span><span class="">fin</span><span class=""> </span><span class="">a&#39;nA</span><span class="delimiter">]</span><span class="">
</span><span class="">    </span><span class="keyword1">also</span><span class=""> </span><span class="keyword1">from</span><span class=""> </span><span class="">b</span><span class=""> </span><span class="">fg</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;g a&#39; = f a&#39;&quot;</span><span class=""> </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">map_le_def</span><span class=""> </span><span class="">intro</span><span class="delimiter">:</span><span class=""> </span><span class="">domI</span><span class=""> </span><span class="">dest</span><span class="delimiter">:</span><span class=""> </span><span class="">bspec</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1">hence</span><span class=""> </span><span class="">ga&#39;</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;map_default d g a&#39; = map_default d f a&#39;&quot;</span><span class=""> </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">map_default_def</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1">also</span><span class=""> </span><span class="keyword1">from</span><span class=""> </span><span class="">anf</span><span class=""> </span><span class="">domf</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="">ana&#39;</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;a &#8800; a&#39;&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class=""> </span><span class="keyword1">note</span><span class=""> </span><span class="">upd_commute</span><span class="delimiter">[</span><span class="">OF</span><span class=""> </span><span class="">this</span><span class="delimiter">]</span><span class="">
</span><span class="">    </span><span class="keyword1">also</span><span class=""> </span><span class="keyword1">note</span><span class=""> </span><span class="">upd_commute</span><span class="delimiter">[</span><span class="">OF</span><span class=""> </span><span class="">ana&#39;</span><span class="delimiter">]</span><span class="">
</span><span class="">    </span><span class="keyword1">also</span><span class=""> </span><span class="keyword1">from</span><span class=""> </span><span class="">domf</span><span class=""> </span><span class="">a&#39;nA</span><span class=""> </span><span class="">anf</span><span class=""> </span><span class="">fg</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;a &#8713; dom ?f&#39;&quot;</span><span class=""> </span><span class="string">&quot;?f&#39; &#8838;<span class="hidden">&#8681;</span><sub>m</sub> g&quot;</span><span class=""> </span><span class="keyword2">and</span><span class=""> </span><span class="">A</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;A = dom ?f&#39;&quot;</span><span class=""> </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">ran_def</span><span class=""> </span><span class="">map_le_def</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1">note</span><span class=""> </span><span class="">A</span><span class=""> </span><span class="keyword1">also</span><span class=""> </span><span class="keyword1">note</span><span class=""> </span><span class="">IH</span><span class="delimiter">[</span><span class="">OF</span><span class=""> </span><span class="">A</span><span class=""> </span><span class="cartouche">&#8249;a &#8713; dom ?f&#39;&#8250;</span><span class=""> </span><span class="cartouche">&#8249;?f&#39; &#8838;<span class="hidden">&#8681;</span><sub>m</sub> g&#8250;</span><span class="delimiter">]</span><span class="">
</span><span class="">    </span><span class="keyword1">also</span><span class=""> </span><span class="keyword1">note</span><span class=""> </span><span class="">upd_commute</span><span class="delimiter">[</span><span class="">OF</span><span class=""> </span><span class="">ana&#39;</span><span class="delimiter">[</span><span class="">symmetric</span><span class="delimiter">]</span><span class="delimiter">]</span><span class=""> </span><span class="keyword1">also</span><span class=""> </span><span class="keyword1">note</span><span class=""> </span><span class="">ga&#39;</span><span class="delimiter">[</span><span class="">symmetric</span><span class="delimiter">]</span><span class=""> </span><span class="keyword1">also</span><span class=""> </span><span class="keyword1">note</span><span class=""> </span><span class="">A</span><span class="delimiter">[</span><span class="">symmetric</span><span class="delimiter">]</span><span class="">
</span><span class="">    </span><span class="keyword1">also</span><span class=""> </span><span class="keyword1">note</span><span class=""> </span><span class="">gwf.fold_insert</span><span class="delimiter">[</span><span class="">symmetric</span><span class="delimiter">,</span><span class=""> </span><span class="">OF</span><span class=""> </span><span class="">fin</span><span class=""> </span><span class="">a&#39;nA</span><span class="delimiter">]</span><span class=""> </span><span class="keyword1">also</span><span class=""> </span><span class="keyword1">note</span><span class=""> </span><span class="">domf</span><span class="">
</span><span class="">    </span><span class="keyword1">finally</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="var">?case</span><span class=""> </span><span class="keyword1">.</span><span class="">
</span><span class="">  </span><span class="keyword1">qed</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">map_default_eq_id</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;map_default d ((&#955;a. Some (f a)) |` {a. f a &#8800; d}) = f&quot;</span><span class="">
</span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">map_default_def</span><span class=""> </span><span class="">restrict_map_def</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">finite_rec_cong1</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="">f</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;comp_fun_commute f&quot;</span><span class=""> </span><span class="keyword2">and</span><span class=""> </span><span class="">g</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;comp_fun_commute g&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">and</span><span class=""> </span><span class="">fin</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;finite A&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">and</span><span class=""> </span><span class="">eq</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;&#8896;a. a &#8712; A &#10233; f a = g a&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;Finite_Set.fold f z A = Finite_Set.fold g z A&quot;</span><span class="">
</span><span class="keyword1">proof</span><span class=""> </span><span class="">-</span><span class="">
</span><span class="">  </span><span class="keyword1">interpret</span><span class=""> </span><span class="">f</span><span class="delimiter">:</span><span class=""> </span><span class="">comp_fun_commute</span><span class=""> </span><span class="">f</span><span class=""> </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">f</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">interpret</span><span class=""> </span><span class="">g</span><span class="delimiter">:</span><span class=""> </span><span class="">comp_fun_commute</span><span class=""> </span><span class="">g</span><span class=""> </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">g</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">{</span><span class=""> </span><span class="keyword3">fix</span><span class=""> </span><span class="">B</span><span class="">
</span><span class="">    </span><span class="keyword3">assume</span><span class=""> </span><span class="">BsubA</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;B &#8838; A&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">with</span><span class=""> </span><span class="">fin</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;finite B&quot;</span><span class=""> </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">blast</span><span class=""> </span><span class="">intro</span><span class="delimiter">:</span><span class=""> </span><span class="">finite_subset</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1">hence</span><span class=""> </span><span class="string">&quot;B &#8838; A &#10233; Finite_Set.fold f z B = Finite_Set.fold g z B&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">proof</span><span class="delimiter">(</span><span class="">induct</span><span class="delimiter">)</span><span class="">
</span><span class="">      </span><span class="keyword3">case</span><span class=""> </span><span class="">empty</span><span class=""> </span><span class="keyword3">thus</span><span class=""> </span><span class="var">?case</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">    </span><span class="keyword1">next</span><span class="">
</span><span class="">      </span><span class="keyword3">case</span><span class=""> </span><span class="delimiter">(</span><span class="">insert</span><span class=""> </span><span class="">a</span><span class=""> </span><span class="">B</span><span class="delimiter">)</span><span class="">
</span><span class="">      </span><span class="keyword1">note</span><span class=""> </span><span class="">finB</span><span class=""> </span><span class="delimiter">=</span><span class=""> </span><span class="cartouche">&#8249;finite B&#8250;</span><span class=""> </span><span class="keyword1">note</span><span class=""> </span><span class="">anB</span><span class=""> </span><span class="delimiter">=</span><span class=""> </span><span class="cartouche">&#8249;a &#8713; B&#8250;</span><span class=""> </span><span class="keyword1">note</span><span class=""> </span><span class="">sub</span><span class=""> </span><span class="delimiter">=</span><span class=""> </span><span class="cartouche">&#8249;insert a B &#8838; A&#8250;</span><span class="">
</span><span class="">      </span><span class="keyword1">note</span><span class=""> </span><span class="">IH</span><span class=""> </span><span class="delimiter">=</span><span class=""> </span><span class="cartouche">&#8249;B &#8838; A &#10233; Finite_Set.fold f z B = Finite_Set.fold g z B&#8250;</span><span class="">
</span><span class="">      </span><span class="keyword1">from</span><span class=""> </span><span class="">sub</span><span class=""> </span><span class="">anB</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="">BpsubA</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;B &#8834; A&quot;</span><span class=""> </span><span class="keyword2">and</span><span class=""> </span><span class="">BsubA</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;B &#8838; A&quot;</span><span class=""> </span><span class="keyword2">and</span><span class=""> </span><span class="">aA</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;a &#8712; A&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">      </span><span class="keyword1">from</span><span class=""> </span><span class="">IH</span><span class="delimiter">[</span><span class="">OF</span><span class=""> </span><span class="">BsubA</span><span class="delimiter">]</span><span class=""> </span><span class="">eq</span><span class="delimiter">[</span><span class="">OF</span><span class=""> </span><span class="">aA</span><span class="delimiter">]</span><span class=""> </span><span class="">finB</span><span class=""> </span><span class="">anB</span><span class="">
</span><span class="">      </span><span class="keyword3">show</span><span class=""> </span><span class="var">?case</span><span class=""> </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">auto</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1">qed</span><span class="">
</span><span class="">    </span><span class="keyword1">with</span><span class=""> </span><span class="">BsubA</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;Finite_Set.fold f z B = Finite_Set.fold g z B&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">blast</span><span class=""> </span><span class="keyword1">}</span><span class="">
</span><span class="">  </span><span class="keyword3">thus</span><span class=""> </span><span class="var">?thesis</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">blast</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">finfun_rec_upd</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="string">&quot;finfun_rec cnst upd (f(a&#39; $:= b&#39;)) = upd a&#39; b&#39; (finfun_rec cnst upd f)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">including</span><span class=""> </span><span class="">finfun</span><span class="">
</span><span class="keyword1">proof</span><span class=""> </span><span class="">-</span><span class="">
</span><span class="">  </span><span class="keyword3">obtain</span><span class=""> </span><span class="">b</span><span class=""> </span><span class="keyword2">where</span><span class=""> </span><span class="">b</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;b = finfun_default f&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">  </span><span class="keyword1">let</span><span class=""> </span><span class="var">?the</span><span class=""> </span><span class="delimiter">=</span><span class=""> </span><span class="string">&quot;&#955;f g. f = Abs_finfun (map_default b g) &#8743; finite (dom g) &#8743; b &#8713; ran g&quot;</span><span class="">
</span><span class="">  </span><span class="keyword3">obtain</span><span class=""> </span><span class="">g</span><span class=""> </span><span class="keyword2">where</span><span class=""> </span><span class="">g</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;g = The (?the f)&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">blast</span><span class="">
</span><span class="">  </span><span class="keyword3">obtain</span><span class=""> </span><span class="">y</span><span class=""> </span><span class="keyword2">where</span><span class=""> </span><span class="">f</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;f = Abs_finfun y&quot;</span><span class=""> </span><span class="keyword2">and</span><span class=""> </span><span class="">y</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;y &#8712; finfun&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">cases</span><span class=""> </span><span class="">f</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">from</span><span class=""> </span><span class="">f</span><span class=""> </span><span class="">y</span><span class=""> </span><span class="">b</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="">bfin</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;finite {a. y a &#8800; b}&quot;</span><span class=""> </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_default_def</span><span class=""> </span><span class="">finite_finfun_default_aux</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="">  </span><span class="keyword1">let</span><span class=""> </span><span class="var">?g</span><span class=""> </span><span class="delimiter">=</span><span class=""> </span><span class="string">&quot;(&#955;a. Some (y a)) |` {a. y a &#8800; b}&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">from</span><span class=""> </span><span class="">bfin</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="">fing</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;finite (dom ?g)&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">  </span><span class="keyword1">have</span><span class=""> </span><span class="">bran</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;b &#8713; ran ?g&quot;</span><span class=""> </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">ran_def</span><span class=""> </span><span class="">restrict_map_def</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">have</span><span class=""> </span><span class="">yg</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;y = map_default b ?g&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">  </span><span class="keyword1">have</span><span class=""> </span><span class="">gg</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;g = ?g&quot;</span><span class=""> </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">g</span><span class="">
</span><span class="">  </span><span class="keyword1">proof</span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">the_equality</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1">from</span><span class=""> </span><span class="">f</span><span class=""> </span><span class="">y</span><span class=""> </span><span class="">bfin</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;?the f ?g&quot;</span><span class="">
</span><span class="">      </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">auto</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">restrict_map_def</span><span class=""> </span><span class="">ran_def</span><span class=""> </span><span class="">split</span><span class="delimiter">:</span><span class=""> </span><span class="">split_if_asm</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">next</span><span class="">
</span><span class="">    </span><span class="keyword3">fix</span><span class=""> </span><span class="">g&#39;</span><span class="">
</span><span class="">    </span><span class="keyword3">assume</span><span class=""> </span><span class="string">&quot;?the f g&#39;&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">hence</span><span class=""> </span><span class="">fin&#39;</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;finite (dom g&#39;)&quot;</span><span class=""> </span><span class="keyword2">and</span><span class=""> </span><span class="">ran&#39;</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;b &#8713; ran g&#39;&quot;</span><span class="">
</span><span class="">      </span><span class="keyword2">and</span><span class=""> </span><span class="">eq</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;Abs_finfun (map_default b ?g) = Abs_finfun (map_default b g&#39;)&quot;</span><span class=""> </span><span class="keyword1">using</span><span class=""> </span><span class="">f</span><span class=""> </span><span class="">yg</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">    </span><span class="keyword1">from</span><span class=""> </span><span class="">fin&#39;</span><span class=""> </span><span class="">fing</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;map_default b ?g &#8712; finfun&quot;</span><span class=""> </span><span class="string">&quot;map_default b g&#39; &#8712; finfun&quot;</span><span class=""> </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">blast</span><span class=""> </span><span class="">intro</span><span class="delimiter">:</span><span class=""> </span><span class="">map_default_in_finfun</span><span class="delimiter">)</span><span class="delimiter">+</span><span class="">
</span><span class="">    </span><span class="keyword1">with</span><span class=""> </span><span class="">eq</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;map_default b ?g = map_default b g&#39;&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">    </span><span class="keyword1">with</span><span class=""> </span><span class="">fing</span><span class=""> </span><span class="">bran</span><span class=""> </span><span class="">fin&#39;</span><span class=""> </span><span class="">ran&#39;</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;g&#39; = ?g&quot;</span><span class=""> </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">map_default_inject</span><span class="delimiter">[</span><span class="">OF</span><span class=""> </span><span class="">disjI2</span><span class="delimiter">[</span><span class="">OF</span><span class=""> </span><span class="">refl</span><span class="delimiter">]</span><span class="delimiter">,</span><span class=""> </span><span class="">THEN</span><span class=""> </span><span class="">sym</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="">  </span><span class="keyword3">show</span><span class=""> </span><span class="var">?thesis</span><span class="">
</span><span class="">  </span><span class="keyword1">proof</span><span class="delimiter">(</span><span class="">cases</span><span class=""> </span><span class="string">&quot;b&#39; = b&quot;</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword3">case</span><span class=""> </span><span class="">True</span><span class="">
</span><span class="">    </span><span class="keyword1">note</span><span class=""> </span><span class="">b&#39;b</span><span class=""> </span><span class="delimiter">=</span><span class=""> </span><span class="">True</span><span class="">
</span><span class="">
</span><span class="">    </span><span class="keyword1">let</span><span class=""> </span><span class="var">?g&#39;</span><span class=""> </span><span class="delimiter">=</span><span class=""> </span><span class="string">&quot;(&#955;a. Some ((y(a&#39; := b)) a)) |` {a. (y(a&#39; := b)) a &#8800; b}&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">from</span><span class=""> </span><span class="">bfin</span><span class=""> </span><span class="">b&#39;b</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="">fing&#39;</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;finite (dom ?g&#39;)&quot;</span><span class="">
</span><span class="">      </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">Collect_conj_eq</span><span class=""> </span><span class="">Collect_imp_eq</span><span class=""> </span><span class="">intro</span><span class="delimiter">:</span><span class=""> </span><span class="">finite_subset</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1">have</span><span class=""> </span><span class="">brang&#39;</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;b &#8713; ran ?g&#39;&quot;</span><span class=""> </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">ran_def</span><span class=""> </span><span class="">restrict_map_def</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="">    </span><span class="keyword1">let</span><span class=""> </span><span class="var">?b&#39;</span><span class=""> </span><span class="delimiter">=</span><span class=""> </span><span class="string">&quot;&#955;a. case ?g&#39; a of None &#8658; b | Some b &#8658; b&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">let</span><span class=""> </span><span class="var">?b</span><span class=""> </span><span class="delimiter">=</span><span class=""> </span><span class="string">&quot;map_default b ?g&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">from</span><span class=""> </span><span class="">upd_left_comm</span><span class=""> </span><span class="">upd_left_comm</span><span class=""> </span><span class="">fing&#39;</span><span class="">
</span><span class="">    </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;Finite_Set.fold (&#955;a. upd a (?b&#39; a)) (cnst b) (dom ?g&#39;) = Finite_Set.fold (&#955;a. upd a (?b a)) (cnst b) (dom ?g&#39;)&quot;</span><span class="">
</span><span class="">      </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">finite_rec_cong1</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">restrict_map_def</span><span class=""> </span><span class="">b&#39;b</span><span class=""> </span><span class="">b</span><span class=""> </span><span class="">map_default_def</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1">also</span><span class=""> </span><span class="keyword1">interpret</span><span class=""> </span><span class="">gwf</span><span class="delimiter">:</span><span class=""> </span><span class="">comp_fun_commute</span><span class=""> </span><span class="string">&quot;&#955;a. upd a (?b a)&quot;</span><span class=""> </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">upd_left_comm</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;Finite_Set.fold (&#955;a. upd a (?b a)) (cnst b) (dom ?g&#39;) = upd a&#39; b&#39; (Finite_Set.fold (&#955;a. upd a (?b a)) (cnst b) (dom ?g))&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">proof</span><span class="delimiter">(</span><span class="">cases</span><span class=""> </span><span class="string">&quot;y a&#39; = b&quot;</span><span class="delimiter">)</span><span class="">
</span><span class="">      </span><span class="keyword3">case</span><span class=""> </span><span class="">True</span><span class="">
</span><span class="">      </span><span class="keyword1">with</span><span class=""> </span><span class="">b&#39;b</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="">g&#39;</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;?g&#39; = ?g&quot;</span><span class=""> </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">restrict_map_def</span><span class="delimiter">)</span><span class="">
</span><span class="">      </span><span class="keyword1">from</span><span class=""> </span><span class="">True</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="">a&#39;ndomg</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;a&#39; &#8713; dom ?g&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">      </span><span class="keyword1">from</span><span class=""> </span><span class="">f</span><span class=""> </span><span class="">b&#39;b</span><span class=""> </span><span class="">b</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="var">?thesis</span><span class=""> </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">g&#39;</span><span class="">
</span><span class="">        </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">subst</span><span class=""> </span><span class="">map_default_update_const</span><span class="delimiter">[</span><span class="">OF</span><span class=""> </span><span class="">fing</span><span class=""> </span><span class="">a&#39;ndomg</span><span class=""> </span><span class="">map_le_refl</span><span class="delimiter">,</span><span class=""> </span><span class="">symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">    </span><span class="keyword1">next</span><span class="">
</span><span class="">      </span><span class="keyword3">case</span><span class=""> </span><span class="">False</span><span class="">
</span><span class="">      </span><span class="keyword1">hence</span><span class=""> </span><span class="">domg</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;dom ?g = insert a&#39; (dom ?g&#39;)&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">      </span><span class="keyword1">from</span><span class=""> </span><span class="">False</span><span class=""> </span><span class="">b&#39;b</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="">a&#39;ndomg&#39;</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;a&#39; &#8713; dom ?g&#39;&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">      </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;Finite_Set.fold (&#955;a. upd a (?b a)) (cnst b) (insert a&#39; (dom ?g&#39;)) = 
            upd a&#39; (?b a&#39;) (Finite_Set.fold (&#955;a. upd a (?b a)) (cnst b) (dom ?g&#39;))&quot;</span><span class="">
</span><span class="">        </span><span class="keyword1">using</span><span class=""> </span><span class="">fing&#39;</span><span class=""> </span><span class="">a&#39;ndomg&#39;</span><span class=""> </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">b&#39;b</span><span class=""> </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">gwf.fold_insert</span><span class="delimiter">)</span><span class="">
</span><span class="">      </span><span class="keyword1">hence</span><span class=""> </span><span class="string">&quot;upd a&#39; b (Finite_Set.fold (&#955;a. upd a (?b a)) (cnst b) (insert a&#39; (dom ?g&#39;))) =
             upd a&#39; b (upd a&#39; (?b a&#39;) (Finite_Set.fold (&#955;a. upd a (?b a)) (cnst b) (dom ?g&#39;)))&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">      </span><span class="keyword1">also</span><span class=""> </span><span class="keyword1">from</span><span class=""> </span><span class="">b&#39;b</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="">g&#39;leg</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;?g&#39; &#8838;<span class="hidden">&#8681;</span><sub>m</sub> ?g&quot;</span><span class=""> </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">restrict_map_def</span><span class=""> </span><span class="">map_le_def</span><span class="delimiter">)</span><span class="">
</span><span class="">      </span><span class="keyword1">note</span><span class=""> </span><span class="">map_default_update_twice</span><span class="delimiter">[</span><span class="">OF</span><span class=""> </span><span class="">fing&#39;</span><span class=""> </span><span class="">a&#39;ndomg&#39;</span><span class=""> </span><span class="">this</span><span class="delimiter">,</span><span class=""> </span><span class="">of</span><span class=""> </span><span class="">b</span><span class=""> </span><span class="string">&quot;?b a&#39;&quot;</span><span class=""> </span><span class="">b</span><span class="delimiter">]</span><span class="">
</span><span class="">      </span><span class="keyword1">also</span><span class=""> </span><span class="keyword1">note</span><span class=""> </span><span class="">map_default_update_const</span><span class="delimiter">[</span><span class="">OF</span><span class=""> </span><span class="">fing&#39;</span><span class=""> </span><span class="">a&#39;ndomg&#39;</span><span class=""> </span><span class="">g&#39;leg</span><span class="delimiter">,</span><span class=""> </span><span class="">of</span><span class=""> </span><span class="">b</span><span class="delimiter">]</span><span class="">
</span><span class="">      </span><span class="keyword1">finally</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="var">?thesis</span><span class=""> </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">b&#39;b</span><span class=""> </span><span class="">domg</span><span class="delimiter">[</span><span class="">unfolded</span><span class=""> </span><span class="">b&#39;b</span><span class="delimiter">]</span><span class=""> </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">sym</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1">qed</span><span class="">
</span><span class="">    </span><span class="keyword1">also</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;The (?the (f(a&#39; $:= b&#39;))) = ?g&#39;&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">proof</span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">the_equality</span><span class="delimiter">)</span><span class="">
</span><span class="">      </span><span class="keyword1">from</span><span class=""> </span><span class="">f</span><span class=""> </span><span class="">y</span><span class=""> </span><span class="">b</span><span class=""> </span><span class="">b&#39;b</span><span class=""> </span><span class="">brang&#39;</span><span class=""> </span><span class="">fing&#39;</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;?the (f(a&#39; $:= b&#39;)) ?g&#39;&quot;</span><span class="">
</span><span class="">        </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">del</span><span class="delimiter">:</span><span class=""> </span><span class="">fun_upd_apply</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_update_def</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1">next</span><span class="">
</span><span class="">      </span><span class="keyword3">fix</span><span class=""> </span><span class="">g&#39;</span><span class="">
</span><span class="">      </span><span class="keyword3">assume</span><span class=""> </span><span class="string">&quot;?the (f(a&#39; $:= b&#39;)) g&#39;&quot;</span><span class="">
</span><span class="">      </span><span class="keyword1">hence</span><span class=""> </span><span class="">fin&#39;</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;finite (dom g&#39;)&quot;</span><span class=""> </span><span class="keyword2">and</span><span class=""> </span><span class="">ran&#39;</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;b &#8713; ran g&#39;&quot;</span><span class="">
</span><span class="">        </span><span class="keyword2">and</span><span class=""> </span><span class="">eq</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;f(a&#39; $:= b&#39;) = Abs_finfun (map_default b g&#39;)&quot;</span><span class=""> 
</span><span class="">        </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">del</span><span class="delimiter">:</span><span class=""> </span><span class="">fun_upd_apply</span><span class="delimiter">)</span><span class="">
</span><span class="">      </span><span class="keyword1">from</span><span class=""> </span><span class="">fin&#39;</span><span class=""> </span><span class="">fing&#39;</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;map_default b g&#39; &#8712; finfun&quot;</span><span class=""> </span><span class="string">&quot;map_default b ?g&#39; &#8712; finfun&quot;</span><span class="">
</span><span class="">        </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">blast</span><span class=""> </span><span class="">intro</span><span class="delimiter">:</span><span class=""> </span><span class="">map_default_in_finfun</span><span class="delimiter">)</span><span class="delimiter">+</span><span class="">
</span><span class="">      </span><span class="keyword1">with</span><span class=""> </span><span class="">eq</span><span class=""> </span><span class="">f</span><span class=""> </span><span class="">b&#39;b</span><span class=""> </span><span class="">b</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;map_default b ?g&#39; = map_default b g&#39;&quot;</span><span class="">
</span><span class="">        </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">del</span><span class="delimiter">:</span><span class=""> </span><span class="">fun_upd_apply</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_update_def</span><span class="delimiter">)</span><span class="">
</span><span class="">      </span><span class="keyword1">with</span><span class=""> </span><span class="">fing&#39;</span><span class=""> </span><span class="">brang&#39;</span><span class=""> </span><span class="">fin&#39;</span><span class=""> </span><span class="">ran&#39;</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;g&#39; = ?g&#39;&quot;</span><span class="">
</span><span class="">        </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">map_default_inject</span><span class="delimiter">[</span><span class="">OF</span><span class=""> </span><span class="">disjI2</span><span class="delimiter">[</span><span class="">OF</span><span class=""> </span><span class="">refl</span><span class="delimiter">]</span><span class="delimiter">,</span><span class=""> </span><span class="">THEN</span><span class=""> </span><span class="">sym</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1">qed</span><span class="">
</span><span class="">    </span><span class="keyword1">ultimately</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="var">?thesis</span><span class=""> </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">finfun_rec_def</span><span class=""> </span><span class="">Let_def</span><span class=""> </span><span class="">b</span><span class=""> </span><span class="">gg</span><span class="delimiter">[</span><span class="">unfolded</span><span class=""> </span><span class="">g</span><span class=""> </span><span class="">b</span><span class="delimiter">]</span><span class=""> </span><span class="keyword1">using</span><span class=""> </span><span class="">bfin</span><span class=""> </span><span class="">b&#39;b</span><span class=""> </span><span class="">b</span><span class="">
</span><span class="">      </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">only</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_default_update_const</span><span class=""> </span><span class="">map_default_def</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">next</span><span class="">
</span><span class="">    </span><span class="keyword3">case</span><span class=""> </span><span class="">False</span><span class="">
</span><span class="">    </span><span class="keyword1">note</span><span class=""> </span><span class="">b&#39;b</span><span class=""> </span><span class="delimiter">=</span><span class=""> </span><span class="">this</span><span class="">
</span><span class="">    </span><span class="keyword1">let</span><span class=""> </span><span class="var">?g&#39;</span><span class=""> </span><span class="delimiter">=</span><span class=""> </span><span class="string">&quot;?g(a&#39; &#8614; b&#39;)&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">let</span><span class=""> </span><span class="var">?b&#39;</span><span class=""> </span><span class="delimiter">=</span><span class=""> </span><span class="string">&quot;map_default b ?g&#39;&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">let</span><span class=""> </span><span class="var">?b</span><span class=""> </span><span class="delimiter">=</span><span class=""> </span><span class="string">&quot;map_default b ?g&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">from</span><span class=""> </span><span class="">fing</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="">fing&#39;</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;finite (dom ?g&#39;)&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">    </span><span class="keyword1">from</span><span class=""> </span><span class="">bran</span><span class=""> </span><span class="">b&#39;b</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="">bnrang&#39;</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;b &#8713; ran ?g&#39;&quot;</span><span class=""> </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">ran_def</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1">have</span><span class=""> </span><span class="">ffmg&#39;</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;map_default b ?g&#39; = y(a&#39; := b&#39;)&quot;</span><span class=""> </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">map_default_def</span><span class=""> </span><span class="">restrict_map_def</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1">with</span><span class=""> </span><span class="">f</span><span class=""> </span><span class="">y</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="">f_Abs</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;f(a&#39; $:= b&#39;) = Abs_finfun (map_default b ?g&#39;)&quot;</span><span class=""> </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_update_def</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1">have</span><span class=""> </span><span class="">g&#39;</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;The (?the (f(a&#39; $:= b&#39;))) = ?g&#39;&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">proof</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">the_equality</span><span class="delimiter">)</span><span class="">
</span><span class="">      </span><span class="keyword1">from</span><span class=""> </span><span class="">fing&#39;</span><span class=""> </span><span class="">bnrang&#39;</span><span class=""> </span><span class="">f_Abs</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;?the (f(a&#39; $:= b&#39;)) ?g&#39;&quot;</span><span class="">
</span><span class="">        </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_update_def</span><span class=""> </span><span class="">restrict_map_def</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1">next</span><span class="">
</span><span class="">      </span><span class="keyword3">fix</span><span class=""> </span><span class="">g&#39;</span><span class=""> </span><span class="keyword3">assume</span><span class=""> </span><span class="string">&quot;?the (f(a&#39; $:= b&#39;)) g&#39;&quot;</span><span class="">
</span><span class="">      </span><span class="keyword1">hence</span><span class=""> </span><span class="">f&#39;</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;f(a&#39; $:= b&#39;) = Abs_finfun (map_default b g&#39;)&quot;</span><span class="">
</span><span class="">        </span><span class="keyword2">and</span><span class=""> </span><span class="">fin&#39;</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;finite (dom g&#39;)&quot;</span><span class=""> </span><span class="keyword2">and</span><span class=""> </span><span class="">brang&#39;</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;b &#8713; ran g&#39;&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">      </span><span class="keyword1">from</span><span class=""> </span><span class="">fing&#39;</span><span class=""> </span><span class="">fin&#39;</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;map_default b ?g&#39; &#8712; finfun&quot;</span><span class=""> </span><span class="string">&quot;map_default b g&#39; &#8712; finfun&quot;</span><span class="">
</span><span class="">        </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">intro</span><span class="delimiter">:</span><span class=""> </span><span class="">map_default_in_finfun</span><span class="delimiter">)</span><span class="">
</span><span class="">      </span><span class="keyword1">with</span><span class=""> </span><span class="">f&#39;</span><span class=""> </span><span class="">f_Abs</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;map_default b g&#39; = map_default b ?g&#39;&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">      </span><span class="keyword1">with</span><span class=""> </span><span class="">fin&#39;</span><span class=""> </span><span class="">brang&#39;</span><span class=""> </span><span class="">fing&#39;</span><span class=""> </span><span class="">bnrang&#39;</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;g&#39; = ?g&#39;&quot;</span><span class="">
</span><span class="">        </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">map_default_inject</span><span class="delimiter">[</span><span class="">OF</span><span class=""> </span><span class="">disjI2</span><span class="delimiter">[</span><span class="">OF</span><span class=""> </span><span class="">refl</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1">qed</span><span class="">
</span><span class="">    </span><span class="keyword1">have</span><span class=""> </span><span class="">dom</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;dom (((&#955;a. Some (y a)) |` {a. y a &#8800; b})(a&#39; &#8614; b&#39;)) = insert a&#39; (dom ((&#955;a. Some (y a)) |` {a. y a &#8800; b}))&quot;</span><span class="">
</span><span class="">      </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">    </span><span class="keyword3">show</span><span class=""> </span><span class="var">?thesis</span><span class="">
</span><span class="">    </span><span class="keyword1">proof</span><span class="delimiter">(</span><span class="">cases</span><span class=""> </span><span class="string">&quot;y a&#39; = b&quot;</span><span class="delimiter">)</span><span class="">
</span><span class="">      </span><span class="keyword3">case</span><span class=""> </span><span class="">True</span><span class="">
</span><span class="">      </span><span class="keyword1">hence</span><span class=""> </span><span class="">a&#39;ndomg</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;a&#39; &#8713; dom ?g&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">      </span><span class="keyword1">from</span><span class=""> </span><span class="">f</span><span class=""> </span><span class="">y</span><span class=""> </span><span class="">b&#39;b</span><span class=""> </span><span class="">True</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="">yff</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;y = map_default b (?g&#39; |` dom ?g)&quot;</span><span class="">
</span><span class="">        </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">restrict_map_def</span><span class=""> </span><span class="">map_default_def</span><span class=""> </span><span class="">intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span class=""> </span><span class="">ext</span><span class="delimiter">)</span><span class="">
</span><span class="">      </span><span class="keyword1">hence</span><span class=""> </span><span class="">f&#39;</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;f = Abs_finfun (map_default b (?g&#39; |` dom ?g))&quot;</span><span class=""> </span><span class="keyword1">using</span><span class=""> </span><span class="">f</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">      </span><span class="keyword1">interpret</span><span class=""> </span><span class="">g&#39;wf</span><span class="delimiter">:</span><span class=""> </span><span class="">comp_fun_commute</span><span class=""> </span><span class="string">&quot;&#955;a. upd a (?b&#39; a)&quot;</span><span class=""> </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">upd_left_comm</span><span class="delimiter">)</span><span class="">
</span><span class="">      </span><span class="keyword1">from</span><span class=""> </span><span class="">upd_left_comm</span><span class=""> </span><span class="">upd_left_comm</span><span class=""> </span><span class="">fing</span><span class="">
</span><span class="">      </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;Finite_Set.fold (&#955;a. upd a (?b a)) (cnst b) (dom ?g) = Finite_Set.fold (&#955;a. upd a (?b&#39; a)) (cnst b) (dom ?g)&quot;</span><span class="">
</span><span class="">        </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">finite_rec_cong1</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">restrict_map_def</span><span class=""> </span><span class="">b&#39;b</span><span class=""> </span><span class="">True</span><span class=""> </span><span class="">map_default_def</span><span class="delimiter">)</span><span class="">
</span><span class="">      </span><span class="keyword3">thus</span><span class=""> </span><span class="var">?thesis</span><span class=""> </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">finfun_rec_def</span><span class=""> </span><span class="">Let_def</span><span class=""> </span><span class="">finfun_default_update_const</span><span class=""> </span><span class="">b</span><span class="delimiter">[</span><span class="">symmetric</span><span class="delimiter">]</span><span class="">
</span><span class="">        </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">g&#39;</span><span class=""> </span><span class="">g</span><span class="delimiter">[</span><span class="">symmetric</span><span class="delimiter">]</span><span class=""> </span><span class="">gg</span><span class=""> </span><span class="">g&#39;wf.fold_insert</span><span class="delimiter">[</span><span class="">OF</span><span class=""> </span><span class="">fing</span><span class=""> </span><span class="">a&#39;ndomg</span><span class="delimiter">,</span><span class=""> </span><span class="">of</span><span class=""> </span><span class="string">&quot;cnst b&quot;</span><span class="delimiter">,</span><span class=""> </span><span class="">folded</span><span class=""> </span><span class="">dom</span><span class="delimiter">]</span><span class="">
</span><span class="">        </span><span class="keyword1">by</span><span class=""> </span><span class="">-</span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">arg_cong2</span><span class="delimiter">[</span><span class="keyword2">where</span><span class=""> </span><span class="">f</span><span class="delimiter">=</span><span class="string">&quot;upd a&#39;&quot;</span><span class="delimiter">]</span><span class="delimiter">,</span><span class=""> </span><span class="">simp_all</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">map_default_def</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1">next</span><span class="">
</span><span class="">      </span><span class="keyword3">case</span><span class=""> </span><span class="">False</span><span class="">
</span><span class="">      </span><span class="keyword1">hence</span><span class=""> </span><span class="string">&quot;insert a&#39; (dom ?g) = dom ?g&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">      </span><span class="keyword1">moreover</span><span class=""> </span><span class="keyword1">{</span><span class="">
</span><span class="">        </span><span class="keyword1">let</span><span class=""> </span><span class="var">?g&#39;&#39;</span><span class=""> </span><span class="delimiter">=</span><span class=""> </span><span class="string">&quot;?g(a&#39; := None)&quot;</span><span class="">
</span><span class="">        </span><span class="keyword1">let</span><span class=""> </span><span class="var">?b&#39;&#39;</span><span class=""> </span><span class="delimiter">=</span><span class=""> </span><span class="string">&quot;map_default b ?g&#39;&#39;&quot;</span><span class="">
</span><span class="">        </span><span class="keyword1">from</span><span class=""> </span><span class="">False</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="">domg</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;dom ?g = insert a&#39; (dom ?g&#39;&#39;)&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">        </span><span class="keyword1">from</span><span class=""> </span><span class="">False</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="">a&#39;ndomg&#39;&#39;</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;a&#39; &#8713; dom ?g&#39;&#39;&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">        </span><span class="keyword1">have</span><span class=""> </span><span class="">fing&#39;&#39;</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;finite (dom ?g&#39;&#39;)&quot;</span><span class=""> </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">finite_subset</span><span class="delimiter">[</span><span class="">OF</span><span class=""> </span><span class="">_</span><span class=""> </span><span class="">fing</span><span class="delimiter">]</span><span class="delimiter">)</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">        </span><span class="keyword1">have</span><span class=""> </span><span class="">bnrang&#39;&#39;</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;b &#8713; ran ?g&#39;&#39;&quot;</span><span class=""> </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">ran_def</span><span class=""> </span><span class="">restrict_map_def</span><span class="delimiter">)</span><span class="">
</span><span class="">        </span><span class="keyword1">interpret</span><span class=""> </span><span class="">gwf</span><span class="delimiter">:</span><span class=""> </span><span class="">comp_fun_commute</span><span class=""> </span><span class="string">&quot;&#955;a. upd a (?b a)&quot;</span><span class=""> </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">upd_left_comm</span><span class="delimiter">)</span><span class="">
</span><span class="">        </span><span class="keyword1">interpret</span><span class=""> </span><span class="">g&#39;wf</span><span class="delimiter">:</span><span class=""> </span><span class="">comp_fun_commute</span><span class=""> </span><span class="string">&quot;&#955;a. upd a (?b&#39; a)&quot;</span><span class=""> </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">upd_left_comm</span><span class="delimiter">)</span><span class="">
</span><span class="">        </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;upd a&#39; b&#39; (Finite_Set.fold (&#955;a. upd a (?b a)) (cnst b) (insert a&#39; (dom ?g&#39;&#39;))) =
              upd a&#39; b&#39; (upd a&#39; (?b a&#39;) (Finite_Set.fold (&#955;a. upd a (?b a)) (cnst b) (dom ?g&#39;&#39;)))&quot;</span><span class="">
</span><span class="">          </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">gwf.fold_insert</span><span class="delimiter">[</span><span class="">OF</span><span class=""> </span><span class="">fing&#39;&#39;</span><span class=""> </span><span class="">a&#39;ndomg&#39;&#39;</span><span class="delimiter">]</span><span class=""> </span><span class="">f</span><span class=""> </span><span class="keyword1">..</span><span class="">
</span><span class="">        </span><span class="keyword1">also</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="">g&#39;&#39;leg</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;?g |` dom ?g&#39;&#39; &#8838;<span class="hidden">&#8681;</span><sub>m</sub> ?g&quot;</span><span class=""> </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">map_le_def</span><span class="delimiter">)</span><span class="">
</span><span class="">        </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;dom (?g |` dom ?g&#39;&#39;) = dom ?g&#39;&#39;&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">        </span><span class="keyword1">note</span><span class=""> </span><span class="">map_default_update_twice</span><span class="delimiter">[</span><span class="keyword2">where</span><span class=""> </span><span class="">d</span><span class="delimiter">=</span><span class="">b</span><span class=""> </span><span class="keyword2">and</span><span class=""> </span><span class="">f</span><span class=""> </span><span class="delimiter">=</span><span class=""> </span><span class="string">&quot;?g |` dom ?g&#39;&#39;&quot;</span><span class=""> </span><span class="keyword2">and</span><span class=""> </span><span class="">a</span><span class="delimiter">=</span><span class="">a&#39;</span><span class=""> </span><span class="keyword2">and</span><span class=""> </span><span class="">d&#39;</span><span class="delimiter">=</span><span class="string">&quot;?b a&#39;&quot;</span><span class=""> </span><span class="keyword2">and</span><span class=""> </span><span class="">d&#39;&#39;</span><span class="delimiter">=</span><span class="">b&#39;</span><span class=""> </span><span class="keyword2">and</span><span class=""> </span><span class="">g</span><span class="delimiter">=</span><span class="string">&quot;?g&quot;</span><span class="delimiter">,</span><span class="">
</span><span class="">                                     </span><span class="">unfolded</span><span class=""> </span><span class="">this</span><span class="delimiter">,</span><span class=""> </span><span class="">OF</span><span class=""> </span><span class="">fing&#39;&#39;</span><span class=""> </span><span class="">a&#39;ndomg&#39;&#39;</span><span class=""> </span><span class="">g&#39;&#39;leg</span><span class="delimiter">]</span><span class="">
</span><span class="">        </span><span class="keyword1">also</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="">b&#39;</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;b&#39; = ?b&#39; a&#39;&quot;</span><span class=""> </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">map_default_def</span><span class="delimiter">)</span><span class="">
</span><span class="">        </span><span class="keyword1">from</span><span class=""> </span><span class="">upd_left_comm</span><span class=""> </span><span class="">upd_left_comm</span><span class=""> </span><span class="">fing&#39;&#39;</span><span class="">
</span><span class="">        </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;Finite_Set.fold (&#955;a. upd a (?b a)) (cnst b) (dom ?g&#39;&#39;) =
          Finite_Set.fold (&#955;a. upd a (?b&#39; a)) (cnst b) (dom ?g&#39;&#39;)&quot;</span><span class="">
</span><span class="">          </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">finite_rec_cong1</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">restrict_map_def</span><span class=""> </span><span class="">b&#39;b</span><span class=""> </span><span class="">map_default_def</span><span class="delimiter">)</span><span class="">
</span><span class="">        </span><span class="keyword1">with</span><span class=""> </span><span class="">b&#39;</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;upd a&#39; b&#39; (Finite_Set.fold (&#955;a. upd a (?b a)) (cnst b) (dom ?g&#39;&#39;)) =
                     upd a&#39; (?b&#39; a&#39;) (Finite_Set.fold (&#955;a. upd a (?b&#39; a)) (cnst b) (dom ?g&#39;&#39;))&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">        </span><span class="keyword1">also</span><span class=""> </span><span class="keyword1">note</span><span class=""> </span><span class="">g&#39;wf.fold_insert</span><span class="delimiter">[</span><span class="">OF</span><span class=""> </span><span class="">fing&#39;&#39;</span><span class=""> </span><span class="">a&#39;ndomg&#39;&#39;</span><span class="delimiter">,</span><span class=""> </span><span class="">symmetric</span><span class="delimiter">]</span><span class="">
</span><span class="">        </span><span class="keyword1">finally</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;upd a&#39; b&#39; (Finite_Set.fold (&#955;a. upd a (?b a)) (cnst b) (dom ?g)) =
                   Finite_Set.fold (&#955;a. upd a (?b&#39; a)) (cnst b) (dom ?g)&quot;</span><span class="">
</span><span class="">          </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">domg</span><span class=""> </span><span class="keyword1">.</span><span class=""> </span><span class="keyword1">}</span><span class="">
</span><span class="">      </span><span class="keyword1">ultimately</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;Finite_Set.fold (&#955;a. upd a (?b&#39; a)) (cnst b) (insert a&#39; (dom ?g)) =
                    upd a&#39; b&#39; (Finite_Set.fold (&#955;a. upd a (?b a)) (cnst b) (dom ?g))&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">      </span><span class="keyword3">thus</span><span class=""> </span><span class="var">?thesis</span><span class=""> </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">finfun_rec_def</span><span class=""> </span><span class="">Let_def</span><span class=""> </span><span class="">finfun_default_update_const</span><span class=""> </span><span class="">b</span><span class="delimiter">[</span><span class="">symmetric</span><span class="delimiter">]</span><span class=""> </span><span class="">g</span><span class="delimiter">[</span><span class="">symmetric</span><span class="delimiter">]</span><span class=""> </span><span class="">g&#39;</span><span class=""> </span><span class="">dom</span><span class="delimiter">[</span><span class="">symmetric</span><span class="delimiter">]</span><span class="">
</span><span class="">        </span><span class="keyword1">using</span><span class=""> </span><span class="">b&#39;b</span><span class=""> </span><span class="">gg</span><span class=""> </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">map_default_insert</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1">qed</span><span class="">
</span><span class="">  </span><span class="keyword1">qed</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="keyword2">end</span><span class="">
</span><span class="">
</span><span class="keyword1">locale</span><span class=""> </span><span class="">finfun_rec_wf</span><span class=""> </span><span class="delimiter">=</span><span class=""> </span><span class="">finfun_rec_wf_aux</span><span class=""> </span><span class="delimiter">+</span><span class=""> 
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="">const_update_all</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="string">&quot;finite (UNIV :: &#39;a set) &#10233; Finite_Set.fold (&#955;a. upd a b&#39;) (cnst b) (UNIV :: &#39;a set) = cnst b&#39;&quot;</span><span class="">
</span><span class="keyword2">begin</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">finfun_rec_const</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="keyword2">includes</span><span class=""> </span><span class="">finfun</span><span class=""> </span><span class="keyword2">shows</span><span class="">
</span><span class="">  </span><span class="string">&quot;finfun_rec cnst upd (K$ c) = cnst c&quot;</span><span class="">
</span><span class="keyword1">proof</span><span class="delimiter">(</span><span class="">cases</span><span class=""> </span><span class="string">&quot;finite (UNIV :: &#39;a set)&quot;</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword3">case</span><span class=""> </span><span class="">False</span><span class="">
</span><span class="">  </span><span class="keyword1">hence</span><span class=""> </span><span class="string">&quot;finfun_default ((K$ c) :: &#39;a &#8658;f &#39;b) = c&quot;</span><span class=""> </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_default_const</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">moreover</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;(THE g :: &#39;a &#8640; &#39;b. (K$ c) = Abs_finfun (map_default c g) &#8743; finite (dom g) &#8743; c &#8713; ran g) = empty&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">proof</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">the_equality</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;(K$ c) = Abs_finfun (map_default c empty) &#8743; finite (dom empty) &#8743; c &#8713; ran empty&quot;</span><span class="">
</span><span class="">      </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_const_def</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">next</span><span class="">
</span><span class="">    </span><span class="keyword3">fix</span><span class=""> </span><span class="">g</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;&#39;a &#8640; &#39;b&quot;</span><span class="">
</span><span class="">    </span><span class="keyword3">assume</span><span class=""> </span><span class="string">&quot;(K$ c) = Abs_finfun (map_default c g) &#8743; finite (dom g) &#8743; c &#8713; ran g&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">hence</span><span class=""> </span><span class="">g</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;(K$ c) = Abs_finfun (map_default c g)&quot;</span><span class=""> </span><span class="keyword2">and</span><span class=""> </span><span class="">fin</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;finite (dom g)&quot;</span><span class=""> </span><span class="keyword2">and</span><span class=""> </span><span class="">ran</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;c &#8713; ran g&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">blast</span><span class="delimiter">+</span><span class="">
</span><span class="">    </span><span class="keyword1">from</span><span class=""> </span><span class="">g</span><span class=""> </span><span class="">map_default_in_finfun</span><span class="delimiter">[</span><span class="">OF</span><span class=""> </span><span class="">fin</span><span class="delimiter">,</span><span class=""> </span><span class="">of</span><span class=""> </span><span class="">c</span><span class="delimiter">]</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;map_default c g = (&#955;a. c)&quot;</span><span class="">
</span><span class="">      </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_const_def</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1">moreover</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;map_default c empty = (&#955;a. c)&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">    </span><span class="keyword1">ultimately</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;g = empty&quot;</span><span class=""> </span><span class="keyword1">by</span><span class="">-</span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">map_default_inject</span><span class="delimiter">[</span><span class="">OF</span><span class=""> </span><span class="">disjI2</span><span class="delimiter">[</span><span class="">OF</span><span class=""> </span><span class="">refl</span><span class="delimiter">]</span><span class=""> </span><span class="">fin</span><span class=""> </span><span class="">ran</span><span class="delimiter">]</span><span class="delimiter">,</span><span class=""> </span><span class="">auto</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">qed</span><span class="">
</span><span class="">  </span><span class="keyword1">ultimately</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="var">?thesis</span><span class=""> </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_rec_def</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1">next</span><span class="">
</span><span class="">  </span><span class="keyword3">case</span><span class=""> </span><span class="">True</span><span class="">
</span><span class="">  </span><span class="keyword1">hence</span><span class=""> </span><span class="">default</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;finfun_default ((K$ c) :: &#39;a &#8658;f &#39;b) = undefined&quot;</span><span class=""> </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_default_const</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">let</span><span class=""> </span><span class="var">?the</span><span class=""> </span><span class="delimiter">=</span><span class=""> </span><span class="string">&quot;&#955;g :: &#39;a &#8640; &#39;b. (K$ c) = Abs_finfun (map_default undefined g) &#8743; finite (dom g) &#8743; undefined &#8713; ran g&quot;</span><span class="">
</span><span class="">  </span><span class="keyword3">show</span><span class=""> </span><span class="var">?thesis</span><span class="">
</span><span class="">  </span><span class="keyword1">proof</span><span class="delimiter">(</span><span class="">cases</span><span class=""> </span><span class="string">&quot;c = undefined&quot;</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword3">case</span><span class=""> </span><span class="">True</span><span class="">
</span><span class="">    </span><span class="keyword1">have</span><span class=""> </span><span class="">the</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;The ?the = empty&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">proof</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">the_equality</span><span class="delimiter">)</span><span class="">
</span><span class="">      </span><span class="keyword1">from</span><span class=""> </span><span class="">True</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;?the empty&quot;</span><span class=""> </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_const_def</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1">next</span><span class="">
</span><span class="">      </span><span class="keyword3">fix</span><span class=""> </span><span class="">g&#39;</span><span class="">
</span><span class="">      </span><span class="keyword3">assume</span><span class=""> </span><span class="string">&quot;?the g&#39;&quot;</span><span class="">
</span><span class="">      </span><span class="keyword1">hence</span><span class=""> </span><span class="">fg</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;(K$ c) = Abs_finfun (map_default undefined g&#39;)&quot;</span><span class="">
</span><span class="">        </span><span class="keyword2">and</span><span class=""> </span><span class="">fin</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;finite (dom g&#39;)&quot;</span><span class=""> </span><span class="keyword2">and</span><span class=""> </span><span class="">g</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;undefined &#8713; ran g&#39;&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp_all</span><span class="">
</span><span class="">      </span><span class="keyword1">from</span><span class=""> </span><span class="">fin</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;map_default undefined g&#39; &#8712; finfun&quot;</span><span class=""> </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">map_default_in_finfun</span><span class="delimiter">)</span><span class="">
</span><span class="">      </span><span class="keyword1">with</span><span class=""> </span><span class="">fg</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;map_default undefined g&#39; = (&#955;a. c)&quot;</span><span class="">
</span><span class="">        </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_const_def</span><span class=""> </span><span class="">intro</span><span class="delimiter">:</span><span class=""> </span><span class="">Abs_finfun_inject</span><span class="delimiter">[</span><span class="">THEN</span><span class=""> </span><span class="">iffD1</span><span class="delimiter">,</span><span class=""> </span><span class="">symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="">
</span><span class="">      </span><span class="keyword1">with</span><span class=""> </span><span class="">True</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;g&#39; = empty&quot;</span><span class="">
</span><span class="">        </span><span class="keyword1">by</span><span class=""> </span><span class="">-</span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">map_default_inject</span><span class="delimiter">(</span><span class="">2</span><span class="delimiter">)</span><span class="delimiter">[</span><span class="">OF</span><span class=""> </span><span class="">_</span><span class=""> </span><span class="">fin</span><span class=""> </span><span class="">g</span><span class="delimiter">]</span><span class="delimiter">,</span><span class=""> </span><span class="">auto</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1">qed</span><span class="">
</span><span class="">    </span><span class="keyword3">show</span><span class=""> </span><span class="var">?thesis</span><span class=""> </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">finfun_rec_def</span><span class=""> </span><span class="keyword1">using</span><span class=""> </span><span class="cartouche">&#8249;finite UNIV&#8250;</span><span class=""> </span><span class="">True</span><span class="">
</span><span class="">      </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">Let_def</span><span class=""> </span><span class="">the</span><span class=""> </span><span class="">default</span><span class=""> </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">simp</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">next</span><span class="">
</span><span class="">    </span><span class="keyword3">case</span><span class=""> </span><span class="">False</span><span class="">
</span><span class="">    </span><span class="keyword1">have</span><span class=""> </span><span class="">the</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;The ?the = (&#955;a :: &#39;a. Some c)&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">proof</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">the_equality</span><span class="delimiter">)</span><span class="">
</span><span class="">      </span><span class="keyword1">from</span><span class=""> </span><span class="">False</span><span class=""> </span><span class="">True</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;?the (&#955;a :: &#39;a. Some c)&quot;</span><span class="">
</span><span class="">        </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">map_default_def</span><span class=""> </span><span class="delimiter">[</span><span class="">abs_def</span><span class="delimiter">]</span><span class=""> </span><span class="">finfun_const_def</span><span class=""> </span><span class="">dom_def</span><span class=""> </span><span class="">ran_def</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1">next</span><span class="">
</span><span class="">      </span><span class="keyword3">fix</span><span class=""> </span><span class="">g&#39;</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;&#39;a &#8640; &#39;b&quot;</span><span class="">
</span><span class="">      </span><span class="keyword3">assume</span><span class=""> </span><span class="string">&quot;?the g&#39;&quot;</span><span class="">
</span><span class="">      </span><span class="keyword1">hence</span><span class=""> </span><span class="">fg</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;(K$ c) = Abs_finfun (map_default undefined g&#39;)&quot;</span><span class="">
</span><span class="">        </span><span class="keyword2">and</span><span class=""> </span><span class="">fin</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;finite (dom g&#39;)&quot;</span><span class=""> </span><span class="keyword2">and</span><span class=""> </span><span class="">g</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;undefined &#8713; ran g&#39;&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp_all</span><span class="">
</span><span class="">      </span><span class="keyword1">from</span><span class=""> </span><span class="">fin</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;map_default undefined g&#39; &#8712; finfun&quot;</span><span class=""> </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">map_default_in_finfun</span><span class="delimiter">)</span><span class="">
</span><span class="">      </span><span class="keyword1">with</span><span class=""> </span><span class="">fg</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;map_default undefined g&#39; = (&#955;a. c)&quot;</span><span class="">
</span><span class="">        </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_const_def</span><span class=""> </span><span class="">intro</span><span class="delimiter">:</span><span class=""> </span><span class="">Abs_finfun_inject</span><span class="delimiter">[</span><span class="">THEN</span><span class=""> </span><span class="">iffD1</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="">
</span><span class="">      </span><span class="keyword1">with</span><span class=""> </span><span class="">True</span><span class=""> </span><span class="">False</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;g&#39; = (&#955;a::&#39;a. Some c)&quot;</span><span class="">
</span><span class="">        </span><span class="keyword1">by</span><span class=""> </span><span class="">-</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">map_default_inject</span><span class="delimiter">(</span><span class="">2</span><span class="delimiter">)</span><span class="delimiter">[</span><span class="">OF</span><span class=""> </span><span class="">_</span><span class=""> </span><span class="">fin</span><span class=""> </span><span class="">g</span><span class="delimiter">]</span><span class="delimiter">,</span><span class="">
</span><span class="">          </span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">dom_def</span><span class=""> </span><span class="">ran_def</span><span class=""> </span><span class="">map_default_def</span><span class=""> </span><span class="delimiter">[</span><span class="">abs_def</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1">qed</span><span class="">
</span><span class="">    </span><span class="keyword3">show</span><span class=""> </span><span class="var">?thesis</span><span class=""> </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">finfun_rec_def</span><span class=""> </span><span class="keyword1">using</span><span class=""> </span><span class="">True</span><span class=""> </span><span class="">False</span><span class="">
</span><span class="">      </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">Let_def</span><span class=""> </span><span class="">the</span><span class=""> </span><span class="">default</span><span class=""> </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">dom_def</span><span class=""> </span><span class="">map_default_def</span><span class=""> </span><span class="">const_update_all</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">qed</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="keyword2">end</span><span class="">
</span><span class="">
</span><span class="keyword1">subsection</span><span class=""> </span><span class="cartouche">&#8249;Weak induction rule and case analysis for FinFuns&#8250;</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">finfun_weak_induct</span><span class=""> </span><span class="delimiter">[</span><span class="">consumes</span><span class=""> </span><span class="">0</span><span class="delimiter">,</span><span class=""> </span><span class="">case_names</span><span class=""> </span><span class="">const</span><span class=""> </span><span class="">update</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="">const</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;&#8896;b. P (K$ b)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">and</span><span class=""> </span><span class="">update</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;&#8896;f a b. P f &#10233; P (f(a $:= b))&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;P x&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">including</span><span class=""> </span><span class="">finfun</span><span class="">
</span><span class="keyword1">proof</span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">x</span><span class=""> </span><span class="">rule</span><span class="delimiter">:</span><span class=""> </span><span class="">Abs_finfun_induct</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword3">case</span><span class=""> </span><span class="delimiter">(</span><span class="">Abs_finfun</span><span class=""> </span><span class="">y</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">then</span><span class=""> </span><span class="keyword3">obtain</span><span class=""> </span><span class="">b</span><span class=""> </span><span class="keyword2">where</span><span class=""> </span><span class="string">&quot;finite {a. y a &#8800; b}&quot;</span><span class=""> </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">finfun_def</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">blast</span><span class="">
</span><span class="">  </span><span class="keyword3">thus</span><span class=""> </span><span class="var">?case</span><span class=""> </span><span class="keyword1">using</span><span class=""> </span><span class="cartouche">&#8249;y &#8712; finfun&#8250;</span><span class="">
</span><span class="">  </span><span class="keyword1">proof</span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="string">&quot;{a. y a &#8800; b}&quot;</span><span class=""> </span><span class="">arbitrary</span><span class="delimiter">:</span><span class=""> </span><span class="">y</span><span class=""> </span><span class="">rule</span><span class="delimiter">:</span><span class=""> </span><span class="">finite_induct</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword3">case</span><span class=""> </span><span class="">empty</span><span class="">
</span><span class="">    </span><span class="keyword1">hence</span><span class=""> </span><span class="string">&quot;&#8896;a. y a = b&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">blast</span><span class="">
</span><span class="">    </span><span class="keyword1">hence</span><span class=""> </span><span class="string">&quot;y = (&#955;a. b)&quot;</span><span class=""> </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">auto</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1">hence</span><span class=""> </span><span class="string">&quot;Abs_finfun y = finfun_const b&quot;</span><span class=""> </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">finfun_const_def</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">    </span><span class="keyword3">thus</span><span class=""> </span><span class="var">?case</span><span class=""> </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">const</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">next</span><span class="">
</span><span class="">    </span><span class="keyword3">case</span><span class=""> </span><span class="delimiter">(</span><span class="">insert</span><span class=""> </span><span class="">a</span><span class=""> </span><span class="">A</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1">note</span><span class=""> </span><span class="">IH</span><span class=""> </span><span class="delimiter">=</span><span class=""> </span><span class="cartouche">&#8249;&#8896;y. &#10214; A = {a. y a &#8800; b}; y &#8712; finfun  &#10215; &#10233; P (Abs_finfun y)&#8250;</span><span class="">
</span><span class="">    </span><span class="keyword1">note</span><span class=""> </span><span class="">y</span><span class=""> </span><span class="delimiter">=</span><span class=""> </span><span class="cartouche">&#8249;y &#8712; finfun&#8250;</span><span class="">
</span><span class="">    </span><span class="keyword1">with</span><span class=""> </span><span class="cartouche">&#8249;insert a A = {a. y a &#8800; b}&#8250;</span><span class=""> </span><span class="cartouche">&#8249;a &#8713; A&#8250;</span><span class="">
</span><span class="">    </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;A = {a&#39;. (y(a := b)) a&#39; &#8800; b}&quot;</span><span class=""> </span><span class="string">&quot;y(a := b) &#8712; finfun&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">    </span><span class="keyword1">from</span><span class=""> </span><span class="">IH</span><span class="delimiter">[</span><span class="">OF</span><span class=""> </span><span class="">this</span><span class="delimiter">]</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;P (finfun_update (Abs_finfun (y(a := b))) a (y a))&quot;</span><span class=""> </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">update</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword3">thus</span><span class=""> </span><span class="var">?case</span><span class=""> </span><span class="keyword1">using</span><span class=""> </span><span class="">y</span><span class=""> </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">finfun_update_def</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">  </span><span class="keyword1">qed</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">finfun_exhaust_disj</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;(&#8707;b. x = finfun_const b) &#8744; (&#8707;f a b. x = finfun_update f a b)&quot;</span><span class="">
</span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">x</span><span class=""> </span><span class="">rule</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_weak_induct</span><span class="delimiter">)</span><span class=""> </span><span class="">blast</span><span class="delimiter">+</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">finfun_exhaust</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">obtains</span><span class=""> </span><span class="">b</span><span class=""> </span><span class="keyword2">where</span><span class=""> </span><span class="string">&quot;x = (K$ b)&quot;</span><span class="">
</span><span class="">        </span><span class="delimiter">|</span><span class=""> </span><span class="">f</span><span class=""> </span><span class="">a</span><span class=""> </span><span class="">b</span><span class=""> </span><span class="keyword2">where</span><span class=""> </span><span class="string">&quot;x = f(a $:= b)&quot;</span><span class="">
</span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">atomize_elim</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">finfun_exhaust_disj</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">finfun_rec_unique</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">fixes</span><span class=""> </span><span class="">f</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;&#39;a &#8658;f &#39;b &#8658; &#39;c&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="">c</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;&#8896;c. f (K$ c) = cnst c&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">and</span><span class=""> </span><span class="">u</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;&#8896;g a b. f (g(a $:= b)) = upd g a b (f g)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">and</span><span class=""> </span><span class="">c&#39;</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;&#8896;c. f&#39; (K$ c) = cnst c&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">and</span><span class=""> </span><span class="">u&#39;</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;&#8896;g a b. f&#39; (g(a $:= b)) = upd g a b (f&#39; g)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;f = f&#39;&quot;</span><span class="">
</span><span class="keyword1">proof</span><span class="">
</span><span class="">  </span><span class="keyword3">fix</span><span class=""> </span><span class="">g</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;&#39;a &#8658;f &#39;b&quot;</span><span class="">
</span><span class="">  </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;f g = f&#39; g&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">g</span><span class=""> </span><span class="">rule</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_weak_induct</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">c</span><span class=""> </span><span class="">u</span><span class=""> </span><span class="">c&#39;</span><span class=""> </span><span class="">u&#39;</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="">
</span><span class="keyword1">subsection</span><span class=""> </span><span class="cartouche">&#8249;Function application&#8250;</span><span class="">
</span><span class="">
</span><span class="keyword1">notation</span><span class=""> </span><span class="">finfun_apply</span><span class=""> </span><span class="delimiter">(</span><span class="keyword2">infixl</span><span class=""> </span><span class="string">&quot;$&quot;</span><span class=""> </span><span class="">999</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">interpretation</span><span class=""> </span><span class="">finfun_apply_aux</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_rec_wf_aux</span><span class=""> </span><span class="string">&quot;&#955;b. b&quot;</span><span class=""> </span><span class="string">&quot;&#955;a&#39; b c. if (a = a&#39;) then b else c&quot;</span><span class="">
</span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">unfold_locales</span><span class="delimiter">)</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">
</span><span class="keyword1">interpretation</span><span class=""> </span><span class="">finfun_apply</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_rec_wf</span><span class=""> </span><span class="string">&quot;&#955;b. b&quot;</span><span class=""> </span><span class="string">&quot;&#955;a&#39; b c. if (a = a&#39;) then b else c&quot;</span><span class="">
</span><span class="keyword1">proof</span><span class="delimiter">(</span><span class="">unfold_locales</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword3">fix</span><span class=""> </span><span class="">b&#39;</span><span class=""> </span><span class="">b</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="tfree">&#39;a</span><span class="">
</span><span class="">  </span><span class="keyword3">assume</span><span class=""> </span><span class="">fin</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;finite (UNIV :: &#39;b set)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">{</span><span class=""> </span><span class="keyword3">fix</span><span class=""> </span><span class="">A</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;&#39;b set&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">interpret</span><span class=""> </span><span class="">comp_fun_commute</span><span class=""> </span><span class="string">&quot;&#955;a&#39;. If (a = a&#39;) b&#39;&quot;</span><span class=""> </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">finfun_apply_aux.upd_left_comm</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1">from</span><span class=""> </span><span class="">fin</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;finite A&quot;</span><span class=""> </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">intro</span><span class="delimiter">:</span><span class=""> </span><span class="">finite_subset</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1">hence</span><span class=""> </span><span class="string">&quot;Finite_Set.fold (&#955;a&#39;. If (a = a&#39;) b&#39;) b A = (if a &#8712; A then b&#39; else b)&quot;</span><span class="">
</span><span class="">      </span><span class="keyword1">by</span><span class=""> </span><span class="">induct</span><span class=""> </span><span class="">auto</span><span class=""> </span><span class="keyword1">}</span><span class="">
</span><span class="">  </span><span class="keyword1">from</span><span class=""> </span><span class="">this</span><span class="delimiter">[</span><span class="">of</span><span class=""> </span><span class="">UNIV</span><span class="delimiter">]</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;Finite_Set.fold (&#955;a&#39;. If (a = a&#39;) b&#39;) b UNIV = b&#39;&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">finfun_apply_def</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;op $ = (&#955;f a. finfun_rec (&#955;b. b) (&#955;a&#39; b c. if (a = a&#39;) then b else c) f)&quot;</span><span class="">
</span><span class="keyword1">proof</span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">finfun_rec_unique</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword3">fix</span><span class=""> </span><span class="">c</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;op $ (K$ c) = (&#955;a. c)&quot;</span><span class=""> </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_const.rep_eq</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1">next</span><span class="">
</span><span class="">  </span><span class="keyword3">fix</span><span class=""> </span><span class="">g</span><span class=""> </span><span class="">a</span><span class=""> </span><span class="">b</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;op $ g(a $:= b) = (&#955;c. if c = a then b else g $ c)&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_update_def</span><span class=""> </span><span class="">fun_upd_finfun</span><span class=""> </span><span class="">Abs_finfun_inverse</span><span class=""> </span><span class="">finfun_apply</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1">qed</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">finfun_upd_apply</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;f(a $:= b) $ a&#39; = (if a = a&#39; then b else f $ a&#39;)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">and</span><span class=""> </span><span class="">finfun_upd_apply_code</span><span class=""> </span><span class="delimiter">[</span><span class="">code</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;(finfun_update_code f a b) $ a&#39; = (if a = a&#39; then b else f $ a&#39;)&quot;</span><span class="">
</span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">simp_all</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_apply_def</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">finfun_const_apply</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">,</span><span class=""> </span><span class="">code</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;(K$ b) $ a = b&quot;</span><span class="">
</span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_apply_def</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">finfun_upd_apply_same</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="string">&quot;f(a $:= b) $ a = b&quot;</span><span class="">
</span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_upd_apply</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">finfun_upd_apply_other</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="string">&quot;a &#8800; a&#39; &#10233; f(a $:= b) $ a&#39; = f $ a&#39;&quot;</span><span class="">
</span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_upd_apply</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">finfun_ext</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;(&#8896;a. f $ a = g $ a) &#10233; f = g&quot;</span><span class="">
</span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_apply_inject</span><span class="delimiter">[</span><span class="">symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">expand_finfun_eq</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;(f = g) = (op $ f = op $ g)&quot;</span><span class="">
</span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">intro</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_ext</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">finfun_upd_triv</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;f(x $:= f $ x) = f&quot;</span><span class="">
</span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">expand_finfun_eq</span><span class=""> </span><span class="">fun_eq_iff</span><span class=""> </span><span class="">finfun_upd_apply</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">finfun_const_inject</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;(K$ b) = (K$ b&#39;) &#8801; b = b&#39;&quot;</span><span class="">
</span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">expand_finfun_eq</span><span class=""> </span><span class="">fun_eq_iff</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">finfun_const_eq_update</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="string">&quot;((K$ b) = f(a $:= b&#39;)) = (b = b&#39; &#8743; (&#8704;a&#39;. a &#8800; a&#39; &#10230; f $ a&#39; = b))&quot;</span><span class="">
</span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">expand_finfun_eq</span><span class=""> </span><span class="">fun_eq_iff</span><span class=""> </span><span class="">finfun_upd_apply</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">subsection</span><span class=""> </span><span class="cartouche">&#8249;Function composition&#8250;</span><span class="">
</span><span class="">
</span><span class="keyword1">definition</span><span class=""> </span><span class="">finfun_comp</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;(&#39;a &#8658; &#39;b) &#8658; &#39;c &#8658;f &#39;a &#8658; &#39;c &#8658;f &#39;b&quot;</span><span class="">  </span><span class="delimiter">(</span><span class="keyword2">infixr</span><span class=""> </span><span class="string">&quot;&#8728;$&quot;</span><span class=""> </span><span class="">55</span><span class="delimiter">)</span><span class="">
</span><span class="keyword2">where</span><span class=""> </span><span class="delimiter">[</span><span class="">code</span><span class=""> </span><span class="">del</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;g &#8728;$ f  = finfun_rec (&#955;b. (K$ g b)) (&#955;a b c. c(a $:= g b)) f&quot;</span><span class="">
</span><span class="">
</span><span class="keyword1">notation</span><span class=""> </span><span class="delimiter">(</span><span class="">ASCII</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="">finfun_comp</span><span class=""> </span><span class="delimiter">(</span><span class="keyword2">infixr</span><span class=""> </span><span class="string">&quot;o$&quot;</span><span class=""> </span><span class="">55</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">interpretation</span><span class=""> </span><span class="">finfun_comp_aux</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_rec_wf_aux</span><span class=""> </span><span class="string">&quot;(&#955;b. (K$ g b))&quot;</span><span class=""> </span><span class="string">&quot;(&#955;a b c. c(a $:= g b))&quot;</span><span class="">
</span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">unfold_locales</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_upd_apply</span><span class=""> </span><span class="">intro</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_ext</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">interpretation</span><span class=""> </span><span class="">finfun_comp</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_rec_wf</span><span class=""> </span><span class="string">&quot;(&#955;b. (K$ g b))&quot;</span><span class=""> </span><span class="string">&quot;(&#955;a b c. c(a $:= g b))&quot;</span><span class="">
</span><span class="keyword1">proof</span><span class="">
</span><span class="">  </span><span class="keyword3">fix</span><span class=""> </span><span class="">b&#39;</span><span class=""> </span><span class="">b</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="tfree">&#39;a</span><span class="">
</span><span class="">  </span><span class="keyword3">assume</span><span class=""> </span><span class="">fin</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;finite (UNIV :: &#39;c set)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">{</span><span class=""> </span><span class="keyword3">fix</span><span class=""> </span><span class="">A</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;&#39;c set&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">from</span><span class=""> </span><span class="">fin</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;finite A&quot;</span><span class=""> </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">intro</span><span class="delimiter">:</span><span class=""> </span><span class="">finite_subset</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1">hence</span><span class=""> </span><span class="string">&quot;Finite_Set.fold (&#955;(a :: &#39;c) c. c(a $:= g b&#39;)) (K$ g b) A =
      Abs_finfun (&#955;a. if a &#8712; A then g b&#39; else g b)&quot;</span><span class="">
</span><span class="">      </span><span class="keyword1">by</span><span class=""> </span><span class="">induct</span><span class=""> </span><span class="delimiter">(</span><span class="">simp_all</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_const_def</span><span class="delimiter">,</span><span class=""> </span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_update_def</span><span class=""> </span><span class="">Abs_finfun_inverse_finite</span><span class=""> </span><span class="">fun_upd_def</span><span class=""> </span><span class="">Abs_finfun_inject_finite</span><span class=""> </span><span class="">fun_eq_iff</span><span class=""> </span><span class="">fin</span><span class="delimiter">)</span><span class=""> </span><span class="keyword1">}</span><span class="">
</span><span class="">  </span><span class="keyword1">from</span><span class=""> </span><span class="">this</span><span class="delimiter">[</span><span class="">of</span><span class=""> </span><span class="">UNIV</span><span class="delimiter">]</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;Finite_Set.fold (&#955;(a :: &#39;c) c. c(a $:= g b&#39;)) (K$ g b) UNIV = (K$ g b&#39;)&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_const_def</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">finfun_comp_const</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">,</span><span class=""> </span><span class="">code</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="string">&quot;g &#8728;$ (K$ c) = (K$ g c)&quot;</span><span class="">
</span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_comp_def</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">finfun_comp_update</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;g &#8728;$ (f(a $:= b)) = (g &#8728;$ f)(a $:= g b)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">and</span><span class=""> </span><span class="">finfun_comp_update_code</span><span class=""> </span><span class="delimiter">[</span><span class="">code</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> 
</span><span class="">  </span><span class="string">&quot;g &#8728;$ (finfun_update_code f a b) = finfun_update_code (g &#8728;$ f) a (g b)&quot;</span><span class="">
</span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">simp_all</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_comp_def</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">finfun_comp_apply</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="string">&quot;op $ (g &#8728;$ f) = g &#8728; op $ f&quot;</span><span class="">
</span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">f</span><span class=""> </span><span class="">rule</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_weak_induct</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_upd_apply</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">finfun_comp_comp_collapse</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;f &#8728;$ g &#8728;$ h = (f &#8728; g) &#8728;$ h&quot;</span><span class="">
</span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">h</span><span class=""> </span><span class="">rule</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_weak_induct</span><span class="delimiter">)</span><span class=""> </span><span class="">simp_all</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">finfun_comp_const1</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;(&#955;x. c) &#8728;$ f = (K$ c)&quot;</span><span class="">
</span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">f</span><span class=""> </span><span class="">rule</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_weak_induct</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">intro</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_ext</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_upd_apply</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">finfun_comp_id1</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;(&#955;x. x) &#8728;$ f = f&quot;</span><span class=""> </span><span class="string">&quot;id &#8728;$ f = f&quot;</span><span class="">
</span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">f</span><span class=""> </span><span class="">rule</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_weak_induct</span><span class="delimiter">)</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">finfun_comp_conv_comp</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;g &#8728;$ f = Abs_finfun (g &#8728; op $ f)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">including</span><span class=""> </span><span class="">finfun</span><span class="">
</span><span class="keyword1">proof</span><span class=""> </span><span class="">-</span><span class="">
</span><span class="">  </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;(&#955;f. g &#8728;$ f) = (&#955;f. Abs_finfun (g &#8728; op $ f))&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">proof</span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">finfun_rec_unique</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1">{</span><span class=""> </span><span class="keyword3">fix</span><span class=""> </span><span class="">c</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;Abs_finfun (g &#8728; op $ (K$ c)) = (K$ g c)&quot;</span><span class="">
</span><span class="">        </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_comp_def</span><span class=""> </span><span class="">o_def</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_const_def</span><span class="delimiter">)</span><span class=""> </span><span class="keyword1">}</span><span class="">
</span><span class="">    </span><span class="keyword1">{</span><span class=""> </span><span class="keyword3">fix</span><span class=""> </span><span class="">g&#39;</span><span class=""> </span><span class="">a</span><span class=""> </span><span class="">b</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;Abs_finfun (g &#8728; op $ g&#39;(a $:= b)) = (Abs_finfun (g &#8728; op $ g&#39;))(a $:= g b)&quot;</span><span class="">
</span><span class="">      </span><span class="keyword1">proof</span><span class=""> </span><span class="">-</span><span class="">
</span><span class="">        </span><span class="keyword3">obtain</span><span class=""> </span><span class="">y</span><span class=""> </span><span class="keyword2">where</span><span class=""> </span><span class="">y</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;y &#8712; finfun&quot;</span><span class=""> </span><span class="keyword2">and</span><span class=""> </span><span class="">g&#39;</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;g&#39; = Abs_finfun y&quot;</span><span class=""> </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">cases</span><span class=""> </span><span class="">g&#39;</span><span class="delimiter">)</span><span class="">
</span><span class="">        </span><span class="keyword1">moreover</span><span class=""> </span><span class="keyword1">from</span><span class=""> </span><span class="">g&#39;</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;(g &#8728; op $ g&#39;) &#8712; finfun&quot;</span><span class=""> </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_left_compose</span><span class="delimiter">)</span><span class="">
</span><span class="">        </span><span class="keyword1">moreover</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;g &#8728; y(a := b) = (g &#8728; y)(a := g b)&quot;</span><span class=""> </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">auto</span><span class="delimiter">)</span><span class="">
</span><span class="">        </span><span class="keyword1">ultimately</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="var">?thesis</span><span class=""> </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_comp_def</span><span class=""> </span><span class="">finfun_update_def</span><span class="delimiter">)</span><span class="">
</span><span class="">      </span><span class="keyword1">qed</span><span class=""> </span><span class="keyword1">}</span><span class="">
</span><span class="">  </span><span class="keyword1">qed</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">  </span><span class="keyword3">thus</span><span class=""> </span><span class="var">?thesis</span><span class=""> </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">fun_eq_iff</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="keyword1">definition</span><span class=""> </span><span class="">finfun_comp2</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;&#39;b &#8658;f &#39;c &#8658; (&#39;a &#8658; &#39;b) &#8658; &#39;a &#8658;f &#39;c&quot;</span><span class="">  </span><span class="delimiter">(</span><span class="keyword2">infixr</span><span class=""> </span><span class="string">&quot;$&#8728;&quot;</span><span class=""> </span><span class="">55</span><span class="delimiter">)</span><span class="">
</span><span class="keyword2">where</span><span class=""> </span><span class="delimiter">[</span><span class="">code</span><span class=""> </span><span class="">del</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;g $&#8728; f = Abs_finfun (op $ g &#8728; f)&quot;</span><span class="">
</span><span class="">
</span><span class="keyword1">notation</span><span class=""> </span><span class="delimiter">(</span><span class="">ASCII</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="">finfun_comp2</span><span class="">  </span><span class="delimiter">(</span><span class="keyword2">infixr</span><span class=""> </span><span class="string">&quot;$o&quot;</span><span class=""> </span><span class="">55</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">finfun_comp2_const</span><span class=""> </span><span class="delimiter">[</span><span class="">code</span><span class="delimiter">,</span><span class=""> </span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;finfun_comp2 (K$ c) f = (K$ c)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">including</span><span class=""> </span><span class="">finfun</span><span class="">
</span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_comp2_def</span><span class=""> </span><span class="">finfun_const_def</span><span class=""> </span><span class="">comp_def</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">finfun_comp2_update</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">includes</span><span class=""> </span><span class="">finfun</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="">inj</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;inj f&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;finfun_comp2 (g(b $:= c)) f = (if b &#8712; range f then (finfun_comp2 g f)(inv f b $:= c) else finfun_comp2 g f)&quot;</span><span class="">
</span><span class="keyword1">proof</span><span class="delimiter">(</span><span class="">cases</span><span class=""> </span><span class="string">&quot;b &#8712; range f&quot;</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword3">case</span><span class=""> </span><span class="">True</span><span class="">
</span><span class="">  </span><span class="keyword1">from</span><span class=""> </span><span class="">inj</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;&#8896;x. (op $ g)(f x := c) &#8728; f = (op $ g &#8728; f)(x := c)&quot;</span><span class=""> </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span class=""> </span><span class="">ext</span><span class=""> </span><span class="">dest</span><span class="delimiter">:</span><span class=""> </span><span class="">injD</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">with</span><span class=""> </span><span class="">inj</span><span class=""> </span><span class="">True</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="var">?thesis</span><span class=""> </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_comp2_def</span><span class=""> </span><span class="">finfun_update_def</span><span class=""> </span><span class="">finfun_right_compose</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1">next</span><span class="">
</span><span class="">  </span><span class="keyword3">case</span><span class=""> </span><span class="">False</span><span class="">
</span><span class="">  </span><span class="keyword1">hence</span><span class=""> </span><span class="string">&quot;(op $ g)(b := c) &#8728; f = op $ g &#8728; f&quot;</span><span class=""> </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">fun_eq_iff</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">with</span><span class=""> </span><span class="">False</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="var">?thesis</span><span class=""> </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_comp2_def</span><span class=""> </span><span class="">finfun_update_def</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="keyword1">subsection</span><span class=""> </span><span class="cartouche">&#8249;Universal quantification&#8250;</span><span class="">
</span><span class="">
</span><span class="keyword1">definition</span><span class=""> </span><span class="">finfun_All_except</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;&#39;a list &#8658; &#39;a &#8658;f bool &#8658; bool&quot;</span><span class="">
</span><span class="keyword2">where</span><span class=""> </span><span class="delimiter">[</span><span class="">code</span><span class=""> </span><span class="">del</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;finfun_All_except A P &#8801; &#8704;a. a &#8712; set A &#8744; P $ a&quot;</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">finfun_All_except_const</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;finfun_All_except A (K$ b) &#10231; b &#8744; set A = UNIV&quot;</span><span class="">
</span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_All_except_def</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">finfun_All_except_const_finfun_UNIV_code</span><span class=""> </span><span class="delimiter">[</span><span class="">code</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="string">&quot;finfun_All_except A (K$ b) = (b &#8744; is_list_UNIV A)&quot;</span><span class="">
</span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_All_except_const</span><span class=""> </span><span class="">is_list_UNIV_iff</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">finfun_All_except_update</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="string">&quot;finfun_All_except A f(a $:= b) = ((a &#8712; set A &#8744; b) &#8743; finfun_All_except (a # A) f)&quot;</span><span class="">
</span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">fastforce</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_All_except_def</span><span class=""> </span><span class="">finfun_upd_apply</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">finfun_All_except_update_code</span><span class=""> </span><span class="delimiter">[</span><span class="">code</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">fixes</span><span class=""> </span><span class="">a</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;&#39;a :: card_UNIV&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;finfun_All_except A (finfun_update_code f a b) = ((a &#8712; set A &#8744; b) &#8743; finfun_All_except (a # A) f)&quot;</span><span class="">
</span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_All_except_update</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">definition</span><span class=""> </span><span class="">finfun_All</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;&#39;a &#8658;f bool &#8658; bool&quot;</span><span class="">
</span><span class="keyword2">where</span><span class=""> </span><span class="string">&quot;finfun_All = finfun_All_except []&quot;</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">finfun_All_const</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;finfun_All (K$ b) = b&quot;</span><span class="">
</span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_All_def</span><span class=""> </span><span class="">finfun_All_except_def</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">finfun_All_update</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;finfun_All f(a $:= b) = (b &#8743; finfun_All_except [a] f)&quot;</span><span class="">
</span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_All_def</span><span class=""> </span><span class="">finfun_All_except_update</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">finfun_All_All</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;finfun_All P = All (op $ P)&quot;</span><span class="">
</span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_All_def</span><span class=""> </span><span class="">finfun_All_except_def</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="">
</span><span class="keyword1">definition</span><span class=""> </span><span class="">finfun_Ex</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;&#39;a &#8658;f bool &#8658; bool&quot;</span><span class="">
</span><span class="keyword2">where</span><span class=""> </span><span class="string">&quot;finfun_Ex P = Not (finfun_All (Not &#8728;$ P))&quot;</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">finfun_Ex_Ex</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;finfun_Ex P = Ex (op $ P)&quot;</span><span class="">
</span><span class="keyword1">unfolding</span><span class=""> </span><span class="">finfun_Ex_def</span><span class=""> </span><span class="">finfun_All_All</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">finfun_Ex_const</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;finfun_Ex (K$ b) = b&quot;</span><span class="">
</span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_Ex_def</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="">
</span><span class="keyword1">subsection</span><span class=""> </span><span class="cartouche">&#8249;A diagonal operator for FinFuns&#8250;</span><span class="">
</span><span class="">
</span><span class="keyword1">definition</span><span class=""> </span><span class="">finfun_Diag</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;&#39;a &#8658;f &#39;b &#8658; &#39;a &#8658;f &#39;c &#8658; &#39;a &#8658;f (&#39;b &#215; &#39;c)&quot;</span><span class=""> </span><span class="delimiter">(</span><span class="string">&quot;(1&#39;($_,/ _$&#39;))&quot;</span><span class=""> </span><span class="delimiter">[</span><span class="">0</span><span class="delimiter">,</span><span class=""> </span><span class="">0</span><span class="delimiter">]</span><span class=""> </span><span class="">1000</span><span class="delimiter">)</span><span class="">
</span><span class="keyword2">where</span><span class=""> </span><span class="delimiter">[</span><span class="">code</span><span class=""> </span><span class="">del</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;($f, g$) = finfun_rec (&#955;b. Pair b &#8728;$ g) (&#955;a b c. c(a $:= (b, g $ a))) f&quot;</span><span class="">
</span><span class="">
</span><span class="keyword1">interpretation</span><span class=""> </span><span class="">finfun_Diag_aux</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_rec_wf_aux</span><span class=""> </span><span class="string">&quot;&#955;b. Pair b &#8728;$ g&quot;</span><span class=""> </span><span class="string">&quot;&#955;a b c. c(a $:= (b, g $ a))&quot;</span><span class="">
</span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">unfold_locales</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="">simp_all</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">expand_finfun_eq</span><span class=""> </span><span class="">fun_eq_iff</span><span class=""> </span><span class="">finfun_upd_apply</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">interpretation</span><span class=""> </span><span class="">finfun_Diag</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_rec_wf</span><span class=""> </span><span class="string">&quot;&#955;b. Pair b &#8728;$ g&quot;</span><span class=""> </span><span class="string">&quot;&#955;a b c. c(a $:= (b, g $ a))&quot;</span><span class="">
</span><span class="keyword1">proof</span><span class="">
</span><span class="">  </span><span class="keyword3">fix</span><span class=""> </span><span class="">b&#39;</span><span class=""> </span><span class="">b</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="tfree">&#39;a</span><span class="">
</span><span class="">  </span><span class="keyword3">assume</span><span class=""> </span><span class="">fin</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;finite (UNIV :: &#39;c set)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">{</span><span class=""> </span><span class="keyword3">fix</span><span class=""> </span><span class="">A</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;&#39;c set&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">interpret</span><span class=""> </span><span class="">comp_fun_commute</span><span class=""> </span><span class="string">&quot;&#955;a c. c(a $:= (b&#39;, g $ a))&quot;</span><span class=""> </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">finfun_Diag_aux.upd_left_comm</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1">from</span><span class=""> </span><span class="">fin</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;finite A&quot;</span><span class=""> </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">intro</span><span class="delimiter">:</span><span class=""> </span><span class="">finite_subset</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1">hence</span><span class=""> </span><span class="string">&quot;Finite_Set.fold (&#955;a c. c(a $:= (b&#39;, g $ a))) (Pair b &#8728;$ g) A =
      Abs_finfun (&#955;a. (if a &#8712; A then b&#39; else b, g $ a))&quot;</span><span class="">
</span><span class="">      </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">induct</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="">simp_all</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_const_def</span><span class=""> </span><span class="">finfun_comp_conv_comp</span><span class=""> </span><span class="">o_def</span><span class="delimiter">,</span><span class="">
</span><span class="">                 </span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_update_def</span><span class=""> </span><span class="">Abs_finfun_inverse_finite</span><span class=""> </span><span class="">fun_upd_def</span><span class=""> </span><span class="">Abs_finfun_inject_finite</span><span class=""> </span><span class="">fun_eq_iff</span><span class=""> </span><span class="">fin</span><span class="delimiter">)</span><span class=""> </span><span class="keyword1">}</span><span class="">
</span><span class="">  </span><span class="keyword1">from</span><span class=""> </span><span class="">this</span><span class="delimiter">[</span><span class="">of</span><span class=""> </span><span class="">UNIV</span><span class="delimiter">]</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;Finite_Set.fold (&#955;a c. c(a $:= (b&#39;, g $ a))) (Pair b &#8728;$ g) UNIV = Pair b&#39; &#8728;$ g&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_const_def</span><span class=""> </span><span class="">finfun_comp_conv_comp</span><span class=""> </span><span class="">o_def</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">finfun_Diag_const1</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;($K$ b, g$) = Pair b &#8728;$ g&quot;</span><span class="">
</span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_Diag_def</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">text</span><span class=""> </span><span class="cartouche">&#8249;
  Do not use @{thm finfun_Diag_const1} for the code generator because @{term &quot;Pair b&quot;} is injective, i.e. if @{term g} is free of redundant updates, there is no need to check for redundant updates as is done for @{term &quot;op &#8728;$&quot;}.
&#8250;</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">finfun_Diag_const_code</span><span class=""> </span><span class="delimiter">[</span><span class="">code</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="string">&quot;($K$ b, K$ c$) = (K$ (b, c))&quot;</span><span class="">
</span><span class="">  </span><span class="string">&quot;($K$ b, finfun_update_code g a c$) = finfun_update_code ($K$ b, g$) a (b, c)&quot;</span><span class="">
</span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">simp_all</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_Diag_const1</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">finfun_Diag_update1</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;($f(a $:= b), g$) = ($f, g$)(a $:= (b, g $ a))&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">and</span><span class=""> </span><span class="">finfun_Diag_update1_code</span><span class=""> </span><span class="delimiter">[</span><span class="">code</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;($finfun_update_code f a b, g$) = ($f, g$)(a $:= (b, g $ a))&quot;</span><span class="">
</span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">simp_all</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_Diag_def</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">finfun_Diag_const2</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;($f, K$ c$) = (&#955;b. (b, c)) &#8728;$ f&quot;</span><span class="">
</span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">f</span><span class=""> </span><span class="">rule</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_weak_induct</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_ext</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_upd_apply</span><span class=""> </span><span class="">finfun_Diag_const1</span><span class=""> </span><span class="">finfun_Diag_update1</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">finfun_Diag_update2</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;($f, g(a $:= c)$) = ($f, g$)(a $:= (f $ a, c))&quot;</span><span class="">
</span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">f</span><span class=""> </span><span class="">rule</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_weak_induct</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_ext</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_upd_apply</span><span class=""> </span><span class="">finfun_Diag_const1</span><span class=""> </span><span class="">finfun_Diag_update1</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">finfun_Diag_const_const</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;($K$ b, K$ c$) = (K$ (b, c))&quot;</span><span class="">
</span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_Diag_const1</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">finfun_Diag_const_update</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="string">&quot;($K$ b, g(a $:= c)$) = ($K$ b, g$)(a $:= (b, c))&quot;</span><span class="">
</span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_Diag_const1</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">finfun_Diag_update_const</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="string">&quot;($f(a $:= b), K$ c$) = ($f, K$ c$)(a $:= (b, c))&quot;</span><span class="">
</span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_Diag_def</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">finfun_Diag_update_update</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="string">&quot;($f(a $:= b), g(a&#39; $:= c)$) = (if a = a&#39; then ($f, g$)(a $:= (b, c)) else ($f, g$)(a $:= (b, g $ a))(a&#39; $:= (f $ a&#39;, c)))&quot;</span><span class="">
</span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_Diag_update1</span><span class=""> </span><span class="">finfun_Diag_update2</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">finfun_Diag_apply</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;op $ ($f, g$) = (&#955;x. (f $ x, g $ x))&quot;</span><span class="">
</span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">f</span><span class=""> </span><span class="">rule</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_weak_induct</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_Diag_const1</span><span class=""> </span><span class="">finfun_Diag_update1</span><span class=""> </span><span class="">finfun_upd_apply</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">finfun_Diag_conv_Abs_finfun</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="string">&quot;($f, g$) = Abs_finfun ((&#955;x. (f $ x, g $ x)))&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">including</span><span class=""> </span><span class="">finfun</span><span class="">
</span><span class="keyword1">proof</span><span class=""> </span><span class="">-</span><span class="">
</span><span class="">  </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;(&#955;f :: &#39;a &#8658;f &#39;b. ($f, g$)) = (&#955;f. Abs_finfun ((&#955;x. (f $ x, g $ x))))&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">proof</span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">finfun_rec_unique</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1">{</span><span class=""> </span><span class="keyword3">fix</span><span class=""> </span><span class="">c</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;Abs_finfun (&#955;x. ((K$ c) $ x, g $ x)) = Pair c &#8728;$ g&quot;</span><span class="">
</span><span class="">        </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_comp_conv_comp</span><span class=""> </span><span class="">o_def</span><span class=""> </span><span class="">finfun_const_def</span><span class="delimiter">)</span><span class=""> </span><span class="keyword1">}</span><span class="">
</span><span class="">    </span><span class="keyword1">{</span><span class=""> </span><span class="keyword3">fix</span><span class=""> </span><span class="">g&#39;</span><span class=""> </span><span class="">a</span><span class=""> </span><span class="">b</span><span class="">
</span><span class="">      </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;Abs_finfun (&#955;x. (g&#39;(a $:= b) $ x, g $ x)) =
            (Abs_finfun (&#955;x. (g&#39; $ x, g $ x)))(a $:= (b, g $ a))&quot;</span><span class="">
</span><span class="">        </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_update_def</span><span class=""> </span><span class="">fun_eq_iff</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">del</span><span class="delimiter">:</span><span class=""> </span><span class="">fun_upd_apply</span><span class="delimiter">)</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="keyword1">}</span><span class="">
</span><span class="">  </span><span class="keyword1">qed</span><span class="delimiter">(</span><span class="">simp_all</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_Diag_const1</span><span class=""> </span><span class="">finfun_Diag_update1</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword3">thus</span><span class=""> </span><span class="var">?thesis</span><span class=""> </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">fun_eq_iff</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">finfun_Diag_eq</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;($f, g$) = ($f&#39;, g&#39;$) &#10231; f = f&#39; &#8743; g = g&#39;&quot;</span><span class="">
</span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">expand_finfun_eq</span><span class=""> </span><span class="">fun_eq_iff</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">definition</span><span class=""> </span><span class="">finfun_fst</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;&#39;a &#8658;f (&#39;b &#215; &#39;c) &#8658; &#39;a &#8658;f &#39;b&quot;</span><span class="">
</span><span class="keyword2">where</span><span class=""> </span><span class="delimiter">[</span><span class="">code</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;finfun_fst f = fst &#8728;$ f&quot;</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">finfun_fst_const</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;finfun_fst (K$ bc) = (K$ fst bc)&quot;</span><span class="">
</span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_fst_def</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">finfun_fst_update</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;finfun_fst (f(a $:= bc)) = (finfun_fst f)(a $:= fst bc)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">and</span><span class=""> </span><span class="">finfun_fst_update_code</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;finfun_fst (finfun_update_code f a bc) = (finfun_fst f)(a $:= fst bc)&quot;</span><span class="">
</span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">simp_all</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_fst_def</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">finfun_fst_comp_conv</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;finfun_fst (f &#8728;$ g) = (fst &#8728; f) &#8728;$ g&quot;</span><span class="">
</span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_fst_def</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">finfun_fst_conv</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;finfun_fst ($f, g$) = f&quot;</span><span class="">
</span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">f</span><span class=""> </span><span class="">rule</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_weak_induct</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="">simp_all</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_Diag_const1</span><span class=""> </span><span class="">finfun_fst_comp_conv</span><span class=""> </span><span class="">o_def</span><span class=""> </span><span class="">finfun_Diag_update1</span><span class=""> </span><span class="">finfun_fst_update</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">finfun_fst_conv_Abs_finfun</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;finfun_fst = (&#955;f. Abs_finfun (fst &#8728; op $ f))&quot;</span><span class="">
</span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_fst_def</span><span class=""> </span><span class="delimiter">[</span><span class="">abs_def</span><span class="delimiter">]</span><span class=""> </span><span class="">finfun_comp_conv_comp</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="">
</span><span class="keyword1">definition</span><span class=""> </span><span class="">finfun_snd</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;&#39;a &#8658;f (&#39;b &#215; &#39;c) &#8658; &#39;a &#8658;f &#39;c&quot;</span><span class="">
</span><span class="keyword2">where</span><span class=""> </span><span class="delimiter">[</span><span class="">code</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;finfun_snd f = snd &#8728;$ f&quot;</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">finfun_snd_const</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;finfun_snd (K$ bc) = (K$ snd bc)&quot;</span><span class="">
</span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_snd_def</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">finfun_snd_update</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;finfun_snd (f(a $:= bc)) = (finfun_snd f)(a $:= snd bc)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">and</span><span class=""> </span><span class="">finfun_snd_update_code</span><span class=""> </span><span class="delimiter">[</span><span class="">code</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;finfun_snd (finfun_update_code f a bc) = (finfun_snd f)(a $:= snd bc)&quot;</span><span class="">
</span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">simp_all</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_snd_def</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">finfun_snd_comp_conv</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;finfun_snd (f &#8728;$ g) = (snd &#8728; f) &#8728;$ g&quot;</span><span class="">
</span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_snd_def</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">finfun_snd_conv</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;finfun_snd ($f, g$) = g&quot;</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">f</span><span class=""> </span><span class="">rule</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_weak_induct</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_Diag_const1</span><span class=""> </span><span class="">finfun_snd_comp_conv</span><span class=""> </span><span class="">o_def</span><span class=""> </span><span class="">finfun_Diag_update1</span><span class=""> </span><span class="">finfun_snd_update</span><span class=""> </span><span class="">finfun_upd_apply</span><span class=""> </span><span class="">intro</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_ext</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">done</span></span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">finfun_snd_conv_Abs_finfun</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;finfun_snd = (&#955;f. Abs_finfun (snd &#8728; op $ f))&quot;</span><span class="">
</span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_snd_def</span><span class=""> </span><span class="delimiter">[</span><span class="">abs_def</span><span class="delimiter">]</span><span class=""> </span><span class="">finfun_comp_conv_comp</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">finfun_Diag_collapse</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;($finfun_fst f, finfun_snd f$) = f&quot;</span><span class="">
</span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">f</span><span class=""> </span><span class="">rule</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_weak_induct</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="">simp_all</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_fst_const</span><span class=""> </span><span class="">finfun_snd_const</span><span class=""> </span><span class="">finfun_fst_update</span><span class=""> </span><span class="">finfun_snd_update</span><span class=""> </span><span class="">finfun_Diag_update_update</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">subsection</span><span class=""> </span><span class="cartouche">&#8249;Currying for FinFuns&#8250;</span><span class="">
</span><span class="">
</span><span class="keyword1">definition</span><span class=""> </span><span class="">finfun_curry</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;(&#39;a &#215; &#39;b) &#8658;f &#39;c &#8658; &#39;a &#8658;f &#39;b &#8658;f &#39;c&quot;</span><span class="">
</span><span class="keyword2">where</span><span class=""> </span><span class="delimiter">[</span><span class="">code</span><span class=""> </span><span class="">del</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;finfun_curry = finfun_rec (finfun_const &#8728; finfun_const) (&#955;(a, b) c f. f(a $:= (f $ a)(b $:= c)))&quot;</span><span class="">
</span><span class="">
</span><span class="keyword1">interpretation</span><span class=""> </span><span class="">finfun_curry_aux</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_rec_wf_aux</span><span class=""> </span><span class="string">&quot;finfun_const &#8728; finfun_const&quot;</span><span class=""> </span><span class="string">&quot;&#955;(a, b) c f. f(a $:= (f $ a)(b $:= c))&quot;</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">unfold_locales</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">split_def</span><span class=""> </span><span class="">finfun_update_twist</span><span class=""> </span><span class="">finfun_upd_apply</span><span class=""> </span><span class="">split_paired_all</span><span class=""> </span><span class="">finfun_update_const_same</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">done</span></span><span class="">
</span><span class="">
</span><span class="keyword1">interpretation</span><span class=""> </span><span class="">finfun_curry</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_rec_wf</span><span class=""> </span><span class="string">&quot;finfun_const &#8728; finfun_const&quot;</span><span class=""> </span><span class="string">&quot;&#955;(a, b) c f. f(a $:= (f $ a)(b $:= c))&quot;</span><span class="">
</span><span class="keyword1">proof</span><span class="delimiter">(</span><span class="">unfold_locales</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword3">fix</span><span class=""> </span><span class="">b&#39;</span><span class=""> </span><span class="">b</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="tfree">&#39;b</span><span class="">
</span><span class="">  </span><span class="keyword3">assume</span><span class=""> </span><span class="">fin</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;finite (UNIV :: (&#39;c &#215; &#39;a) set)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">hence</span><span class=""> </span><span class="">fin1</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;finite (UNIV :: &#39;c set)&quot;</span><span class=""> </span><span class="keyword2">and</span><span class=""> </span><span class="">fin2</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;finite (UNIV :: &#39;a set)&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">UNIV_Times_UNIV</span><span class="delimiter">[</span><span class="">symmetric</span><span class="delimiter">]</span><span class="">
</span><span class="">    </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">fastforce</span><span class=""> </span><span class="">dest</span><span class="delimiter">:</span><span class=""> </span><span class="">finite_cartesian_productD1</span><span class=""> </span><span class="">finite_cartesian_productD2</span><span class="delimiter">)</span><span class="delimiter">+</span><span class="">
</span><span class="">  </span><span class="keyword1">note</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class=""> </span><span class="delimiter">=</span><span class=""> </span><span class="">Abs_finfun_inverse_finite</span><span class="delimiter">[</span><span class="">OF</span><span class=""> </span><span class="">fin</span><span class="delimiter">]</span><span class=""> </span><span class="">Abs_finfun_inverse_finite</span><span class="delimiter">[</span><span class="">OF</span><span class=""> </span><span class="">fin1</span><span class="delimiter">]</span><span class=""> </span><span class="">Abs_finfun_inverse_finite</span><span class="delimiter">[</span><span class="">OF</span><span class=""> </span><span class="">fin2</span><span class="delimiter">]</span><span class="">
</span><span class="">  </span><span class="keyword1">{</span><span class=""> </span><span class="keyword3">fix</span><span class=""> </span><span class="">A</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;(&#39;c &#215; &#39;a) set&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">interpret</span><span class=""> </span><span class="">comp_fun_commute</span><span class=""> </span><span class="string">&quot;&#955;a :: &#39;c &#215; &#39;a. (&#955;(a, b) c f. f(a $:= (f $ a)(b $:= c))) a b&#39;&quot;</span><span class="">
</span><span class="">      </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">finfun_curry_aux.upd_left_comm</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1">from</span><span class=""> </span><span class="">fin</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;finite A&quot;</span><span class=""> </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">intro</span><span class="delimiter">:</span><span class=""> </span><span class="">finite_subset</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1">hence</span><span class=""> </span><span class="string">&quot;Finite_Set.fold (&#955;a :: &#39;c &#215; &#39;a. (&#955;(a, b) c f. f(a $:= (f $ a)(b $:= c))) a b&#39;) ((finfun_const &#8728; finfun_const) b) A = Abs_finfun (&#955;a. Abs_finfun (&#955;b&#39;&#39;. if (a, b&#39;&#39;) &#8712; A then b&#39; else b))&quot;</span><span class="">
</span><span class="">      </span><span class="keyword1">by</span><span class=""> </span><span class="">induct</span><span class=""> </span><span class="delimiter">(</span><span class="">simp_all</span><span class="delimiter">,</span><span class=""> </span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_update_def</span><span class=""> </span><span class="">finfun_const_def</span><span class=""> </span><span class="">split_def</span><span class=""> </span><span class="">intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span class=""> </span><span class="">arg_cong</span><span class="delimiter">[</span><span class="keyword2">where</span><span class=""> </span><span class="">f</span><span class="delimiter">=</span><span class="string">&quot;Abs_finfun&quot;</span><span class="delimiter">]</span><span class=""> </span><span class="">ext</span><span class="delimiter">)</span><span class=""> </span><span class="keyword1">}</span><span class="">
</span><span class="">  </span><span class="keyword1">from</span><span class=""> </span><span class="">this</span><span class="delimiter">[</span><span class="">of</span><span class=""> </span><span class="">UNIV</span><span class="delimiter">]</span><span class="">
</span><span class="">  </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;Finite_Set.fold (&#955;a :: &#39;c &#215; &#39;a. (&#955;(a, b) c f. f(a $:= (f $ a)(b $:= c))) a b&#39;) ((finfun_const &#8728; finfun_const) b) UNIV = (finfun_const &#8728; finfun_const) b&#39;&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_const_def</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">finfun_curry_const</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">,</span><span class=""> </span><span class="">code</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;finfun_curry (K$ c) = (K$ K$ c)&quot;</span><span class="">
</span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_curry_def</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">finfun_curry_update</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="string">&quot;finfun_curry (f((a, b) $:= c)) = (finfun_curry f)(a $:= (finfun_curry f $ a)(b $:= c))&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">and</span><span class=""> </span><span class="">finfun_curry_update_code</span><span class=""> </span><span class="delimiter">[</span><span class="">code</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="string">&quot;finfun_curry (finfun_update_code f (a, b) c) = (finfun_curry f)(a $:= (finfun_curry f $ a)(b $:= c))&quot;</span><span class="">
</span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">simp_all</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_curry_def</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">finfun_Abs_finfun_curry</span><span class="delimiter">:</span><span class=""> </span><span class="keyword2">assumes</span><span class=""> </span><span class="">fin</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;f &#8712; finfun&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;(&#955;a. Abs_finfun (curry f a)) &#8712; finfun&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">including</span><span class=""> </span><span class="">finfun</span><span class="">
</span><span class="keyword1">proof</span><span class=""> </span><span class="">-</span><span class="">
</span><span class="">  </span><span class="keyword1">from</span><span class=""> </span><span class="">fin</span><span class=""> </span><span class="keyword3">obtain</span><span class=""> </span><span class="">c</span><span class=""> </span><span class="keyword2">where</span><span class=""> </span><span class="">c</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;finite {ab. f ab &#8800; c}&quot;</span><span class=""> </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">finfun_def</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">blast</span><span class="">
</span><span class="">  </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;{a. &#8707;b. f (a, b) &#8800; c} = fst ` {ab. f ab &#8800; c}&quot;</span><span class=""> </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">force</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">hence</span><span class=""> </span><span class="string">&quot;{a. curry f a &#8800; (&#955;x. c)} = fst ` {ab. f ab &#8800; c}&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">curry_def</span><span class=""> </span><span class="">fun_eq_iff</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">with</span><span class=""> </span><span class="">fin</span><span class=""> </span><span class="">c</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;finite {a.  Abs_finfun (curry f a) &#8800; (K$ c)}&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_const_def</span><span class=""> </span><span class="">finfun_curry</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword3">thus</span><span class=""> </span><span class="var">?thesis</span><span class=""> </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">finfun_def</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">finfun_curry_conv_curry</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">fixes</span><span class=""> </span><span class="">f</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;(&#39;a &#215; &#39;b) &#8658;f &#39;c&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;finfun_curry f = Abs_finfun (&#955;a. Abs_finfun (curry (finfun_apply f) a))&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">including</span><span class=""> </span><span class="">finfun</span><span class="">
</span><span class="keyword1">proof</span><span class=""> </span><span class="">-</span><span class="">
</span><span class="">  </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;finfun_curry = (&#955;f :: (&#39;a &#215; &#39;b) &#8658;f &#39;c. Abs_finfun (&#955;a. Abs_finfun (curry (finfun_apply f) a)))&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">proof</span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">finfun_rec_unique</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword3">fix</span><span class=""> </span><span class="">c</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;finfun_curry (K$ c) = (K$ K$ c)&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">    </span><span class="keyword3">fix</span><span class=""> </span><span class="">f</span><span class=""> </span><span class="">a</span><span class="">
</span><span class="">    </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;finfun_curry (f(a $:= c)) = (finfun_curry f)(fst a $:= (finfun_curry f $ (fst a))(snd a $:= c))&quot;</span><span class="">
</span><span class="">      </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">cases</span><span class=""> </span><span class="">a</span><span class="delimiter">)</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">    </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;Abs_finfun (&#955;a. Abs_finfun (curry (finfun_apply (K$ c)) a)) = (K$ K$ c)&quot;</span><span class="">
</span><span class="">      </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_curry_def</span><span class=""> </span><span class="">finfun_const_def</span><span class=""> </span><span class="">curry_def</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword3">fix</span><span class=""> </span><span class="">g</span><span class=""> </span><span class="">b</span><span class="">
</span><span class="">    </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;Abs_finfun (&#955;aa. Abs_finfun (curry (op $ g(a $:= b)) aa)) =
      (Abs_finfun (&#955;a. Abs_finfun (curry (op $ g) a)))(
      fst a $:= ((Abs_finfun (&#955;a. Abs_finfun (curry (op $ g) a))) $ (fst a))(snd a $:= b))&quot;</span><span class="">
</span><span class="">      </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">cases</span><span class=""> </span><span class="">a</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span class=""> </span><span class="">ext</span><span class=""> </span><span class="">arg_cong</span><span class="delimiter">[</span><span class="keyword2">where</span><span class=""> </span><span class="">f</span><span class="delimiter">=</span><span class="">Abs_finfun</span><span class="delimiter">]</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_curry_def</span><span class=""> </span><span class="">finfun_update_def</span><span class=""> </span><span class="">finfun_Abs_finfun_curry</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">qed</span><span class="">
</span><span class="">  </span><span class="keyword3">thus</span><span class=""> </span><span class="var">?thesis</span><span class=""> </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">fun_eq_iff</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="keyword1">subsection</span><span class=""> </span><span class="cartouche">&#8249;Executable equality for FinFuns&#8250;</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">eq_finfun_All_ext</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;(f = g) &#10231; finfun_All ((&#955;(x, y). x = y) &#8728;$ ($f, g$))&quot;</span><span class="">
</span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">expand_finfun_eq</span><span class=""> </span><span class="">fun_eq_iff</span><span class=""> </span><span class="">finfun_All_All</span><span class=""> </span><span class="">o_def</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">instantiation</span><span class=""> </span><span class="">finfun</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="delimiter">(</span><span class="string">&quot;{card_UNIV,equal}&quot;</span><span class="delimiter">,</span><span class="">equal</span><span class="delimiter">)</span><span class=""> </span><span class="">equal</span><span class=""> </span><span class="keyword2">begin</span><span class="">
</span><span class="keyword1">definition</span><span class=""> </span><span class="">eq_finfun_def</span><span class=""> </span><span class="delimiter">[</span><span class="">code</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;HOL.equal f g &#10231; finfun_All ((&#955;(x, y). x = y) &#8728;$ ($f, g$))&quot;</span><span class="">
</span><span class="keyword1">instance</span><span class=""> </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">intro_classes</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">eq_finfun_All_ext</span><span class=""> </span><span class="">eq_finfun_def</span><span class="delimiter">)</span><span class="">
</span><span class="keyword2">end</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="delimiter">[</span><span class="">code</span><span class=""> </span><span class="">nbe</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="string">&quot;HOL.equal (f :: _ &#8658;f _) f &#10231; True&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">fact</span><span class=""> </span><span class="">equal_refl</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">subsection</span><span class=""> </span><span class="cartouche">&#8249;An operator that explicitly removes all redundant updates in the generated representations&#8250;</span><span class="">
</span><span class="">
</span><span class="keyword1">definition</span><span class=""> </span><span class="">finfun_clearjunk</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;&#39;a &#8658;f &#39;b &#8658; &#39;a &#8658;f &#39;b&quot;</span><span class="">
</span><span class="keyword2">where</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">,</span><span class=""> </span><span class="">code</span><span class=""> </span><span class="">del</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;finfun_clearjunk = id&quot;</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">finfun_clearjunk_const</span><span class=""> </span><span class="delimiter">[</span><span class="">code</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;finfun_clearjunk (K$ b) = (K$ b)&quot;</span><span class="">
</span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">finfun_clearjunk_update</span><span class=""> </span><span class="delimiter">[</span><span class="">code</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> 
</span><span class="">  </span><span class="string">&quot;finfun_clearjunk (finfun_update_code f a b) = f(a $:= b)&quot;</span><span class="">
</span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">
</span><span class="keyword1">subsection</span><span class=""> </span><span class="cartouche">&#8249;The domain of a FinFun as a FinFun&#8250;</span><span class="">
</span><span class="">
</span><span class="keyword1">definition</span><span class=""> </span><span class="">finfun_dom</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;(&#39;a &#8658;f &#39;b) &#8658; (&#39;a &#8658;f bool)&quot;</span><span class="">
</span><span class="keyword2">where</span><span class=""> </span><span class="delimiter">[</span><span class="">code</span><span class=""> </span><span class="">del</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;finfun_dom f = Abs_finfun (&#955;a. f $ a &#8800; finfun_default f)&quot;</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">finfun_dom_const</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="string">&quot;finfun_dom ((K$ c) :: &#39;a &#8658;f &#39;b) = (K$ finite (UNIV :: &#39;a set) &#8743; c &#8800; undefined)&quot;</span><span class="">
</span><span class="keyword1">unfolding</span><span class=""> </span><span class="">finfun_dom_def</span><span class=""> </span><span class="">finfun_default_const</span><span class="">
</span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">auto</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="">simp_all</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_const_def</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">text</span><span class=""> </span><span class="cartouche">&#8249;
  @{term &quot;finfun_dom&quot; } raises an exception when called on a FinFun whose domain is a finite type. 
  For such FinFuns, the default value (and as such the domain) is undefined.
&#8250;</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">finfun_dom_const_code</span><span class=""> </span><span class="delimiter">[</span><span class="">code</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="string">&quot;finfun_dom ((K$ c) :: (&#39;a :: card_UNIV) &#8658;f &#39;b) = 
   (if CARD(&#39;a) = 0 then (K$ False) else Code.abort (STR &#39;&#39;finfun_dom called on finite type&#39;&#39;) (&#955;_. finfun_dom (K$ c)))&quot;</span><span class="">
</span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_dom_const</span><span class=""> </span><span class="">card_UNIV</span><span class=""> </span><span class="">card_eq_0_iff</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">finfun_dom_finfunI</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;(&#955;a. f $ a &#8800; finfun_default f) &#8712; finfun&quot;</span><span class="">
</span><span class="keyword1">using</span><span class=""> </span><span class="">finite_finfun_default</span><span class="delimiter">[</span><span class="">of</span><span class=""> </span><span class="">f</span><span class="delimiter">]</span><span class="">
</span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_def</span><span class=""> </span><span class="">exI</span><span class="delimiter">[</span><span class="keyword2">where</span><span class=""> </span><span class="">x</span><span class="delimiter">=</span><span class="">False</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">finfun_dom_update</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="string">&quot;finfun_dom (f(a $:= b)) = (finfun_dom f)(a $:= (b &#8800; finfun_default f))&quot;</span><span class="">
</span><span class="keyword1">including</span><span class=""> </span><span class="">finfun</span><span class=""> </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">finfun_dom_def</span><span class=""> </span><span class="">finfun_update_def</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_default_update_const</span><span class=""> </span><span class="">finfun_dom_finfunI</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">fold</span><span class=""> </span><span class="">finfun_update.rep_eq</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_upd_apply</span><span class=""> </span><span class="">fun_eq_iff</span><span class=""> </span><span class="">fun_upd_def</span><span class=""> </span><span class="">finfun_default_update_const</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">done</span></span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">finfun_dom_update_code</span><span class=""> </span><span class="delimiter">[</span><span class="">code</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="string">&quot;finfun_dom (finfun_update_code f a b) = finfun_update_code (finfun_dom f) a (b &#8800; finfun_default f)&quot;</span><span class="">
</span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">simp</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">finite_finfun_dom</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;finite {x. finfun_dom f $ x}&quot;</span><span class="">
</span><span class="keyword1">proof</span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">f</span><span class=""> </span><span class="">rule</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_weak_induct</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword3">case</span><span class=""> </span><span class="delimiter">(</span><span class="">const</span><span class=""> </span><span class="">b</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword3">thus</span><span class=""> </span><span class="var">?case</span><span class="">
</span><span class="">    </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">cases</span><span class=""> </span><span class="string">&quot;finite (UNIV :: &#39;a set) &#8743; b &#8800; undefined&quot;</span><span class="delimiter">)</span><span class="">
</span><span class="">      </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_dom_const</span><span class=""> </span><span class="">UNIV_def</span><span class=""> </span><span class="delimiter">[</span><span class="">symmetric</span><span class="delimiter">]</span><span class=""> </span><span class="">Set.empty_def</span><span class=""> </span><span class="delimiter">[</span><span class="">symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1">next</span><span class="">
</span><span class="">  </span><span class="keyword3">case</span><span class=""> </span><span class="delimiter">(</span><span class="">update</span><span class=""> </span><span class="">f</span><span class=""> </span><span class="">a</span><span class=""> </span><span class="">b</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;{x. finfun_dom f(a $:= b) $ x} =
    (if b = finfun_default f then {x. finfun_dom f $ x} - {a} else insert a {x. finfun_dom f $ x})&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_upd_apply</span><span class=""> </span><span class="">split</span><span class="delimiter">:</span><span class=""> </span><span class="">split_if_asm</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword3">thus</span><span class=""> </span><span class="var">?case</span><span class=""> </span><span class="keyword1">using</span><span class=""> </span><span class="">update</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="">
</span><span class="keyword1">subsection</span><span class=""> </span><span class="cartouche">&#8249;The domain of a FinFun as a sorted list&#8250;</span><span class="">
</span><span class="">
</span><span class="keyword1">definition</span><span class=""> </span><span class="">finfun_to_list</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;(&#39;a :: linorder) &#8658;f &#39;b &#8658; &#39;a list&quot;</span><span class="">
</span><span class="keyword2">where</span><span class="">
</span><span class="">  </span><span class="string">&quot;finfun_to_list f = (THE xs. set xs = {x. finfun_dom f $ x} &#8743; sorted xs &#8743; distinct xs)&quot;</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">set_finfun_to_list</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;set (finfun_to_list f) = {x. finfun_dom f $ x}&quot;</span><span class=""> </span><span class="delimiter">(</span><span class="keyword2">is</span><span class=""> </span><span class="var">?thesis1</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword2">and</span><span class=""> </span><span class="">sorted_finfun_to_list</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;sorted (finfun_to_list f)&quot;</span><span class=""> </span><span class="delimiter">(</span><span class="keyword2">is</span><span class=""> </span><span class="var">?thesis2</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword2">and</span><span class=""> </span><span class="">distinct_finfun_to_list</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;distinct (finfun_to_list f)&quot;</span><span class=""> </span><span class="delimiter">(</span><span class="keyword2">is</span><span class=""> </span><span class="var">?thesis3</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1">proof</span><span class=""> </span><span class="delimiter">(</span><span class="">atomize</span><span class=""> </span><span class="delimiter">(</span><span class="">full</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;?thesis1 &#8743; ?thesis2 &#8743; ?thesis3&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">finfun_to_list_def</span><span class="">
</span><span class="">    </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">theI&#39;</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">finite_sorted_distinct_unique</span><span class=""> </span><span class="">finite_finfun_dom</span><span class="delimiter">)</span><span class="delimiter">+</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">finfun_const_False_conv_bot</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;op $ (K$ False) = bot&quot;</span><span class="">
</span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">finfun_const_True_conv_top</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;op $ (K$ True) = top&quot;</span><span class="">
</span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">finfun_to_list_const</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="string">&quot;finfun_to_list ((K$ c) :: (&#39;a :: {linorder} &#8658;f &#39;b)) = 
  (if &#172; finite (UNIV :: &#39;a set) &#8744; c = undefined then [] else THE xs. set xs = UNIV &#8743; sorted xs &#8743; distinct xs)&quot;</span><span class="">
</span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_to_list_def</span><span class=""> </span><span class="">finfun_const_False_conv_bot</span><span class=""> </span><span class="">finfun_const_True_conv_top</span><span class=""> </span><span class="">finfun_dom_const</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">finfun_to_list_const_code</span><span class=""> </span><span class="delimiter">[</span><span class="">code</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="string">&quot;finfun_to_list ((K$ c) :: (&#39;a :: {linorder, card_UNIV} &#8658;f &#39;b)) =
   (if CARD(&#39;a) = 0 then [] else Code.abort (STR &#39;&#39;finfun_to_list called on finite type&#39;&#39;) (&#955;_. finfun_to_list ((K$ c) :: (&#39;a &#8658;f &#39;b))))&quot;</span><span class="">
</span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_to_list_const</span><span class=""> </span><span class="">card_UNIV</span><span class=""> </span><span class="">card_eq_0_iff</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">remove1_insort_insert_same</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="string">&quot;x &#8713; set xs &#10233; remove1 x (insort_insert x xs) = xs&quot;</span><span class="">
</span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">metis</span><span class=""> </span><span class="">insort_insert_insort</span><span class=""> </span><span class="">remove1_insort</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">finfun_dom_conv</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="string">&quot;finfun_dom f $ x &#10231; f $ x &#8800; finfun_default f&quot;</span><span class="">
</span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">f</span><span class=""> </span><span class="">rule</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_weak_induct</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_dom_const</span><span class=""> </span><span class="">finfun_default_const</span><span class=""> </span><span class="">finfun_default_update_const</span><span class=""> </span><span class="">finfun_upd_apply</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">finfun_to_list_update</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="string">&quot;finfun_to_list (f(a $:= b)) = 
  (if b = finfun_default f then List.remove1 a (finfun_to_list f) else List.insort_insert a (finfun_to_list f))&quot;</span><span class="">
</span><span class="keyword1">proof</span><span class="delimiter">(</span><span class="">subst</span><span class=""> </span><span class="">finfun_to_list_def</span><span class="delimiter">,</span><span class=""> </span><span class="">rule</span><span class=""> </span><span class="">the_equality</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword3">fix</span><span class=""> </span><span class="">xs</span><span class="">
</span><span class="">  </span><span class="keyword3">assume</span><span class=""> </span><span class="string">&quot;set xs = {x. finfun_dom f(a $:= b) $ x} &#8743; sorted xs &#8743; distinct xs&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">hence</span><span class=""> </span><span class="">eq</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;set xs = {x. finfun_dom f(a $:= b) $ x}&quot;</span><span class="">
</span><span class="">    </span><span class="keyword2">and</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;sorted xs&quot;</span><span class=""> </span><span class="string">&quot;distinct xs&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp_all</span><span class="">
</span><span class="">  </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;xs = (if b = finfun_default f then remove1 a (finfun_to_list f) else insort_insert a (finfun_to_list f))&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">proof</span><span class="delimiter">(</span><span class="">cases</span><span class=""> </span><span class="string">&quot;b = finfun_default f&quot;</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword3">case</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="">True</span><span class="">
</span><span class="">    </span><span class="keyword3">show</span><span class=""> </span><span class="var">?thesis</span><span class="">
</span><span class="">    </span><span class="keyword1">proof</span><span class="delimiter">(</span><span class="">cases</span><span class=""> </span><span class="string">&quot;finfun_dom f $ a&quot;</span><span class="delimiter">)</span><span class="">
</span><span class="">      </span><span class="keyword3">case</span><span class=""> </span><span class="">True</span><span class="">
</span><span class="">      </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;finfun_to_list f = insort_insert a xs&quot;</span><span class="">
</span><span class="">        </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">finfun_to_list_def</span><span class="">
</span><span class="">      </span><span class="keyword1">proof</span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">the_equality</span><span class="delimiter">)</span><span class="">
</span><span class="">        </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;set (insort_insert a xs) = insert a (set xs)&quot;</span><span class=""> </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">set_insort_insert</span><span class="delimiter">)</span><span class="">
</span><span class="">        </span><span class="keyword1">also</span><span class=""> </span><span class="keyword1">note</span><span class=""> </span><span class="">eq</span><span class=""> </span><span class="keyword1">also</span><span class="">
</span><span class="">        </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;insert a {x. finfun_dom f(a $:= b) $ x} = {x. finfun_dom f $ x}&quot;</span><span class=""> </span><span class="keyword1">using</span><span class=""> </span><span class="">True</span><span class="">
</span><span class="">          </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_upd_apply</span><span class=""> </span><span class="">split</span><span class="delimiter">:</span><span class=""> </span><span class="">split_if_asm</span><span class="delimiter">)</span><span class="">
</span><span class="">        </span><span class="keyword1">finally</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="">1</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;set (insort_insert a xs) = {x. finfun_dom f $ x} &#8743; sorted (insort_insert a xs) &#8743; distinct (insort_insert a xs)&quot;</span><span class="">
</span><span class="">          </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">sorted_insort_insert</span><span class=""> </span><span class="">distinct_insort_insert</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="">        </span><span class="keyword3">fix</span><span class=""> </span><span class="">xs&#39;</span><span class="">
</span><span class="">        </span><span class="keyword3">assume</span><span class=""> </span><span class="string">&quot;set xs&#39; = {x. finfun_dom f $ x} &#8743; sorted xs&#39; &#8743; distinct xs&#39;&quot;</span><span class="">
</span><span class="">        </span><span class="keyword3">thus</span><span class=""> </span><span class="string">&quot;xs&#39; = insort_insert a xs&quot;</span><span class=""> </span><span class="keyword1">using</span><span class=""> </span><span class="">1</span><span class=""> </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">dest</span><span class="delimiter">:</span><span class=""> </span><span class="">sorted_distinct_set_unique</span><span class="delimiter">)</span><span class="">
</span><span class="">      </span><span class="keyword1">qed</span><span class="">
</span><span class="">      </span><span class="keyword1">with</span><span class=""> </span><span class="">eq</span><span class=""> </span><span class="">True</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="var">?thesis</span><span class=""> </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">remove1_insort_insert_same</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1">next</span><span class="">
</span><span class="">      </span><span class="keyword3">case</span><span class=""> </span><span class="">False</span><span class="">
</span><span class="">      </span><span class="keyword1">hence</span><span class=""> </span><span class="string">&quot;f $ a = b&quot;</span><span class=""> </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_dom_conv</span><span class="delimiter">)</span><span class="">
</span><span class="">      </span><span class="keyword1">hence</span><span class=""> </span><span class="">f</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;f(a $:= b) = f&quot;</span><span class=""> </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">expand_finfun_eq</span><span class=""> </span><span class="">fun_eq_iff</span><span class=""> </span><span class="">finfun_upd_apply</span><span class="delimiter">)</span><span class="">
</span><span class="">      </span><span class="keyword1">from</span><span class=""> </span><span class="">eq</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;finfun_to_list f = xs&quot;</span><span class=""> </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">f</span><span class=""> </span><span class="">finfun_to_list_def</span><span class="">
</span><span class="">        </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">elim</span><span class="delimiter">:</span><span class=""> </span><span class="">sorted_distinct_set_unique</span><span class=""> </span><span class="">intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span class=""> </span><span class="">the_equality</span><span class="delimiter">)</span><span class="">
</span><span class="">      </span><span class="keyword1">with</span><span class=""> </span><span class="">eq</span><span class=""> </span><span class="">False</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="var">?thesis</span><span class=""> </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">f</span><span class=""> </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">remove1_idem</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1">qed</span><span class="">
</span><span class="">  </span><span class="keyword1">next</span><span class="">
</span><span class="">    </span><span class="keyword3">case</span><span class=""> </span><span class="">False</span><span class="">
</span><span class="">    </span><span class="keyword3">show</span><span class=""> </span><span class="var">?thesis</span><span class="">
</span><span class="">    </span><span class="keyword1">proof</span><span class="delimiter">(</span><span class="">cases</span><span class=""> </span><span class="string">&quot;finfun_dom f $ a&quot;</span><span class="delimiter">)</span><span class="">
</span><span class="">      </span><span class="keyword3">case</span><span class=""> </span><span class="">True</span><span class="">
</span><span class="">      </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;finfun_to_list f = xs&quot;</span><span class="">
</span><span class="">        </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">finfun_to_list_def</span><span class="">
</span><span class="">      </span><span class="keyword1">proof</span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">the_equality</span><span class="delimiter">)</span><span class="">
</span><span class="">        </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;finfun_dom f = finfun_dom f(a $:= b)&quot;</span><span class=""> </span><span class="keyword1">using</span><span class=""> </span><span class="">False</span><span class=""> </span><span class="">True</span><span class="">
</span><span class="">          </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">expand_finfun_eq</span><span class=""> </span><span class="">fun_eq_iff</span><span class=""> </span><span class="">finfun_upd_apply</span><span class="delimiter">)</span><span class="">
</span><span class="">        </span><span class="keyword1">with</span><span class=""> </span><span class="">eq</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="">1</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;set xs = {x. finfun_dom f $ x} &#8743; sorted xs &#8743; distinct xs&quot;</span><span class="">
</span><span class="">          </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">del</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_dom_update</span><span class="delimiter">)</span><span class="">
</span><span class="">        
</span><span class="">        </span><span class="keyword3">fix</span><span class=""> </span><span class="">xs&#39;</span><span class="">
</span><span class="">        </span><span class="keyword3">assume</span><span class=""> </span><span class="string">&quot;set xs&#39; = {x. finfun_dom f $ x} &#8743; sorted xs&#39; &#8743; distinct xs&#39;&quot;</span><span class="">
</span><span class="">        </span><span class="keyword3">thus</span><span class=""> </span><span class="string">&quot;xs&#39; = xs&quot;</span><span class=""> </span><span class="keyword1">using</span><span class=""> </span><span class="">1</span><span class=""> </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">elim</span><span class="delimiter">:</span><span class=""> </span><span class="">sorted_distinct_set_unique</span><span class="delimiter">)</span><span class="">
</span><span class="">      </span><span class="keyword1">qed</span><span class="">
</span><span class="">      </span><span class="keyword3">thus</span><span class=""> </span><span class="var">?thesis</span><span class=""> </span><span class="keyword1">using</span><span class=""> </span><span class="">False</span><span class=""> </span><span class="">True</span><span class=""> </span><span class="">eq</span><span class=""> </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">insort_insert_triv</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1">next</span><span class="">
</span><span class="">      </span><span class="keyword3">case</span><span class=""> </span><span class="">False</span><span class="">
</span><span class="">      </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;finfun_to_list f = remove1 a xs&quot;</span><span class="">
</span><span class="">        </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">finfun_to_list_def</span><span class="">
</span><span class="">      </span><span class="keyword1">proof</span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">the_equality</span><span class="delimiter">)</span><span class="">
</span><span class="">        </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;set (remove1 a xs) = set xs - {a}&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">        </span><span class="keyword1">also</span><span class=""> </span><span class="keyword1">note</span><span class=""> </span><span class="">eq</span><span class=""> </span><span class="keyword1">also</span><span class="">
</span><span class="">        </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;{x. finfun_dom f(a $:= b) $ x} - {a} = {x. finfun_dom f $ x}&quot;</span><span class=""> </span><span class="keyword1">using</span><span class=""> </span><span class="">False</span><span class="">
</span><span class="">          </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_upd_apply</span><span class=""> </span><span class="">split</span><span class="delimiter">:</span><span class=""> </span><span class="">split_if_asm</span><span class="delimiter">)</span><span class="">
</span><span class="">        </span><span class="keyword1">finally</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="">1</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;set (remove1 a xs) = {x. finfun_dom f $ x} &#8743; sorted (remove1 a xs) &#8743; distinct (remove1 a xs)&quot;</span><span class="">
</span><span class="">          </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">sorted_remove1</span><span class="delimiter">)</span><span class="">
</span><span class="">        
</span><span class="">        </span><span class="keyword3">fix</span><span class=""> </span><span class="">xs&#39;</span><span class="">
</span><span class="">        </span><span class="keyword3">assume</span><span class=""> </span><span class="string">&quot;set xs&#39; = {x. finfun_dom f $ x} &#8743; sorted xs&#39; &#8743; distinct xs&#39;&quot;</span><span class="">
</span><span class="">        </span><span class="keyword3">thus</span><span class=""> </span><span class="string">&quot;xs&#39; = remove1 a xs&quot;</span><span class=""> </span><span class="keyword1">using</span><span class=""> </span><span class="">1</span><span class=""> </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">blast</span><span class=""> </span><span class="">intro</span><span class="delimiter">:</span><span class=""> </span><span class="">sorted_distinct_set_unique</span><span class="delimiter">)</span><span class="">
</span><span class="">      </span><span class="keyword1">qed</span><span class="">
</span><span class="">      </span><span class="keyword3">thus</span><span class=""> </span><span class="var">?thesis</span><span class=""> </span><span class="keyword1">using</span><span class=""> </span><span class="">False</span><span class=""> </span><span class="">eq</span><span class=""> </span><span class="cartouche">&#8249;b &#8800; finfun_default f&#8250;</span><span class=""> 
</span><span class="">        </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">insort_insert_insort</span><span class=""> </span><span class="">insort_remove1</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1">qed</span><span class="">
</span><span class="">  </span><span class="keyword1">qed</span><span class="">
</span><span class="keyword1">qed</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">distinct_finfun_to_list</span><span class=""> </span><span class="">sorted_finfun_to_list</span><span class=""> </span><span class="">sorted_remove1</span><span class=""> </span><span class="">set_insort_insert</span><span class=""> </span><span class="">sorted_insort_insert</span><span class=""> </span><span class="">distinct_insort_insert</span><span class=""> </span><span class="">finfun_upd_apply</span><span class=""> </span><span class="">split</span><span class="delimiter">:</span><span class=""> </span><span class="">split_if_asm</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">finfun_to_list_update_code</span><span class=""> </span><span class="delimiter">[</span><span class="">code</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="string">&quot;finfun_to_list (finfun_update_code f a b) = 
  (if b = finfun_default f then List.remove1 a (finfun_to_list f) else List.insort_insert a (finfun_to_list f))&quot;</span><span class="">
</span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_to_list_update</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">text</span><span class=""> </span><span class="cartouche">&#8249;More type class instantiations&#8250;</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">card_eq_1_iff</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;card A = 1 &#10231; A &#8800; {} &#8743; (&#8704;x&#8712;A. &#8704;y&#8712;A. x = y)&quot;</span><span class="">
</span><span class="">  </span><span class="delimiter">(</span><span class="keyword2">is</span><span class=""> </span><span class="string">&quot;?lhs &#10231; ?rhs&quot;</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1">proof</span><span class="">
</span><span class="">  </span><span class="keyword3">assume</span><span class=""> </span><span class="var">?lhs</span><span class="">
</span><span class="">  </span><span class="keyword1">moreover</span><span class=""> </span><span class="keyword1">{</span><span class="">
</span><span class="">    </span><span class="keyword3">fix</span><span class=""> </span><span class="">x</span><span class=""> </span><span class="">y</span><span class="">
</span><span class="">    </span><span class="keyword3">assume</span><span class=""> </span><span class="">A</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;x &#8712; A&quot;</span><span class=""> </span><span class="string">&quot;y &#8712; A&quot;</span><span class=""> </span><span class="keyword2">and</span><span class=""> </span><span class="">neq</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;x &#8800; y&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;finite A&quot;</span><span class=""> </span><span class="keyword1">using</span><span class=""> </span><span class="cartouche">&#8249;?lhs&#8250;</span><span class=""> </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">card_ge_0_finite</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1">from</span><span class=""> </span><span class="">neq</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;2 = card {x, y}&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">    </span><span class="keyword1">also</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;&#8230; &#8804; card A&quot;</span><span class=""> </span><span class="keyword1">using</span><span class=""> </span><span class="">A</span><span class=""> </span><span class="cartouche">&#8249;finite A&#8250;</span><span class="">
</span><span class="">      </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">intro</span><span class="delimiter">:</span><span class=""> </span><span class="">card_mono</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1">finally</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="">False</span><span class=""> </span><span class="keyword1">using</span><span class=""> </span><span class="cartouche">&#8249;?lhs&#8250;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="keyword1">}</span><span class="">
</span><span class="">  </span><span class="keyword1">ultimately</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="var">?rhs</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="keyword1">next</span><span class="">
</span><span class="">  </span><span class="keyword3">assume</span><span class=""> </span><span class="var">?rhs</span><span class="">
</span><span class="">  </span><span class="keyword1">hence</span><span class=""> </span><span class="string">&quot;A = {THE x. x &#8712; A}&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">by</span><span class=""> </span><span class="">safe</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">intro</span><span class="delimiter">:</span><span class=""> </span><span class="">theI</span><span class=""> </span><span class="">the_equality</span><span class="delimiter">[</span><span class="">symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">also</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;card &#8230; = 1&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">  </span><span class="keyword1">finally</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="var">?lhs</span><span class=""> </span><span class="keyword1">.</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">card_UNIV_finfun</span><span class="delimiter">:</span><span class=""> 
</span><span class="">  </span><span class="keyword2">defines</span><span class=""> </span><span class="string">&quot;F == finfun :: (&#39;a &#8658; &#39;b) set&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;CARD(&#39;a &#8658;f &#39;b) = (if CARD(&#39;a) &#8800; 0 &#8743; CARD(&#39;b) &#8800; 0 &#8744; CARD(&#39;b) = 1 then CARD(&#39;b) ^ CARD(&#39;a) else 0)&quot;</span><span class="">
</span><span class="keyword1">proof</span><span class="delimiter">(</span><span class="">cases</span><span class=""> </span><span class="string">&quot;0 &lt; CARD(&#39;a) &#8743; 0 &lt; CARD(&#39;b) &#8744; CARD(&#39;b) = 1&quot;</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword3">case</span><span class=""> </span><span class="">True</span><span class="">
</span><span class="">  </span><span class="keyword1">from</span><span class=""> </span><span class="">True</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;F = UNIV&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">proof</span><span class="">
</span><span class="">    </span><span class="keyword3">assume</span><span class=""> </span><span class="">b</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;CARD(&#39;b) = 1&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">hence</span><span class=""> </span><span class="string">&quot;&#8704;x :: &#39;b. x = undefined&quot;</span><span class="">
</span><span class="">      </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">card_eq_1_iff</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">del</span><span class="delimiter">:</span><span class=""> </span><span class="">One_nat_def</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword3">thus</span><span class=""> </span><span class="var">?thesis</span><span class=""> </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_def</span><span class=""> </span><span class="">F_def</span><span class=""> </span><span class="">intro</span><span class="delimiter">:</span><span class=""> </span><span class="">exI</span><span class="delimiter">[</span><span class="keyword2">where</span><span class=""> </span><span class="">x</span><span class="delimiter">=</span><span class="">undefined</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">qed</span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_def</span><span class=""> </span><span class="">card_gt_0_iff</span><span class=""> </span><span class="">F_def</span><span class=""> </span><span class="">intro</span><span class="delimiter">:</span><span class=""> </span><span class="">finite_subset</span><span class="delimiter">[</span><span class="keyword2">where</span><span class=""> </span><span class="">B</span><span class="delimiter">=</span><span class="">UNIV</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">moreover</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;CARD(&#39;a &#8658;f &#39;b) = card F&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">type_definition.Abs_image</span><span class="delimiter">[</span><span class="">OF</span><span class=""> </span><span class="">type_definition_finfun</span><span class="delimiter">,</span><span class=""> </span><span class="">symmetric</span><span class="delimiter">]</span><span class="">
</span><span class="">    </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span class=""> </span><span class="">card_image</span><span class=""> </span><span class="">inj_onI</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">Abs_finfun_inject</span><span class=""> </span><span class="">F_def</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">ultimately</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="var">?thesis</span><span class=""> </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">card_fun</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1">next</span><span class="">
</span><span class="">  </span><span class="keyword3">case</span><span class=""> </span><span class="">False</span><span class="">
</span><span class="">  </span><span class="keyword1">hence</span><span class=""> </span><span class="">infinite</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;&#172; (finite (UNIV :: &#39;a set) &#8743; finite (UNIV :: &#39;b set))&quot;</span><span class="">
</span><span class="">    </span><span class="keyword2">and</span><span class=""> </span><span class="">b</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;CARD(&#39;b) &#8800; 1&quot;</span><span class=""> </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">simp_all</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">card_eq_0_iff</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">from</span><span class=""> </span><span class="">b</span><span class=""> </span><span class="keyword3">obtain</span><span class=""> </span><span class="">b1</span><span class=""> </span><span class="">b2</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="tfree">&#39;b</span><span class=""> </span><span class="keyword2">where</span><span class=""> </span><span class="string">&quot;b1 &#8800; b2&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">card_eq_1_iff</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">del</span><span class="delimiter">:</span><span class=""> </span><span class="">One_nat_def</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">let</span><span class=""> </span><span class="var">?f</span><span class=""> </span><span class="delimiter">=</span><span class=""> </span><span class="string">&quot;&#955;a a&#39; :: &#39;a. if a = a&#39; then b1 else b2&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">from</span><span class=""> </span><span class="">infinite</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;&#172; finite (UNIV :: (&#39;a &#8658;f &#39;b) set)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">proof</span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">contrapos_nn</span><span class="delimiter">[</span><span class="">OF</span><span class=""> </span><span class="">_</span><span class=""> </span><span class="">conjI</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword3">assume</span><span class=""> </span><span class="">finite</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;finite (UNIV :: (&#39;a &#8658;f &#39;b) set)&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">hence</span><span class=""> </span><span class="string">&quot;finite F&quot;</span><span class="">
</span><span class="">      </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">type_definition.Abs_image</span><span class="delimiter">[</span><span class="">OF</span><span class=""> </span><span class="">type_definition_finfun</span><span class="delimiter">,</span><span class=""> </span><span class="">symmetric</span><span class="delimiter">]</span><span class=""> </span><span class="">F_def</span><span class="">
</span><span class="">      </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">finite_imageD</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">intro</span><span class="delimiter">:</span><span class=""> </span><span class="">inj_onI</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">Abs_finfun_inject</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1">hence</span><span class=""> </span><span class="string">&quot;finite (range ?f)&quot;</span><span class=""> 
</span><span class="">      </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">finite_subset</span><span class="delimiter">[</span><span class="">rotated</span><span class=""> </span><span class="">1</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">F_def</span><span class=""> </span><span class="">finfun_def</span><span class=""> </span><span class="cartouche">&#8249;b1 &#8800; b2&#8250;</span><span class=""> </span><span class="">intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span class=""> </span><span class="">exI</span><span class="delimiter">[</span><span class="keyword2">where</span><span class=""> </span><span class="">x</span><span class="delimiter">=</span><span class="">b2</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword3">thus</span><span class=""> </span><span class="string">&quot;finite (UNIV :: &#39;a set)&quot;</span><span class="">
</span><span class="">      </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">finite_imageD</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">intro</span><span class="delimiter">:</span><span class=""> </span><span class="">inj_onI</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">fun_eq_iff</span><span class=""> </span><span class="cartouche">&#8249;b1 &#8800; b2&#8250;</span><span class=""> </span><span class="">split</span><span class="delimiter">:</span><span class=""> </span><span class="">split_if_asm</span><span class="delimiter">)</span><span class="">
</span><span class="">    
</span><span class="">    </span><span class="keyword1">from</span><span class=""> </span><span class="">finite</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;finite (range (&#955;b. ((K$ b) :: &#39;a &#8658;f &#39;b)))&quot;</span><span class="">
</span><span class="">      </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">finite_subset</span><span class="delimiter">[</span><span class="">rotated</span><span class=""> </span><span class="">1</span><span class="delimiter">]</span><span class="delimiter">)</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">    </span><span class="keyword3">thus</span><span class=""> </span><span class="string">&quot;finite (UNIV :: &#39;b set)&quot;</span><span class="">
</span><span class="">      </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">finite_imageD</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span class=""> </span><span class="">inj_onI</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">qed</span><span class="">
</span><span class="">  </span><span class="keyword1">with</span><span class=""> </span><span class="">False</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="var">?thesis</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">finite_UNIV_finfun</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="string">&quot;finite (UNIV :: (&#39;a &#8658;f &#39;b) set) &#10231;
  (finite (UNIV :: &#39;a set) &#8743; finite (UNIV :: &#39;b set) &#8744; CARD(&#39;b) = 1)&quot;</span><span class="">
</span><span class="">  </span><span class="delimiter">(</span><span class="keyword2">is</span><span class=""> </span><span class="string">&quot;?lhs &#10231; ?rhs&quot;</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1">proof</span><span class=""> </span><span class="">-</span><span class="">
</span><span class="">  </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;?lhs &#10231; CARD(&#39;a &#8658;f &#39;b) &gt; 0&quot;</span><span class=""> </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">card_gt_0_iff</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">also</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;&#8230; &#10231; CARD(&#39;a) &gt; 0 &#8743; CARD(&#39;b) &gt; 0 &#8744; CARD(&#39;b) = 1&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">card_UNIV_finfun</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">also</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;&#8230; = ?rhs&quot;</span><span class=""> </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">card_gt_0_iff</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">finally</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="var">?thesis</span><span class=""> </span><span class="keyword1">.</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="keyword1">instantiation</span><span class=""> </span><span class="">finfun</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="delimiter">(</span><span class="">finite_UNIV</span><span class="delimiter">,</span><span class=""> </span><span class="">card_UNIV</span><span class="delimiter">)</span><span class=""> </span><span class="">finite_UNIV</span><span class=""> </span><span class="keyword2">begin</span><span class="">
</span><span class="keyword1">definition</span><span class=""> </span><span class="string">&quot;finite_UNIV = Phantom(&#39;a &#8658;f &#39;b)
  (let cb = of_phantom (card_UNIV :: &#39;b card_UNIV)
   in cb = 1 &#8744; of_phantom (finite_UNIV :: &#39;a finite_UNIV) &#8743; cb &#8800; 0)&quot;</span><span class="">
</span><span class="keyword1">instance</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="">intro_classes</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">finite_UNIV_finfun_def</span><span class=""> </span><span class="">Let_def</span><span class=""> </span><span class="">card_UNIV</span><span class=""> </span><span class="">finite_UNIV</span><span class=""> </span><span class="">finite_UNIV_finfun</span><span class=""> </span><span class="">card_gt_0_iff</span><span class="delimiter">)</span><span class="">
</span><span class="keyword2">end</span><span class="">
</span><span class="">
</span><span class="keyword1">instantiation</span><span class=""> </span><span class="">finfun</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="delimiter">(</span><span class="">card_UNIV</span><span class="delimiter">,</span><span class=""> </span><span class="">card_UNIV</span><span class="delimiter">)</span><span class=""> </span><span class="">card_UNIV</span><span class=""> </span><span class="keyword2">begin</span><span class="">
</span><span class="keyword1">definition</span><span class=""> </span><span class="string">&quot;card_UNIV = Phantom(&#39;a &#8658;f &#39;b)
  (let ca = of_phantom (card_UNIV :: &#39;a card_UNIV);
       cb = of_phantom (card_UNIV :: &#39;b card_UNIV)
   in if ca &#8800; 0 &#8743; cb &#8800; 0 &#8744; cb = 1 then cb ^ ca else 0)&quot;</span><span class="">
</span><span class="keyword1">instance</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">intro_classes</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">card_UNIV_finfun_def</span><span class=""> </span><span class="">card_UNIV</span><span class=""> </span><span class="">Let_def</span><span class=""> </span><span class="">card_UNIV_finfun</span><span class="delimiter">)</span><span class="">
</span><span class="keyword2">end</span><span class="">
</span><span class="">
</span><span class="keyword1">text</span><span class=""> </span><span class="cartouche">&#8249;Deactivate syntax again. Import theory &#8249;FinFun_Syntax&#8250; to reactivate it again&#8250;</span><span class="">
</span><span class="">
</span><span class="keyword1">no_type_notation</span><span class="">
</span><span class="">  </span><span class="">finfun</span><span class=""> </span><span class="delimiter">(</span><span class="string">&quot;(_ &#8658;f /_)&quot;</span><span class=""> </span><span class="delimiter">[</span><span class="">22</span><span class="delimiter">,</span><span class=""> </span><span class="">21</span><span class="delimiter">]</span><span class=""> </span><span class="">21</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">no_notation</span><span class="">
</span><span class="">  </span><span class="">finfun_const</span><span class=""> </span><span class="delimiter">(</span><span class="string">&quot;K$/ _&quot;</span><span class=""> </span><span class="delimiter">[</span><span class="">0</span><span class="delimiter">]</span><span class=""> </span><span class="">1</span><span class="delimiter">)</span><span class=""> </span><span class="keyword2">and</span><span class="">
</span><span class="">  </span><span class="">finfun_update</span><span class=""> </span><span class="delimiter">(</span><span class="string">&quot;_&#39;(_ $:= _&#39;)&quot;</span><span class=""> </span><span class="delimiter">[</span><span class="">1000</span><span class="delimiter">,</span><span class="">0</span><span class="delimiter">,</span><span class="">0</span><span class="delimiter">]</span><span class=""> </span><span class="">1000</span><span class="delimiter">)</span><span class=""> </span><span class="keyword2">and</span><span class="">
</span><span class="">  </span><span class="">finfun_apply</span><span class=""> </span><span class="delimiter">(</span><span class="keyword2">infixl</span><span class=""> </span><span class="string">&quot;$&quot;</span><span class=""> </span><span class="">999</span><span class="delimiter">)</span><span class=""> </span><span class="keyword2">and</span><span class="">
</span><span class="">  </span><span class="">finfun_comp</span><span class=""> </span><span class="delimiter">(</span><span class="keyword2">infixr</span><span class=""> </span><span class="string">&quot;&#8728;$&quot;</span><span class=""> </span><span class="">55</span><span class="delimiter">)</span><span class=""> </span><span class="keyword2">and</span><span class="">
</span><span class="">  </span><span class="">finfun_comp2</span><span class=""> </span><span class="delimiter">(</span><span class="keyword2">infixr</span><span class=""> </span><span class="string">&quot;$&#8728;&quot;</span><span class=""> </span><span class="">55</span><span class="delimiter">)</span><span class=""> </span><span class="keyword2">and</span><span class="">
</span><span class="">  </span><span class="">finfun_Diag</span><span class=""> </span><span class="delimiter">(</span><span class="string">&quot;(1&#39;($_,/ _$&#39;))&quot;</span><span class=""> </span><span class="delimiter">[</span><span class="">0</span><span class="delimiter">,</span><span class=""> </span><span class="">0</span><span class="delimiter">]</span><span class=""> </span><span class="">1000</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">no_notation</span><span class=""> </span><span class="delimiter">(</span><span class="">ASCII</span><span class="delimiter">)</span><span class=""> 
</span><span class="">  </span><span class="">finfun_comp</span><span class=""> </span><span class="delimiter">(</span><span class="keyword2">infixr</span><span class=""> </span><span class="string">&quot;o$&quot;</span><span class=""> </span><span class="">55</span><span class="delimiter">)</span><span class=""> </span><span class="keyword2">and</span><span class="">
</span><span class="">  </span><span class="">finfun_comp2</span><span class=""> </span><span class="delimiter">(</span><span class="keyword2">infixr</span><span class=""> </span><span class="string">&quot;$o&quot;</span><span class=""> </span><span class="">55</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword2">end</span><span class="">
</span></pre>

</div>
</body>
</html>
