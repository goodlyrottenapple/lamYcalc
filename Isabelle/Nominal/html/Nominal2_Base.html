<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>Theory Nominal2_Base (Isabelle2016: February 2016)</title>
<link media="all" rel="stylesheet" type="text/css" href="isabelle.css"/>
</head>

<body>
<div class="head"><h1>Theory Nominal2_Base</h1>

<span class="command">theory</span> <span class="name">Nominal2_Base</span><br/>
<span class="keyword">imports</span> <a href="Old_Datatype.html"><span class="name">Old_Datatype</span></a> <a href="Infinite_Set.html"><span class="name">Infinite_Set</span></a> <a href="FSet.html"><span class="name">FSet</span></a> <a href="FinFun.html"><span class="name">FinFun</span></a><br/>

</div>
<div class="source">
<pre class="source"><span class="comment">(*  Title:      Nominal2_Base
    Authors:    Christian Urban, Brian Huffman, Cezary Kaliszyk

    Basic definitions and lemma infrastructure for 
    Nominal Isabelle. 
*)</span><span class="">
</span><span class="keyword1">theory</span><span class=""> </span><span class="">Nominal2_Base</span><span class="">
</span><span class="keyword2">imports</span><span class=""> </span><span class="string">&quot;~~/src/HOL/Library/Old_Datatype&quot;</span><span class="">
</span><span class="">        </span><span class="string">&quot;~~/src/HOL/Library/Infinite_Set&quot;</span><span class="">
</span><span class="">        </span><span class="string">&quot;~~/src/HOL/Quotient_Examples/FSet&quot;</span><span class="">
</span><span class="">        </span><span class="string">&quot;~~/src/HOL/Library/FinFun&quot;</span><span class="">
</span><span class="keyword2">keywords</span><span class="">
</span><span class="">  </span><span class="string">&quot;atom_decl&quot;</span><span class=""> </span><span class="string">&quot;equivariance&quot;</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="">thy_decl</span><span class=""> 
</span><span class="keyword2">begin</span><span class="">
</span><span class="">
</span><span class="keyword1">declare</span><span class=""> </span><span class="delimiter">[</span><span class="delimiter">[</span><span class="">typedef_overloaded</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="">
</span><span class="">
</span><span class="">
</span><span class="keyword1">section</span><span class=""> </span><span class="verbatim">{* Atoms and Sorts *}</span><span class="">
</span><span class="">
</span><span class="keyword1">text</span><span class=""> </span><span class="verbatim">{* A simple implementation for atom_sorts is strings. *}</span><span class="">
</span><span class="comment">(* types atom_sort = string *)</span><span class="">
</span><span class="">
</span><span class="keyword1">text</span><span class=""> </span><span class="verbatim">{* To deal with Church-like binding we use trees of  
  strings as sorts. *}</span><span class="">
</span><span class="">
</span><span class="keyword1">datatype</span><span class=""> </span><span class="">atom_sort</span><span class=""> </span><span class="delimiter">=</span><span class=""> </span><span class="">Sort</span><span class=""> </span><span class="string">&quot;string&quot;</span><span class=""> </span><span class="string">&quot;atom_sort list&quot;</span><span class="">
</span><span class="">
</span><span class="keyword1">datatype</span><span class=""> </span><span class="">atom</span><span class=""> </span><span class="delimiter">=</span><span class=""> </span><span class="">Atom</span><span class=""> </span><span class="">atom_sort</span><span class=""> </span><span class="">nat</span><span class="">
</span><span class="">
</span><span class="">
</span><span class="keyword1">text</span><span class=""> </span><span class="verbatim">{* Basic projection function. *}</span><span class="">
</span><span class="">
</span><span class="keyword1">primrec</span><span class="">
</span><span class="">  </span><span class="">sort_of</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;atom &#8658; atom_sort&quot;</span><span class="">
</span><span class="keyword2">where</span><span class="">
</span><span class="">  </span><span class="string">&quot;sort_of (Atom s n) = s&quot;</span><span class="">
</span><span class="">
</span><span class="keyword1">primrec</span><span class="">
</span><span class="">  </span><span class="">nat_of</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;atom &#8658; nat&quot;</span><span class="">
</span><span class="keyword2">where</span><span class="">
</span><span class="">  </span><span class="string">&quot;nat_of (Atom s n) = n&quot;</span><span class="">
</span><span class="">
</span><span class="">
</span><span class="keyword1">text</span><span class=""> </span><span class="verbatim">{* There are infinitely many atoms of each sort. *}</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">INFM_sort_of_eq</span><span class="delimiter">:</span><span class=""> 
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;INFM a. sort_of a = s&quot;</span><span class="">
</span><span class="keyword1">proof</span><span class=""> </span><span class="">-</span><span class="">
</span><span class="">  </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;INFM i. sort_of (Atom s i) = s&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">  </span><span class="keyword1">moreover</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;inj (Atom s)&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">inj_on_def</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">ultimately</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;INFM a. sort_of a = s&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">INFM_inj</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">infinite_sort_of_eq</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;infinite {a. sort_of a = s}&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">using</span><span class=""> </span><span class="">INFM_sort_of_eq</span><span class=""> </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">INFM_iff_infinite</span><span class=""> </span><span class="keyword1">.</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">atom_infinite</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> 
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;infinite (UNIV :: atom set)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">using</span><span class=""> </span><span class="">subset_UNIV</span><span class=""> </span><span class="">infinite_sort_of_eq</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">infinite_super</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">obtain_atom</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">fixes</span><span class=""> </span><span class="">X</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;atom set&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="">X</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;finite X&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">obtains</span><span class=""> </span><span class="">a</span><span class=""> </span><span class="keyword2">where</span><span class=""> </span><span class="string">&quot;a &#8713; X&quot;</span><span class=""> </span><span class="string">&quot;sort_of a = s&quot;</span><span class="">
</span><span class="keyword1">proof</span><span class=""> </span><span class="">-</span><span class="">
</span><span class="">  </span><span class="keyword1">from</span><span class=""> </span><span class="">X</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;MOST a. a &#8713; X&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">MOST_iff_cofinite</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">  </span><span class="keyword1">with</span><span class=""> </span><span class="">INFM_sort_of_eq</span><span class="">
</span><span class="">  </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;INFM a. sort_of a = s &#8743; a &#8713; X&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">INFM_conjI</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">then</span><span class=""> </span><span class="keyword3">obtain</span><span class=""> </span><span class="">a</span><span class=""> </span><span class="keyword2">where</span><span class=""> </span><span class="string">&quot;a &#8713; X&quot;</span><span class=""> </span><span class="string">&quot;sort_of a = s&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">elim</span><span class="delimiter">:</span><span class=""> </span><span class="">INFM_E</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">then</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="var">?thesis</span><span class=""> </span><span class="keyword1">..</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">atom_components_eq_iff</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">fixes</span><span class=""> </span><span class="">a</span><span class=""> </span><span class="">b</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="">atom</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;a = b &#10231; sort_of a = sort_of b &#8743; nat_of a = nat_of b&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">a</span><span class="delimiter">,</span><span class=""> </span><span class="">induct</span><span class=""> </span><span class="">b</span><span class="delimiter">,</span><span class=""> </span><span class="">simp</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="">
</span><span class="keyword1">section</span><span class=""> </span><span class="verbatim">{* Sort-Respecting Permutations *}</span><span class="">
</span><span class="">
</span><span class="keyword1">definition</span><span class="">
</span><span class="">  </span><span class="string">&quot;perm &#8801; {f. bij f &#8743; finite {a. f a &#8800; a} &#8743; (&#8704;a. sort_of (f a) = sort_of a)}&quot;</span><span class="">
</span><span class="">
</span><span class="keyword1">typedef</span><span class=""> </span><span class="">perm</span><span class=""> </span><span class="delimiter">=</span><span class=""> </span><span class="string">&quot;perm&quot;</span><span class="">
</span><span class="keyword1">proof</span><span class="">
</span><span class="">  </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;id &#8712; perm&quot;</span><span class=""> </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">perm_def</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">permI</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="string">&quot;bij f&quot;</span><span class=""> </span><span class="keyword2">and</span><span class=""> </span><span class="string">&quot;MOST x. f x = x&quot;</span><span class=""> </span><span class="keyword2">and</span><span class=""> </span><span class="string">&quot;&#8896;a. sort_of (f a) = sort_of a&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;f &#8712; perm&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">using</span><span class=""> </span><span class="">assms</span><span class=""> </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">perm_def</span><span class=""> </span><span class="">MOST_iff_cofinite</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">perm_is_bij</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;f &#8712; perm &#10233; bij f&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">perm_def</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">perm_is_finite</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;f &#8712; perm &#10233; finite {a. f a &#8800; a}&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">perm_def</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">perm_is_sort_respecting</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;f &#8712; perm &#10233; sort_of (f a) = sort_of a&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">perm_def</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">perm_MOST</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;f &#8712; perm &#10233; MOST x. f x = x&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">perm_def</span><span class=""> </span><span class="">MOST_iff_cofinite</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">perm_id</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;id &#8712; perm&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">perm_def</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">perm_comp</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="">f</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;f &#8712; perm&quot;</span><span class=""> </span><span class="keyword2">and</span><span class=""> </span><span class="">g</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;g &#8712; perm&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;(f &#8728; g) &#8712; perm&quot;</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">permI</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">bij_comp</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">perm_is_bij</span><span class=""> </span><span class="delimiter">[</span><span class="">OF</span><span class=""> </span><span class="">g</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">perm_is_bij</span><span class=""> </span><span class="delimiter">[</span><span class="">OF</span><span class=""> </span><span class="">f</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">MOST_rev_mp</span><span class=""> </span><span class="delimiter">[</span><span class="">OF</span><span class=""> </span><span class="">perm_MOST</span><span class=""> </span><span class="delimiter">[</span><span class="">OF</span><span class=""> </span><span class="">g</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">MOST_rev_mp</span><span class=""> </span><span class="delimiter">[</span><span class="">OF</span><span class=""> </span><span class="">perm_MOST</span><span class=""> </span><span class="delimiter">[</span><span class="">OF</span><span class=""> </span><span class="">f</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">perm_is_sort_respecting</span><span class=""> </span><span class="delimiter">[</span><span class="">OF</span><span class=""> </span><span class="">f</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">perm_is_sort_respecting</span><span class=""> </span><span class="delimiter">[</span><span class="">OF</span><span class=""> </span><span class="">g</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">done</span></span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">perm_inv</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="">f</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;f &#8712; perm&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;(inv f) &#8712; perm&quot;</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">permI</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">bij_imp_bij_inv</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">perm_is_bij</span><span class=""> </span><span class="delimiter">[</span><span class="">OF</span><span class=""> </span><span class="">f</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">MOST_mono</span><span class=""> </span><span class="delimiter">[</span><span class="">OF</span><span class=""> </span><span class="">perm_MOST</span><span class=""> </span><span class="delimiter">[</span><span class="">OF</span><span class=""> </span><span class="">f</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">erule</span><span class=""> </span><span class="">subst</span><span class="delimiter">,</span><span class=""> </span><span class="">rule</span><span class=""> </span><span class="">inv_f_f</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">bij_is_inj</span><span class=""> </span><span class="delimiter">[</span><span class="">OF</span><span class=""> </span><span class="">perm_is_bij</span><span class=""> </span><span class="delimiter">[</span><span class="">OF</span><span class=""> </span><span class="">f</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">perm_is_sort_respecting</span><span class=""> </span><span class="delimiter">[</span><span class="">OF</span><span class=""> </span><span class="">f</span><span class="delimiter">,</span><span class=""> </span><span class="">THEN</span><span class=""> </span><span class="">sym</span><span class="delimiter">,</span><span class=""> </span><span class="">THEN</span><span class=""> </span><span class="">trans</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">surj_f_inv_f</span><span class=""> </span><span class="delimiter">[</span><span class="">OF</span><span class=""> </span><span class="">bij_is_surj</span><span class=""> </span><span class="delimiter">[</span><span class="">OF</span><span class=""> </span><span class="">perm_is_bij</span><span class=""> </span><span class="delimiter">[</span><span class="">OF</span><span class=""> </span><span class="">f</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">done</span></span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">bij_Rep_perm</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;bij (Rep_perm p)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">using</span><span class=""> </span><span class="">Rep_perm</span><span class=""> </span><span class="delimiter">[</span><span class="">of</span><span class=""> </span><span class="">p</span><span class="delimiter">]</span><span class=""> </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">perm_def</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">finite_Rep_perm</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;finite {a. Rep_perm p a &#8800; a}&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">using</span><span class=""> </span><span class="">Rep_perm</span><span class=""> </span><span class="delimiter">[</span><span class="">of</span><span class=""> </span><span class="">p</span><span class="delimiter">]</span><span class=""> </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">perm_def</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">sort_of_Rep_perm</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;sort_of (Rep_perm p a) = sort_of a&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">using</span><span class=""> </span><span class="">Rep_perm</span><span class=""> </span><span class="delimiter">[</span><span class="">of</span><span class=""> </span><span class="">p</span><span class="delimiter">]</span><span class=""> </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">perm_def</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">Rep_perm_ext</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="string">&quot;Rep_perm p1 = Rep_perm p2 &#10233; p1 = p2&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">fun_eq_iff</span><span class=""> </span><span class="">Rep_perm_inject</span><span class=""> </span><span class="delimiter">[</span><span class="">symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">instance</span><span class=""> </span><span class="">perm</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="">size</span><span class=""> </span><span class="keyword1">..</span><span class="">
</span><span class="">
</span><span class="">
</span><span class="keyword1">subsection</span><span class=""> </span><span class="verbatim">{* Permutations form a (multiplicative) group *}</span><span class="">
</span><span class="">
</span><span class="keyword1">instantiation</span><span class=""> </span><span class="">perm</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="">group_add</span><span class="">
</span><span class="keyword2">begin</span><span class="">
</span><span class="">
</span><span class="keyword1">definition</span><span class="">
</span><span class="">  </span><span class="string">&quot;0 = Abs_perm id&quot;</span><span class="">
</span><span class="">
</span><span class="keyword1">definition</span><span class="">
</span><span class="">  </span><span class="string">&quot;- p = Abs_perm (inv (Rep_perm p))&quot;</span><span class="">
</span><span class="">
</span><span class="keyword1">definition</span><span class="">
</span><span class="">  </span><span class="string">&quot;p + q = Abs_perm (Rep_perm p &#8728; Rep_perm q)&quot;</span><span class="">
</span><span class="">
</span><span class="keyword1">definition</span><span class="">
</span><span class="">  </span><span class="string">&quot;(p1::perm) - p2 = p1 + - p2&quot;</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">Rep_perm_0</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;Rep_perm 0 = id&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">zero_perm_def</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">Abs_perm_inverse</span><span class=""> </span><span class="">perm_id</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">Rep_perm_add</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="string">&quot;Rep_perm (p1 + p2) = Rep_perm p1 &#8728; Rep_perm p2&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">plus_perm_def</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">Abs_perm_inverse</span><span class=""> </span><span class="">perm_comp</span><span class=""> </span><span class="">Rep_perm</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">Rep_perm_uminus</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="string">&quot;Rep_perm (- p) = inv (Rep_perm p)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">uminus_perm_def</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">Abs_perm_inverse</span><span class=""> </span><span class="">perm_inv</span><span class=""> </span><span class="">Rep_perm</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">instance</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="">standard</span><span class="">
</span><span class="keyword1">unfolding</span><span class=""> </span><span class="">Rep_perm_inject</span><span class=""> </span><span class="delimiter">[</span><span class="">symmetric</span><span class="delimiter">]</span><span class="">
</span><span class="keyword1">unfolding</span><span class=""> </span><span class="">minus_perm_def</span><span class="">
</span><span class="keyword1">unfolding</span><span class=""> </span><span class="">Rep_perm_add</span><span class="">
</span><span class="keyword1">unfolding</span><span class=""> </span><span class="">Rep_perm_uminus</span><span class="">
</span><span class="keyword1">unfolding</span><span class=""> </span><span class="">Rep_perm_0</span><span class="">
</span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp_all</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">o_assoc</span><span class=""> </span><span class="">inv_o_cancel</span><span class=""> </span><span class="delimiter">[</span><span class="">OF</span><span class=""> </span><span class="">bij_is_inj</span><span class=""> </span><span class="delimiter">[</span><span class="">OF</span><span class=""> </span><span class="">bij_Rep_perm</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword2">end</span><span class="">
</span><span class="">
</span><span class="">
</span><span class="keyword1">section</span><span class=""> </span><span class="verbatim">{* Implementation of swappings *}</span><span class="">
</span><span class="">
</span><span class="keyword1">definition</span><span class="">
</span><span class="">  </span><span class="">swap</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;atom &#8658; atom &#8658; perm&quot;</span><span class=""> </span><span class="delimiter">(</span><span class="string">&quot;&#39;(_ &#8652; _&#39;)&quot;</span><span class="delimiter">)</span><span class="">
</span><span class="keyword2">where</span><span class="">
</span><span class="">  </span><span class="string">&quot;(a &#8652; b) =
    Abs_perm (if sort_of a = sort_of b 
              then (&#955;c. if a = c then b else if b = c then a else c) 
              else id)&quot;</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">Rep_perm_swap</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="string">&quot;Rep_perm (a &#8652; b) =
    (if sort_of a = sort_of b 
     then (&#955;c. if a = c then b else if b = c then a else c)
     else id)&quot;</span><span class="">
</span><span class="keyword1">unfolding</span><span class=""> </span><span class="">swap_def</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">Abs_perm_inverse</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">permI</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class="delimiter">:</span><span class=""> </span><span class="">bij_def</span><span class=""> </span><span class="">inj_on_def</span><span class=""> </span><span class="">surj_def</span><span class="delimiter">)</span><span class="delimiter">[</span><span class="">1</span><span class="delimiter">]</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">MOST_rev_mp</span><span class=""> </span><span class="delimiter">[</span><span class="">OF</span><span class=""> </span><span class="">MOST_neq</span><span class="delimiter">(</span><span class="">1</span><span class="delimiter">)</span><span class=""> </span><span class="delimiter">[</span><span class="">of</span><span class=""> </span><span class="">a</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">MOST_rev_mp</span><span class=""> </span><span class="delimiter">[</span><span class="">OF</span><span class=""> </span><span class="">MOST_neq</span><span class="delimiter">(</span><span class="">1</span><span class="delimiter">)</span><span class=""> </span><span class="delimiter">[</span><span class="">of</span><span class=""> </span><span class="">b</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">done</span></span><span class="">
</span><span class="">
</span><span class="keyword1">lemmas</span><span class=""> </span><span class="">Rep_perm_simps</span><span class=""> </span><span class="delimiter">=</span><span class="">
</span><span class="">  </span><span class="">Rep_perm_0</span><span class="">
</span><span class="">  </span><span class="">Rep_perm_add</span><span class="">
</span><span class="">  </span><span class="">Rep_perm_uminus</span><span class="">
</span><span class="">  </span><span class="">Rep_perm_swap</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">swap_different_sorts</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="string">&quot;sort_of a &#8800; sort_of b &#10233; (a &#8652; b) = 0&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">Rep_perm_ext</span><span class="delimiter">)</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">Rep_perm_simps</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">swap_cancel</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;(a &#8652; b) + (a &#8652; b) = 0&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">and</span><span class="">   </span><span class="string">&quot;(a &#8652; b) + (b &#8652; a) = 0&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">rule_tac</span><span class=""> </span><span class="delimiter">[</span><span class="delimiter">!</span><span class="delimiter">]</span><span class=""> </span><span class="">Rep_perm_ext</span><span class="delimiter">)</span><span class=""> 
</span><span class="">     </span><span class="delimiter">(</span><span class="">simp_all</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">Rep_perm_simps</span><span class=""> </span><span class="">fun_eq_iff</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">swap_self</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="string">&quot;(a &#8652; a) = 0&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">Rep_perm_ext</span><span class="delimiter">,</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">Rep_perm_simps</span><span class=""> </span><span class="">fun_eq_iff</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">minus_swap</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="string">&quot;- (a &#8652; b) = (a &#8652; b)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">minus_unique</span><span class=""> </span><span class="delimiter">[</span><span class="">OF</span><span class=""> </span><span class="">swap_cancel</span><span class="delimiter">(</span><span class="">1</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">swap_commute</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="string">&quot;(a &#8652; b) = (b &#8652; a)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">Rep_perm_ext</span><span class="delimiter">)</span><span class="">
</span><span class="">     </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">Rep_perm_swap</span><span class=""> </span><span class="">fun_eq_iff</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">swap_triple</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="string">&quot;a &#8800; b&quot;</span><span class=""> </span><span class="keyword2">and</span><span class=""> </span><span class="string">&quot;c &#8800; b&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="string">&quot;sort_of a = sort_of b&quot;</span><span class=""> </span><span class="string">&quot;sort_of b = sort_of c&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;(a &#8652; c) + (b &#8652; c) + (a &#8652; c) = (a &#8652; b)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">using</span><span class=""> </span><span class="">assms</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">rule_tac</span><span class=""> </span><span class="">Rep_perm_ext</span><span class="delimiter">)</span><span class="">
</span><span class="">     </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class="delimiter">:</span><span class=""> </span><span class="">Rep_perm_simps</span><span class=""> </span><span class="">fun_eq_iff</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="">
</span><span class="keyword1">section</span><span class=""> </span><span class="verbatim">{* Permutation Types *}</span><span class="">
</span><span class="">
</span><span class="keyword1">text</span><span class=""> </span><span class="verbatim">{*
  Infix syntax for @{text permute} has higher precedence than
  addition, but lower than unary minus.
*}</span><span class="">
</span><span class="">
</span><span class="keyword1">class</span><span class=""> </span><span class="">pt</span><span class=""> </span><span class="delimiter">=</span><span class="">
</span><span class="">  </span><span class="keyword2">fixes</span><span class=""> </span><span class="">permute</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;perm &#8658; &#39;a &#8658; &#39;a&quot;</span><span class=""> </span><span class="delimiter">(</span><span class="string">&quot;_ &#8729; _&quot;</span><span class=""> </span><span class="delimiter">[</span><span class="">76</span><span class="delimiter">,</span><span class=""> </span><span class="">75</span><span class="delimiter">]</span><span class=""> </span><span class="">75</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="">permute_zero</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;0 &#8729; x = x&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="">permute_plus</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;(p + q) &#8729; x = p &#8729; (q &#8729; x)&quot;</span><span class="">
</span><span class="keyword2">begin</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">permute_diff</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;(p - q) &#8729; x = p &#8729; - q &#8729; x&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">using</span><span class=""> </span><span class="">permute_plus</span><span class=""> </span><span class="delimiter">[</span><span class="">of</span><span class=""> </span><span class="">p</span><span class=""> </span><span class="string">&quot;- q&quot;</span><span class=""> </span><span class="">x</span><span class="delimiter">]</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">permute_minus_cancel</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;p &#8729; - p &#8729; x = x&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">and</span><span class="">   </span><span class="string">&quot;- p &#8729; p &#8729; x = x&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">permute_plus</span><span class=""> </span><span class="delimiter">[</span><span class="">symmetric</span><span class="delimiter">]</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp_all</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">permute_swap_cancel</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;(a &#8652; b) &#8729; (a &#8652; b) &#8729; x = x&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">permute_plus</span><span class=""> </span><span class="delimiter">[</span><span class="">symmetric</span><span class="delimiter">]</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">swap_cancel</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">permute_swap_cancel2</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;(a &#8652; b) &#8729; (b &#8652; a) &#8729; x = x&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">permute_plus</span><span class=""> </span><span class="delimiter">[</span><span class="">symmetric</span><span class="delimiter">]</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">swap_commute</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">inj_permute</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> 
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;inj (permute p)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">inj_on_inverseI</span><span class="delimiter">)</span><span class="">
</span><span class="">     </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">permute_minus_cancel</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">surj_permute</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> 
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;surj (permute p)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">surjI</span><span class="delimiter">,</span><span class=""> </span><span class="">rule</span><span class=""> </span><span class="">permute_minus_cancel</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">bij_permute</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> 
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;bij (permute p)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">bijI</span><span class=""> </span><span class="delimiter">[</span><span class="">OF</span><span class=""> </span><span class="">inj_permute</span><span class=""> </span><span class="">surj_permute</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">inv_permute</span><span class="delimiter">:</span><span class=""> 
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;inv (permute p) = permute (- p)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">inv_equality</span><span class="delimiter">)</span><span class=""> </span><span class="delimiter">(</span><span class="">simp_all</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">permute_minus</span><span class="delimiter">:</span><span class=""> 
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;permute (- p) = inv (permute p)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">inv_permute</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">permute_eq_iff</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> 
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;p &#8729; x = p &#8729; y &#10231; x = y&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">inj_permute</span><span class=""> </span><span class="delimiter">[</span><span class="">THEN</span><span class=""> </span><span class="">inj_eq</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword2">end</span><span class="">
</span><span class="">
</span><span class="keyword1">subsection</span><span class=""> </span><span class="verbatim">{* Permutations for atoms *}</span><span class="">
</span><span class="">
</span><span class="keyword1">instantiation</span><span class=""> </span><span class="">atom</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="">pt</span><span class="">
</span><span class="keyword2">begin</span><span class="">
</span><span class="">
</span><span class="keyword1">definition</span><span class="">
</span><span class="">  </span><span class="string">&quot;p &#8729; a = (Rep_perm p) a&quot;</span><span class="">
</span><span class="">
</span><span class="keyword1">instance</span><span class=""> 
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="">standard</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">simp_all</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">permute_atom_def</span><span class=""> </span><span class="">Rep_perm_simps</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">done</span></span><span class="">
</span><span class="">
</span><span class="keyword2">end</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">sort_of_permute</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;sort_of (p &#8729; a) = sort_of a&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">permute_atom_def</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">sort_of_Rep_perm</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">swap_atom</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;(a &#8652; b) &#8729; c =
           (if sort_of a = sort_of b
            then (if c = a then b else if c = b then a else c) else c)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">permute_atom_def</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">Rep_perm_swap</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">swap_atom_simps</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="string">&quot;sort_of a = sort_of b &#10233; (a &#8652; b) &#8729; a = b&quot;</span><span class="">
</span><span class="">  </span><span class="string">&quot;sort_of a = sort_of b &#10233; (a &#8652; b) &#8729; b = a&quot;</span><span class="">
</span><span class="">  </span><span class="string">&quot;c &#8800; a &#10233; c &#8800; b &#10233; (a &#8652; b) &#8729; c = c&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">swap_atom</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp_all</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">perm_eq_iff</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">fixes</span><span class=""> </span><span class="">p</span><span class=""> </span><span class="">q</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;perm&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;p = q &#10231; (&#8704;a::atom. p &#8729; a = q &#8729; a)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">permute_atom_def</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">metis</span><span class=""> </span><span class="">Rep_perm_ext</span><span class=""> </span><span class="">ext</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">subsection</span><span class=""> </span><span class="verbatim">{* Permutations for permutations *}</span><span class="">
</span><span class="">
</span><span class="keyword1">instantiation</span><span class=""> </span><span class="">perm</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="">pt</span><span class="">
</span><span class="keyword2">begin</span><span class="">
</span><span class="">
</span><span class="keyword1">definition</span><span class="">
</span><span class="">  </span><span class="string">&quot;p &#8729; q = p + q - p&quot;</span><span class="">
</span><span class="">
</span><span class="keyword1">instance</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="">standard</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">permute_perm_def</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">permute_perm_def</span><span class=""> </span><span class="">algebra_simps</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">done</span></span><span class="">
</span><span class="">
</span><span class="keyword2">end</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">permute_self</span><span class="delimiter">:</span><span class=""> 
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;p &#8729; p = p&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">permute_perm_def</span><span class=""> 
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">add.assoc</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">pemute_minus_self</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;- p &#8729; p = p&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">permute_perm_def</span><span class=""> 
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">add.assoc</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="">
</span><span class="keyword1">subsection</span><span class=""> </span><span class="verbatim">{* Permutations for functions *}</span><span class="">
</span><span class="">
</span><span class="keyword1">instantiation</span><span class=""> </span><span class="string">&quot;fun&quot;</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="delimiter">(</span><span class="">pt</span><span class="delimiter">,</span><span class=""> </span><span class="">pt</span><span class="delimiter">)</span><span class=""> </span><span class="">pt</span><span class="">
</span><span class="keyword2">begin</span><span class="">
</span><span class="">
</span><span class="keyword1">definition</span><span class="">
</span><span class="">  </span><span class="string">&quot;p &#8729; f = (&#955;x. p &#8729; (f (- p &#8729; x)))&quot;</span><span class="">
</span><span class="">
</span><span class="keyword1">instance</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="">standard</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">permute_fun_def</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">permute_fun_def</span><span class=""> </span><span class="">minus_add</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">done</span></span><span class="">
</span><span class="">
</span><span class="keyword2">end</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">permute_fun_app_eq</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;p &#8729; (f x) = (p &#8729; f) (p &#8729; x)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">permute_fun_def</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">permute_fun_comp</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;p &#8729; f  = (permute p) o f o (permute (-p))&quot;</span><span class="">
</span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">comp_def</span><span class=""> </span><span class="">permute_fun_def</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">subsection</span><span class=""> </span><span class="verbatim">{* Permutations for booleans *}</span><span class="">
</span><span class="">
</span><span class="keyword1">instantiation</span><span class=""> </span><span class="">bool</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="">pt</span><span class="">
</span><span class="keyword2">begin</span><span class="">
</span><span class="">
</span><span class="keyword1">definition</span><span class=""> </span><span class="string">&quot;p &#8729; (b::bool) = b&quot;</span><span class="">
</span><span class="">
</span><span class="keyword1">instance</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="">standard</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">simp_all</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">permute_bool_def</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">done</span></span><span class="">
</span><span class="">
</span><span class="keyword2">end</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">permute_boolE</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">fixes</span><span class=""> </span><span class="">P</span><span class="delimiter">::</span><span class="string">&quot;bool&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;p &#8729; P &#10233; P&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">permute_bool_def</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">permute_boolI</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">fixes</span><span class=""> </span><span class="">P</span><span class="delimiter">::</span><span class="string">&quot;bool&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;P &#10233; p &#8729; P&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">permute_bool_def</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">subsection</span><span class=""> </span><span class="verbatim">{* Permutations for sets *}</span><span class="">
</span><span class="">
</span><span class="keyword1">instantiation</span><span class=""> </span><span class="string">&quot;set&quot;</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="delimiter">(</span><span class="">pt</span><span class="delimiter">)</span><span class=""> </span><span class="">pt</span><span class="">
</span><span class="keyword2">begin</span><span class="">
</span><span class="">
</span><span class="keyword1">definition</span><span class="">
</span><span class="">  </span><span class="string">&quot;p &#8729; X = {p &#8729; x | x. x &#8712; X}&quot;</span><span class=""> 
</span><span class="">
</span><span class="keyword1">instance</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="">standard</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class="delimiter">:</span><span class=""> </span><span class="">permute_set_def</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">done</span></span><span class="">
</span><span class="">
</span><span class="keyword2">end</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">permute_set_eq</span><span class="delimiter">:</span><span class="">
</span><span class=""> </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;p &#8729; X = {x. - p &#8729; x &#8712; X}&quot;</span><span class="">
</span><span class="keyword1">unfolding</span><span class=""> </span><span class="">permute_set_def</span><span class="">
</span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class="delimiter">)</span><span class=""> </span><span class="delimiter">(</span><span class="">metis</span><span class=""> </span><span class="">permute_minus_cancel</span><span class="delimiter">(</span><span class="">1</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">permute_set_eq_image</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;p &#8729; X = permute p ` X&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">permute_set_def</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">permute_set_eq_vimage</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;p &#8729; X = permute (- p) -` X&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">permute_set_eq</span><span class=""> </span><span class="">vimage_def</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">  
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">permute_finite</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;finite (p &#8729; X) = finite X&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">permute_set_eq_vimage</span><span class="">
</span><span class="">  </span><span class="keyword1">using</span><span class=""> </span><span class="">bij_permute</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">finite_vimage_iff</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">swap_set_not_in</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="">a</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;a &#8713; S&quot;</span><span class=""> </span><span class="string">&quot;b &#8713; S&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;(a &#8652; b) &#8729; S = S&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">permute_set_def</span><span class="">
</span><span class="">  </span><span class="keyword1">using</span><span class=""> </span><span class="">a</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class="delimiter">:</span><span class=""> </span><span class="">swap_atom</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">swap_set_in</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="">a</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;a &#8712; S&quot;</span><span class=""> </span><span class="string">&quot;b &#8713; S&quot;</span><span class=""> </span><span class="string">&quot;sort_of a = sort_of b&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;(a &#8652; b) &#8729; S &#8800; S&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">permute_set_def</span><span class="">
</span><span class="">  </span><span class="keyword1">using</span><span class=""> </span><span class="">a</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class="delimiter">:</span><span class=""> </span><span class="">swap_atom</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">swap_set_in_eq</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="">a</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;a &#8712; S&quot;</span><span class=""> </span><span class="string">&quot;b &#8713; S&quot;</span><span class=""> </span><span class="string">&quot;sort_of a = sort_of b&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;(a &#8652; b) &#8729; S = (S - {a}) &#8746; {b}&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">permute_set_def</span><span class="">
</span><span class="">  </span><span class="keyword1">using</span><span class=""> </span><span class="">a</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class="delimiter">:</span><span class=""> </span><span class="">swap_atom</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">swap_set_both_in</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="">a</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;a &#8712; S&quot;</span><span class=""> </span><span class="string">&quot;b &#8712; S&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;(a &#8652; b) &#8729; S = S&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">permute_set_def</span><span class="">
</span><span class="">  </span><span class="keyword1">using</span><span class=""> </span><span class="">a</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class="delimiter">:</span><span class=""> </span><span class="">swap_atom</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">mem_permute_iff</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;(p &#8729; x) &#8712; (p &#8729; X) &#10231; x &#8712; X&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">permute_set_def</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">empty_eqvt</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;p &#8729; {} = {}&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">permute_set_def</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">insert_eqvt</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;p &#8729; (insert x A) = insert (p &#8729; x) (p &#8729; A)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">permute_set_eq_image</span><span class=""> </span><span class="">image_insert</span><span class=""> </span><span class="keyword1">..</span><span class="">
</span><span class="">
</span><span class="">
</span><span class="keyword1">subsection</span><span class=""> </span><span class="verbatim">{* Permutations for @{typ unit} *}</span><span class="">
</span><span class="">
</span><span class="keyword1">instantiation</span><span class=""> </span><span class="">unit</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="">pt</span><span class="">
</span><span class="keyword2">begin</span><span class="">
</span><span class="">
</span><span class="keyword1">definition</span><span class=""> </span><span class="string">&quot;p &#8729; (u::unit) = u&quot;</span><span class="">
</span><span class="">
</span><span class="keyword1">instance</span><span class=""> 
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="">standard</span><span class=""> </span><span class="delimiter">(</span><span class="">simp_all</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">permute_unit_def</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword2">end</span><span class="">
</span><span class="">
</span><span class="">
</span><span class="keyword1">subsection</span><span class=""> </span><span class="verbatim">{* Permutations for products *}</span><span class="">
</span><span class="">
</span><span class="keyword1">instantiation</span><span class=""> </span><span class="">prod</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="delimiter">(</span><span class="">pt</span><span class="delimiter">,</span><span class=""> </span><span class="">pt</span><span class="delimiter">)</span><span class=""> </span><span class="">pt</span><span class="">
</span><span class="keyword2">begin</span><span class="">
</span><span class="">
</span><span class="keyword1">primrec</span><span class=""> 
</span><span class="">  </span><span class="">permute_prod</span><span class=""> 
</span><span class="keyword2">where</span><span class="">
</span><span class="">  </span><span class="">Pair_eqvt</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;p &#8729; (x, y) = (p &#8729; x, p &#8729; y)&quot;</span><span class="">
</span><span class="">
</span><span class="keyword1">instance</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="">standard</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">
</span><span class="keyword2">end</span><span class="">
</span><span class="">
</span><span class="keyword1">subsection</span><span class=""> </span><span class="verbatim">{* Permutations for sums *}</span><span class="">
</span><span class="">
</span><span class="keyword1">instantiation</span><span class=""> </span><span class="">sum</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="delimiter">(</span><span class="">pt</span><span class="delimiter">,</span><span class=""> </span><span class="">pt</span><span class="delimiter">)</span><span class=""> </span><span class="">pt</span><span class="">
</span><span class="keyword2">begin</span><span class="">
</span><span class="">
</span><span class="keyword1">primrec</span><span class=""> 
</span><span class="">  </span><span class="">permute_sum</span><span class=""> 
</span><span class="keyword2">where</span><span class="">
</span><span class="">  </span><span class="">Inl_eqvt</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;p &#8729; (Inl x) = Inl (p &#8729; x)&quot;</span><span class="">
</span><span class="delimiter">|</span><span class=""> </span><span class="">Inr_eqvt</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;p &#8729; (Inr y) = Inr (p &#8729; y)&quot;</span><span class="">
</span><span class="">
</span><span class="keyword1">instance</span><span class=""> 
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="">standard</span><span class=""> </span><span class="delimiter">(</span><span class="">case_tac</span><span class=""> </span><span class="delimiter">[</span><span class="delimiter">!</span><span class="delimiter">]</span><span class=""> </span><span class="">x</span><span class="delimiter">,</span><span class=""> </span><span class="">simp_all</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword2">end</span><span class="">
</span><span class="">
</span><span class="keyword1">subsection</span><span class=""> </span><span class="verbatim">{* Permutations for @{typ &quot;&#39;a list&quot;} *}</span><span class="">
</span><span class="">
</span><span class="keyword1">instantiation</span><span class=""> </span><span class="">list</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="delimiter">(</span><span class="">pt</span><span class="delimiter">)</span><span class=""> </span><span class="">pt</span><span class="">
</span><span class="keyword2">begin</span><span class="">
</span><span class="">
</span><span class="keyword1">primrec</span><span class=""> 
</span><span class="">  </span><span class="">permute_list</span><span class=""> 
</span><span class="keyword2">where</span><span class="">
</span><span class="">  </span><span class="">Nil_eqvt</span><span class="delimiter">:</span><span class="">  </span><span class="string">&quot;p &#8729; [] = []&quot;</span><span class="">
</span><span class="delimiter">|</span><span class=""> </span><span class="">Cons_eqvt</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;p &#8729; (x # xs) = p &#8729; x # p &#8729; xs&quot;</span><span class="">
</span><span class="">
</span><span class="keyword1">instance</span><span class=""> 
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="">standard</span><span class=""> </span><span class="delimiter">(</span><span class="">induct_tac</span><span class=""> </span><span class="delimiter">[</span><span class="delimiter">!</span><span class="delimiter">]</span><span class=""> </span><span class="">x</span><span class="delimiter">,</span><span class=""> </span><span class="">simp_all</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword2">end</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">set_eqvt</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;p &#8729; (set xs) = set (p &#8729; xs)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">xs</span><span class="delimiter">)</span><span class=""> </span><span class="delimiter">(</span><span class="">simp_all</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">empty_eqvt</span><span class=""> </span><span class="">insert_eqvt</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="">
</span><span class="">
</span><span class="keyword1">subsection</span><span class=""> </span><span class="verbatim">{* Permutations for @{typ &quot;&#39;a option&quot;} *}</span><span class="">
</span><span class="">
</span><span class="keyword1">instantiation</span><span class=""> </span><span class="">option</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="delimiter">(</span><span class="">pt</span><span class="delimiter">)</span><span class=""> </span><span class="">pt</span><span class="">
</span><span class="keyword2">begin</span><span class="">
</span><span class="">
</span><span class="keyword1">primrec</span><span class=""> 
</span><span class="">  </span><span class="">permute_option</span><span class=""> 
</span><span class="keyword2">where</span><span class="">
</span><span class="">  </span><span class="">None_eqvt</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;p &#8729; None = None&quot;</span><span class="">
</span><span class="delimiter">|</span><span class=""> </span><span class="">Some_eqvt</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;p &#8729; (Some x) = Some (p &#8729; x)&quot;</span><span class="">
</span><span class="">
</span><span class="keyword1">instance</span><span class=""> 
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="">standard</span><span class=""> </span><span class="delimiter">(</span><span class="">induct_tac</span><span class=""> </span><span class="delimiter">[</span><span class="delimiter">!</span><span class="delimiter">]</span><span class=""> </span><span class="">x</span><span class="delimiter">,</span><span class=""> </span><span class="">simp_all</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword2">end</span><span class="">
</span><span class="">
</span><span class="keyword1">subsection</span><span class=""> </span><span class="verbatim">{* Permutations for @{typ &quot;&#39;a multiset&quot;} *}</span><span class="">
</span><span class="">
</span><span class="keyword1">instantiation</span><span class=""> </span><span class="">multiset</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="delimiter">(</span><span class="">pt</span><span class="delimiter">)</span><span class=""> </span><span class="">pt</span><span class="">
</span><span class="keyword2">begin</span><span class="">
</span><span class="">
</span><span class="keyword1">definition</span><span class="">
</span><span class="">  </span><span class="string">&quot;p &#8729; M = {# p &#8729; x. x :# M #}&quot;</span><span class="">
</span><span class="">
</span><span class="keyword1">instance</span><span class=""> 
</span><span class="keyword1">proof</span><span class="">
</span><span class="">  </span><span class="keyword3">fix</span><span class=""> </span><span class="">M</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;&#39;a multiset&quot;</span><span class=""> </span><span class="keyword2">and</span><span class=""> </span><span class="">p</span><span class=""> </span><span class="">q</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;perm&quot;</span><span class="">
</span><span class="">  </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;0 &#8729; M = M&quot;</span><span class=""> 
</span><span class="">    </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">permute_multiset_def</span><span class="">
</span><span class="">    </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">induct_tac</span><span class=""> </span><span class="">M</span><span class="delimiter">)</span><span class=""> </span><span class="delimiter">(</span><span class="">simp_all</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;(p + q) &#8729; M = p &#8729; q &#8729; M&quot;</span><span class=""> 
</span><span class="">    </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">permute_multiset_def</span><span class="">
</span><span class="">    </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">induct_tac</span><span class=""> </span><span class="">M</span><span class="delimiter">)</span><span class=""> </span><span class="delimiter">(</span><span class="">simp_all</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="keyword2">end</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">permute_multiset</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">fixes</span><span class=""> </span><span class="">M</span><span class=""> </span><span class="">N</span><span class="delimiter">::</span><span class="string">&quot;(&#39;a::pt) multiset&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;(p &#8729; {#}) = ({#} ::(&#39;a::pt) multiset)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">and</span><span class="">   </span><span class="string">&quot;(p &#8729; {# x #}) = {# p &#8729; x #}&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">and</span><span class="">   </span><span class="string">&quot;(p &#8729; (M + N)) = (p &#8729; M) + (p &#8729; N)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">permute_multiset_def</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp_all</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="">
</span><span class="keyword1">subsection</span><span class=""> </span><span class="verbatim">{* Permutations for @{typ &quot;&#39;a fset&quot;} *}</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">permute_fset_rsp</span><span class="delimiter">[</span><span class="">quot_respect</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;(op = ===&gt; list_eq ===&gt; list_eq) permute permute&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">rel_fun_def</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">set_eqvt</span><span class="delimiter">[</span><span class="">symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">instantiation</span><span class=""> </span><span class="">fset</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="delimiter">(</span><span class="">pt</span><span class="delimiter">)</span><span class=""> </span><span class="">pt</span><span class="">
</span><span class="keyword2">begin</span><span class="">
</span><span class="">
</span><span class="keyword1">quotient_definition</span><span class="">
</span><span class="">  </span><span class="string">&quot;permute_fset :: perm &#8658; &#39;a fset &#8658; &#39;a fset&quot;</span><span class="">
</span><span class="keyword2">is</span><span class="">
</span><span class="">  </span><span class="string">&quot;permute :: perm &#8658; &#39;a list &#8658; &#39;a list&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">set_eqvt</span><span class="delimiter">[</span><span class="">symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">instance</span><span class=""> 
</span><span class="keyword1">proof</span><span class="">
</span><span class="">  </span><span class="keyword3">fix</span><span class=""> </span><span class="">x</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;&#39;a fset&quot;</span><span class=""> </span><span class="keyword2">and</span><span class=""> </span><span class="">p</span><span class=""> </span><span class="">q</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;perm&quot;</span><span class="">
</span><span class="">  </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;0 &#8729; x = x&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">descending</span><span class="delimiter">)</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;(p + q) &#8729; x = p &#8729; q &#8729; x&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">descending</span><span class="delimiter">)</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="keyword2">end</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">permute_fset</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">fixes</span><span class=""> </span><span class="">S</span><span class="delimiter">::</span><span class="string">&quot;(&#39;a::pt) fset&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;(p &#8729; {||}) = ({||} ::(&#39;a::pt) fset)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">and</span><span class="">   </span><span class="string">&quot;(p &#8729; insert_fset x S) = insert_fset (p &#8729; x) (p &#8729; S)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">lifting</span><span class=""> </span><span class="">permute_list.simps</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">fset_eqvt</span><span class="delimiter">:</span><span class=""> 
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;p &#8729; (fset S) = fset (p &#8729; S)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">lifting</span><span class=""> </span><span class="">set_eqvt</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="">
</span><span class="keyword1">subsection</span><span class=""> </span><span class="verbatim">{* Permutations for @{typ &quot;(&#39;a, &#39;b) finfun&quot;} *}</span><span class="">
</span><span class="">
</span><span class="keyword1">instantiation</span><span class=""> </span><span class="">finfun</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="delimiter">(</span><span class="">pt</span><span class="delimiter">,</span><span class=""> </span><span class="">pt</span><span class="delimiter">)</span><span class=""> </span><span class="">pt</span><span class="">
</span><span class="keyword2">begin</span><span class="">
</span><span class="">
</span><span class="keyword1">lift_definition</span><span class="">
</span><span class="">  </span><span class="">permute_finfun</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;perm &#8658; (&#39;a, &#39;b) finfun &#8658; (&#39;a, &#39;b) finfun&quot;</span><span class="">
</span><span class="keyword2">is</span><span class="">
</span><span class="">  </span><span class="string">&quot;permute :: perm &#8658; (&#39;a &#8658; &#39;b) &#8658; (&#39;a &#8658; &#39;b)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">permute_fun_comp</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">finfun_right_compose</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">finfun_left_compose</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">assumption</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">simp</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">done</span></span><span class="">
</span><span class="">
</span><span class="keyword1">instance</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="">standard</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">transfer</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">simp</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">transfer</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">simp</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">done</span></span><span class="">
</span><span class="">
</span><span class="keyword2">end</span><span class="">
</span><span class="">
</span><span class="">
</span><span class="keyword1">subsection</span><span class=""> </span><span class="verbatim">{* Permutations for @{typ char}, @{typ nat}, and @{typ int} *}</span><span class="">
</span><span class="">
</span><span class="keyword1">instantiation</span><span class=""> </span><span class="">char</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="">pt</span><span class="">
</span><span class="keyword2">begin</span><span class="">
</span><span class="">
</span><span class="keyword1">definition</span><span class=""> </span><span class="string">&quot;p &#8729; (c::char) = c&quot;</span><span class="">
</span><span class="">
</span><span class="keyword1">instance</span><span class=""> 
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="">standard</span><span class=""> </span><span class="delimiter">(</span><span class="">simp_all</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">permute_char_def</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword2">end</span><span class="">
</span><span class="">
</span><span class="keyword1">instantiation</span><span class=""> </span><span class="">nat</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="">pt</span><span class="">
</span><span class="keyword2">begin</span><span class="">
</span><span class="">
</span><span class="keyword1">definition</span><span class=""> </span><span class="string">&quot;p &#8729; (n::nat) = n&quot;</span><span class="">
</span><span class="">
</span><span class="keyword1">instance</span><span class=""> 
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="">standard</span><span class=""> </span><span class="delimiter">(</span><span class="">simp_all</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">permute_nat_def</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword2">end</span><span class="">
</span><span class="">
</span><span class="keyword1">instantiation</span><span class=""> </span><span class="">int</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="">pt</span><span class="">
</span><span class="keyword2">begin</span><span class="">
</span><span class="">
</span><span class="keyword1">definition</span><span class=""> </span><span class="string">&quot;p &#8729; (i::int) = i&quot;</span><span class="">
</span><span class="">
</span><span class="keyword1">instance</span><span class=""> 
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="">standard</span><span class=""> </span><span class="delimiter">(</span><span class="">simp_all</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">permute_int_def</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword2">end</span><span class="">
</span><span class="">
</span><span class="">
</span><span class="keyword1">section</span><span class=""> </span><span class="verbatim">{* Pure types *}</span><span class="">
</span><span class="">
</span><span class="keyword1">text</span><span class=""> </span><span class="verbatim">{* Pure types will have always empty support. *}</span><span class="">
</span><span class="">
</span><span class="keyword1">class</span><span class=""> </span><span class="">pure</span><span class=""> </span><span class="delimiter">=</span><span class=""> </span><span class="">pt</span><span class=""> </span><span class="delimiter">+</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="">permute_pure</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;p &#8729; x = x&quot;</span><span class="">
</span><span class="">
</span><span class="keyword1">text</span><span class=""> </span><span class="verbatim">{* Types @{typ unit} and @{typ bool} are pure. *}</span><span class="">
</span><span class="">
</span><span class="keyword1">instance</span><span class=""> </span><span class="">unit</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="">pure</span><span class="">
</span><span class="keyword1">proof</span><span class=""> </span><span class="keyword1">qed</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">permute_unit_def</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">instance</span><span class=""> </span><span class="">bool</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="">pure</span><span class="">
</span><span class="keyword1">proof</span><span class=""> </span><span class="keyword1">qed</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">permute_bool_def</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="">
</span><span class="keyword1">text</span><span class=""> </span><span class="verbatim">{* Other type constructors preserve purity. *}</span><span class="">
</span><span class="">
</span><span class="keyword1">instance</span><span class=""> </span><span class="string">&quot;fun&quot;</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="delimiter">(</span><span class="">pure</span><span class="delimiter">,</span><span class=""> </span><span class="">pure</span><span class="delimiter">)</span><span class=""> </span><span class="">pure</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="">standard</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">permute_fun_def</span><span class=""> </span><span class="">permute_pure</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">instance</span><span class=""> </span><span class="">set</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="delimiter">(</span><span class="">pure</span><span class="delimiter">)</span><span class=""> </span><span class="">pure</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="">standard</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">permute_set_def</span><span class=""> </span><span class="">permute_pure</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">instance</span><span class=""> </span><span class="">prod</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="delimiter">(</span><span class="">pure</span><span class="delimiter">,</span><span class=""> </span><span class="">pure</span><span class="delimiter">)</span><span class=""> </span><span class="">pure</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="">standard</span><span class=""> </span><span class="delimiter">(</span><span class="">induct_tac</span><span class=""> </span><span class="">x</span><span class="delimiter">,</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">permute_pure</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">instance</span><span class=""> </span><span class="">sum</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="delimiter">(</span><span class="">pure</span><span class="delimiter">,</span><span class=""> </span><span class="">pure</span><span class="delimiter">)</span><span class=""> </span><span class="">pure</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="">standard</span><span class=""> </span><span class="delimiter">(</span><span class="">induct_tac</span><span class=""> </span><span class="">x</span><span class="delimiter">,</span><span class=""> </span><span class="">simp_all</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">permute_pure</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">instance</span><span class=""> </span><span class="">list</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="delimiter">(</span><span class="">pure</span><span class="delimiter">)</span><span class=""> </span><span class="">pure</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="">standard</span><span class=""> </span><span class="delimiter">(</span><span class="">induct_tac</span><span class=""> </span><span class="">x</span><span class="delimiter">,</span><span class=""> </span><span class="">simp_all</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">permute_pure</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">instance</span><span class=""> </span><span class="">option</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="delimiter">(</span><span class="">pure</span><span class="delimiter">)</span><span class=""> </span><span class="">pure</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="">standard</span><span class=""> </span><span class="delimiter">(</span><span class="">induct_tac</span><span class=""> </span><span class="">x</span><span class="delimiter">,</span><span class=""> </span><span class="">simp_all</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">permute_pure</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="">
</span><span class="keyword1">subsection</span><span class=""> </span><span class="verbatim">{* Types @{typ char}, @{typ nat}, and @{typ int} *}</span><span class="">
</span><span class="">
</span><span class="keyword1">instance</span><span class=""> </span><span class="">char</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="">pure</span><span class="">
</span><span class="keyword1">proof</span><span class=""> </span><span class="keyword1">qed</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">permute_char_def</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">instance</span><span class=""> </span><span class="">nat</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="">pure</span><span class="">
</span><span class="keyword1">proof</span><span class=""> </span><span class="keyword1">qed</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">permute_nat_def</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">instance</span><span class=""> </span><span class="">int</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="">pure</span><span class="">
</span><span class="keyword1">proof</span><span class=""> </span><span class="keyword1">qed</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">permute_int_def</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="">
</span><span class="keyword1">section</span><span class=""> </span><span class="verbatim">{* Infrastructure for Equivariance and Perm_simp *}</span><span class="">
</span><span class="">
</span><span class="keyword1">subsection</span><span class=""> </span><span class="verbatim">{* Basic functions about permutations *}</span><span class="">
</span><span class="">
</span><span class="keyword1">ML_file</span><span class=""> </span><span class="string">&quot;nominal_basics.ML&quot;</span><span class="">
</span><span class="">
</span><span class="">
</span><span class="keyword1">subsection</span><span class=""> </span><span class="verbatim">{* Eqvt infrastructure *}</span><span class="">
</span><span class="">
</span><span class="keyword1">text</span><span class=""> </span><span class="verbatim">{* Setup of the theorem attributes @{text eqvt} and @{text eqvt_raw}. *}</span><span class="">
</span><span class="">                   
</span><span class="keyword1">ML_file</span><span class=""> </span><span class="string">&quot;nominal_thmdecls.ML&quot;</span><span class="">
</span><span class="">
</span><span class="">
</span><span class="keyword1">lemmas</span><span class=""> </span><span class="delimiter">[</span><span class="">eqvt</span><span class="delimiter">]</span><span class=""> </span><span class="delimiter">=</span><span class="">
</span><span class="">  </span><span class="comment">(* pt types *)</span><span class="">
</span><span class="">  </span><span class="">permute_prod.simps</span><span class=""> 
</span><span class="">  </span><span class="">permute_list.simps</span><span class=""> 
</span><span class="">  </span><span class="">permute_option.simps</span><span class=""> 
</span><span class="">  </span><span class="">permute_sum.simps</span><span class="">
</span><span class="">
</span><span class="">  </span><span class="comment">(* sets *)</span><span class="">
</span><span class="">  </span><span class="">empty_eqvt</span><span class=""> </span><span class="">insert_eqvt</span><span class=""> </span><span class="">set_eqvt</span><span class=""> 
</span><span class="">
</span><span class="">  </span><span class="comment">(* fsets *)</span><span class="">
</span><span class="">  </span><span class="">permute_fset</span><span class=""> </span><span class="">fset_eqvt</span><span class="">
</span><span class="">
</span><span class="">  </span><span class="comment">(* multisets *)</span><span class="">
</span><span class="">  </span><span class="">permute_multiset</span><span class="">
</span><span class="">
</span><span class="keyword1">subsection</span><span class=""> </span><span class="verbatim">{* perm_simp infrastructure *}</span><span class="">
</span><span class="">
</span><span class="keyword1">definition</span><span class="">
</span><span class="">  </span><span class="string">&quot;unpermute p = permute (- p)&quot;</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">eqvt_apply</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">fixes</span><span class=""> </span><span class="">f</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;&#39;a::pt &#8658; &#39;b::pt&quot;</span><span class=""> 
</span><span class="">  </span><span class="keyword2">and</span><span class=""> </span><span class="">x</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;&#39;a::pt&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;p &#8729; (f x) &#8801; (p &#8729; f) (p &#8729; x)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">permute_fun_def</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">eqvt_lambda</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">fixes</span><span class=""> </span><span class="">f</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;&#39;a::pt &#8658; &#39;b::pt&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;p &#8729; f &#8801; (&#955;x. p &#8729; (f (unpermute p x)))&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">permute_fun_def</span><span class=""> </span><span class="">unpermute_def</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">eqvt_bound</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;p &#8729; unpermute p x &#8801; x&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">unpermute_def</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">
</span><span class="keyword1">text</span><span class=""> </span><span class="verbatim">{* provides perm_simp methods *}</span><span class="">
</span><span class="">
</span><span class="keyword1">ML_file</span><span class=""> </span><span class="string">&quot;nominal_permeq.ML&quot;</span><span class="">
</span><span class="">
</span><span class="keyword1">method_setup</span><span class=""> </span><span class="">perm_simp</span><span class=""> </span><span class="delimiter">=</span><span class="">
</span><span class=""> </span><span class="verbatim">{* Nominal_Permeq.args_parser &gt;&gt; Nominal_Permeq.perm_simp_meth *}</span><span class="">
</span><span class=""> </span><span class="verbatim">{* pushes permutations inside. *}</span><span class="">
</span><span class="">
</span><span class="keyword1">method_setup</span><span class=""> </span><span class="">perm_strict_simp</span><span class=""> </span><span class="delimiter">=</span><span class="">
</span><span class=""> </span><span class="verbatim">{* Nominal_Permeq.args_parser &gt;&gt; Nominal_Permeq.perm_strict_simp_meth *}</span><span class="">
</span><span class=""> </span><span class="verbatim">{* pushes permutations inside, raises an error if it cannot solve all permutations. *}</span><span class="">
</span><span class="">
</span><span class="keyword1">simproc_setup</span><span class=""> </span><span class="">perm_simproc</span><span class=""> </span><span class="delimiter">(</span><span class="string">&quot;p &#8729; t&quot;</span><span class="delimiter">)</span><span class=""> </span><span class="delimiter">=</span><span class=""> </span><span class="verbatim">{* fn _ =&gt; fn ctxt =&gt; fn ctrm =&gt;
  case Thm.term_of (Thm.dest_arg ctrm) of 
    Free _ =&gt; NONE
  | Var _ =&gt; NONE
  | Const (@{const_name permute}, _) $ _ $ _ =&gt; NONE
  | _ =&gt;
      let
        val thm = Nominal_Permeq.eqvt_conv ctxt Nominal_Permeq.eqvt_strict_config ctrm
          handle ERROR _ =&gt; Thm.reflexive ctrm
      in
        if Thm.is_reflexive thm then NONE else SOME(thm)
      end
*}</span><span class="">
</span><span class="">
</span><span class="">
</span><span class="keyword1">subsubsection</span><span class=""> </span><span class="verbatim">{* Equivariance for permutations and swapping *}</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">permute_eqvt</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;p &#8729; (q &#8729; x) = (p &#8729; q) &#8729; (p &#8729; x)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">permute_perm_def</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">
</span><span class="comment">(* the normal version of this lemma would cause loops *)</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">permute_eqvt_raw</span><span class=""> </span><span class="delimiter">[</span><span class="">eqvt_raw</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;p &#8729; permute &#8801; permute&quot;</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">fun_eq_iff</span><span class=""> </span><span class="">permute_fun_def</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">subst</span><span class=""> </span><span class="">permute_eqvt</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">simp</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">done</span></span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">zero_perm_eqvt</span><span class=""> </span><span class="delimiter">[</span><span class="">eqvt</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;p &#8729; (0::perm) = 0&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">permute_perm_def</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">add_perm_eqvt</span><span class=""> </span><span class="delimiter">[</span><span class="">eqvt</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">fixes</span><span class=""> </span><span class="">p</span><span class=""> </span><span class="">p1</span><span class=""> </span><span class="">p2</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="">perm</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;p &#8729; (p1 + p2) = p &#8729; p1 + p &#8729; p2&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">permute_perm_def</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">perm_eq_iff</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">swap_eqvt</span><span class=""> </span><span class="delimiter">[</span><span class="">eqvt</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;p &#8729; (a &#8652; b) = (p &#8729; a &#8652; p &#8729; b)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">permute_perm_def</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class="delimiter">:</span><span class=""> </span><span class="">swap_atom</span><span class=""> </span><span class="">perm_eq_iff</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">uminus_eqvt</span><span class=""> </span><span class="delimiter">[</span><span class="">eqvt</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">fixes</span><span class=""> </span><span class="">p</span><span class=""> </span><span class="">q</span><span class="delimiter">::</span><span class="string">&quot;perm&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;p &#8729; (- q) = - (p &#8729; q)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">permute_perm_def</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">diff_add_eq_diff_diff_swap</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="">
</span><span class="keyword1">subsubsection</span><span class=""> </span><span class="verbatim">{* Equivariance of Logical Operators *}</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">eq_eqvt</span><span class=""> </span><span class="delimiter">[</span><span class="">eqvt</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;p &#8729; (x = y) &#10231; (p &#8729; x) = (p &#8729; y)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">permute_eq_iff</span><span class=""> </span><span class="">permute_bool_def</span><span class=""> </span><span class="keyword1">..</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">Not_eqvt</span><span class=""> </span><span class="delimiter">[</span><span class="">eqvt</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;p &#8729; (&#172; A) &#10231; &#172; (p &#8729; A)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">permute_bool_def</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">conj_eqvt</span><span class=""> </span><span class="delimiter">[</span><span class="">eqvt</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;p &#8729; (A &#8743; B) &#10231; (p &#8729; A) &#8743; (p &#8729; B)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">permute_bool_def</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">imp_eqvt</span><span class=""> </span><span class="delimiter">[</span><span class="">eqvt</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;p &#8729; (A &#10230; B) &#10231; (p &#8729; A) &#10230; (p &#8729; B)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">permute_bool_def</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">declare</span><span class=""> </span><span class="">imp_eqvt</span><span class="delimiter">[</span><span class="">folded</span><span class=""> </span><span class="">HOL.induct_implies_def</span><span class="delimiter">,</span><span class=""> </span><span class="">eqvt</span><span class="delimiter">]</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">all_eqvt</span><span class=""> </span><span class="delimiter">[</span><span class="">eqvt</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;p &#8729; (&#8704;x. P x) = (&#8704;x. (p &#8729; P) x)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">All_def</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">perm_simp</span><span class="delimiter">)</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">refl</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">declare</span><span class=""> </span><span class="">all_eqvt</span><span class="delimiter">[</span><span class="">folded</span><span class=""> </span><span class="">HOL.induct_forall_def</span><span class="delimiter">,</span><span class=""> </span><span class="">eqvt</span><span class="delimiter">]</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">ex_eqvt</span><span class=""> </span><span class="delimiter">[</span><span class="">eqvt</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;p &#8729; (&#8707;x. P x) = (&#8707;x. (p &#8729; P) x)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">Ex_def</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">perm_simp</span><span class="delimiter">)</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">refl</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">ex1_eqvt</span><span class=""> </span><span class="delimiter">[</span><span class="">eqvt</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;p &#8729; (&#8707;!x. P x) = (&#8707;!x. (p &#8729; P) x)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">Ex1_def</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">perm_simp</span><span class="delimiter">)</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">refl</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">if_eqvt</span><span class=""> </span><span class="delimiter">[</span><span class="">eqvt</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;p &#8729; (if b then x else y) = (if p &#8729; b then p &#8729; x else p &#8729; y)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">permute_fun_def</span><span class=""> </span><span class="">permute_bool_def</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">True_eqvt</span><span class=""> </span><span class="delimiter">[</span><span class="">eqvt</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;p &#8729; True = True&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">permute_bool_def</span><span class=""> </span><span class="keyword1">..</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">False_eqvt</span><span class=""> </span><span class="delimiter">[</span><span class="">eqvt</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;p &#8729; False = False&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">permute_bool_def</span><span class=""> </span><span class="keyword1">..</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">disj_eqvt</span><span class=""> </span><span class="delimiter">[</span><span class="">eqvt</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;p &#8729; (A &#8744; B) &#10231; (p &#8729; A) &#8744; (p &#8729; B)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">permute_bool_def</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">all_eqvt2</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;p &#8729; (&#8704;x. P x) = (&#8704;x. p &#8729; P (- p &#8729; x))&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">perm_simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">permute_minus_cancel</span><span class="delimiter">)</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">refl</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">ex_eqvt2</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;p &#8729; (&#8707;x. P x) = (&#8707;x. p &#8729; P (- p &#8729; x))&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">perm_simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">permute_minus_cancel</span><span class="delimiter">)</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">refl</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">ex1_eqvt2</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;p &#8729; (&#8707;!x. P x) = (&#8707;!x. p &#8729; P (- p &#8729; x))&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">perm_simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">permute_minus_cancel</span><span class="delimiter">)</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">refl</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">the_eqvt</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="">unique</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;&#8707;!x. P x&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;(p &#8729; (THE x. P x)) = (THE x. (p &#8729; P) x)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">the1_equality</span><span class=""> </span><span class="delimiter">[</span><span class="">symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">rule_tac</span><span class=""> </span><span class="">p</span><span class="delimiter">=</span><span class="string">&quot;-p&quot;</span><span class=""> </span><span class="keyword2">in</span><span class=""> </span><span class="">permute_boolE</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">perm_simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">permute_minus_cancel</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">unique</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">rule_tac</span><span class=""> </span><span class="">p</span><span class="delimiter">=</span><span class="string">&quot;-p&quot;</span><span class=""> </span><span class="keyword2">in</span><span class=""> </span><span class="">permute_boolE</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">perm_simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">permute_minus_cancel</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">theI&#39;</span><span class="delimiter">[</span><span class="">OF</span><span class=""> </span><span class="">unique</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">done</span></span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">the_eqvt2</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="">unique</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;&#8707;!x. P x&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;(p &#8729; (THE x. P x)) = (THE x. p &#8729; P (- p &#8729; x))&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">the1_equality</span><span class=""> </span><span class="delimiter">[</span><span class="">symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">only</span><span class="delimiter">:</span><span class=""> </span><span class="">ex1_eqvt2</span><span class="delimiter">[</span><span class="">symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">permute_bool_def</span><span class=""> </span><span class="">unique</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">permute_bool_def</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">theI&#39;</span><span class="delimiter">[</span><span class="">OF</span><span class=""> </span><span class="">unique</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">done</span></span><span class="">
</span><span class="">
</span><span class="keyword1">subsubsection</span><span class=""> </span><span class="verbatim">{* Equivariance of Set operators *}</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">mem_eqvt</span><span class=""> </span><span class="delimiter">[</span><span class="">eqvt</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;p &#8729; (x &#8712; A) &#10231; (p &#8729; x) &#8712; (p &#8729; A)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">permute_bool_def</span><span class=""> </span><span class="">permute_set_def</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">Collect_eqvt</span><span class=""> </span><span class="delimiter">[</span><span class="">eqvt</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;p &#8729; {x. P x} = {x. (p &#8729; P) x}&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">permute_set_eq</span><span class=""> </span><span class="">permute_fun_def</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class="delimiter">:</span><span class=""> </span><span class="">permute_bool_def</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">inter_eqvt</span><span class=""> </span><span class="delimiter">[</span><span class="">eqvt</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;p &#8729; (A &#8745; B) = (p &#8729; A) &#8745; (p &#8729; B)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">Int_def</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">Bex_eqvt</span><span class=""> </span><span class="delimiter">[</span><span class="">eqvt</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;p &#8729; (&#8707;x &#8712; S. P x) = (&#8707;x &#8712; (p &#8729; S). (p &#8729; P) x)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">Bex_def</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">Ball_eqvt</span><span class=""> </span><span class="delimiter">[</span><span class="">eqvt</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;p &#8729; (&#8704;x &#8712; S. P x) = (&#8704;x &#8712; (p &#8729; S). (p &#8729; P) x)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">Ball_def</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">image_eqvt</span><span class=""> </span><span class="delimiter">[</span><span class="">eqvt</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;p &#8729; (f ` A) = (p &#8729; f) ` (p &#8729; A)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">image_def</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">Image_eqvt</span><span class=""> </span><span class="delimiter">[</span><span class="">eqvt</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;p &#8729; (R `` A) = (p &#8729; R) `` (p &#8729; A)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">Image_def</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">UNIV_eqvt</span><span class=""> </span><span class="delimiter">[</span><span class="">eqvt</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;p &#8729; UNIV = UNIV&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">UNIV_def</span><span class=""> 
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">perm_simp</span><span class="delimiter">)</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">refl</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">union_eqvt</span><span class=""> </span><span class="delimiter">[</span><span class="">eqvt</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;p &#8729; (A &#8746; B) = (p &#8729; A) &#8746; (p &#8729; B)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">Un_def</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">UNION_eqvt</span><span class=""> </span><span class="delimiter">[</span><span class="">eqvt</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;p &#8729; (UNION A f) = (UNION (p &#8729; A) (p &#8729; f))&quot;</span><span class="">
</span><span class="keyword1">unfolding</span><span class=""> </span><span class="">UNION_eq</span><span class="">
</span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">perm_simp</span><span class="delimiter">)</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">Diff_eqvt</span><span class=""> </span><span class="delimiter">[</span><span class="">eqvt</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">fixes</span><span class=""> </span><span class="">A</span><span class=""> </span><span class="">B</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;&#39;a::pt set&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;p &#8729; (A - B) = (p &#8729; A) - (p &#8729; B)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">set_diff_eq</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">Compl_eqvt</span><span class=""> </span><span class="delimiter">[</span><span class="">eqvt</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">fixes</span><span class=""> </span><span class="">A</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;&#39;a::pt set&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;p &#8729; (- A) = - (p &#8729; A)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">Compl_eq_Diff_UNIV</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">subset_eqvt</span><span class=""> </span><span class="delimiter">[</span><span class="">eqvt</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;p &#8729; (S &#8838; T) &#10231; (p &#8729; S) &#8838; (p &#8729; T)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">subset_eq</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">psubset_eqvt</span><span class=""> </span><span class="delimiter">[</span><span class="">eqvt</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;p &#8729; (S &#8834; T) &#10231; (p &#8729; S) &#8834; (p &#8729; T)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">psubset_eq</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">vimage_eqvt</span><span class=""> </span><span class="delimiter">[</span><span class="">eqvt</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;p &#8729; (f -` A) = (p &#8729; f) -` (p &#8729; A)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">vimage_def</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">Union_eqvt</span><span class=""> </span><span class="delimiter">[</span><span class="">eqvt</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;p &#8729; (&#8899; S) = &#8899; (p &#8729; S)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">Union_eq</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">Inter_eqvt</span><span class=""> </span><span class="delimiter">[</span><span class="">eqvt</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;p &#8729; (&#8898; S) = &#8898; (p &#8729; S)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">Inter_eq</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">
</span><span class="keyword1">thm</span><span class=""> </span><span class="">foldr.simps</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">foldr_eqvt</span><span class="delimiter">[</span><span class="">eqvt</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="string">&quot;p &#8729; foldr f xs = foldr (p &#8729; f) (p &#8729; xs)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">xs</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">simp_all</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">perm_simp</span><span class=""> </span><span class="">exclude</span><span class="delimiter">:</span><span class=""> </span><span class="">foldr</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">simp</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">done</span></span><span class="">
</span><span class="">
</span><span class="comment">(* FIXME: eqvt attribute *)</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">Sigma_eqvt</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;(p &#8729; (X &#215; Y)) = (p &#8729; X) &#215; (p &#8729; Y)&quot;</span><span class="">
</span><span class="keyword1">unfolding</span><span class=""> </span><span class="">Sigma_def</span><span class="">
</span><span class="keyword1">unfolding</span><span class=""> </span><span class="">SUP_def</span><span class="">
</span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">perm_simp</span><span class="delimiter">)</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">refl</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">text</span><span class=""> </span><span class="verbatim">{* 
  In order to prove that lfp is equivariant we need two
  auxiliary classes which specify that (op &lt;=) and
  Inf are equivariant. Instances for bool and fun are 
  given.
*}</span><span class="">
</span><span class="">
</span><span class="keyword1">class</span><span class=""> </span><span class="">le_eqvt</span><span class=""> </span><span class="delimiter">=</span><span class=""> </span><span class="">order</span><span class=""> </span><span class="delimiter">+</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="">le_eqvt</span><span class=""> </span><span class="delimiter">[</span><span class="">eqvt</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;p &#8729; (x &#8804; y) = ((p &#8729; x) &#8804; (p &#8729; (y::(&#39;a::{pt, order}))))&quot;</span><span class="">
</span><span class="">
</span><span class="keyword1">class</span><span class=""> </span><span class="">inf_eqvt</span><span class=""> </span><span class="delimiter">=</span><span class=""> </span><span class="">Inf</span><span class=""> </span><span class="delimiter">+</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="">inf_eqvt</span><span class=""> </span><span class="delimiter">[</span><span class="">eqvt</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;p &#8729; (Inf X) = Inf (p &#8729; (X::(&#39;a::{pt, complete_lattice}) set))&quot;</span><span class="">
</span><span class="">
</span><span class="keyword1">instantiation</span><span class=""> </span><span class="">bool</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="">le_eqvt</span><span class="">
</span><span class="keyword2">begin</span><span class="">
</span><span class="">
</span><span class="keyword1">instance</span><span class=""> 
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="">standard</span><span class="">
</span><span class="keyword1">unfolding</span><span class=""> </span><span class="">le_bool_def</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">perm_simp</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">refl</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">done</span></span><span class="">
</span><span class="">
</span><span class="keyword2">end</span><span class="">
</span><span class="">
</span><span class="keyword1">instantiation</span><span class=""> </span><span class="string">&quot;fun&quot;</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="delimiter">(</span><span class="">pt</span><span class="delimiter">,</span><span class=""> </span><span class="">le_eqvt</span><span class="delimiter">)</span><span class=""> </span><span class="">le_eqvt</span><span class="">
</span><span class="keyword2">begin</span><span class="">
</span><span class="">
</span><span class="keyword1">instance</span><span class=""> 
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="">standard</span><span class="">
</span><span class="keyword1">unfolding</span><span class=""> </span><span class="">le_fun_def</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">perm_simp</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">refl</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">done</span></span><span class=""> 
</span><span class="">
</span><span class="keyword2">end</span><span class="">
</span><span class="">
</span><span class="keyword1">instantiation</span><span class=""> </span><span class="">bool</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="">inf_eqvt</span><span class="">
</span><span class="keyword2">begin</span><span class="">
</span><span class="">
</span><span class="keyword1">instance</span><span class=""> 
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="">standard</span><span class="">
</span><span class="keyword1">unfolding</span><span class=""> </span><span class="">Inf_bool_def</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">perm_simp</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">refl</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">done</span></span><span class="">
</span><span class="">
</span><span class="keyword2">end</span><span class="">
</span><span class="">
</span><span class="keyword1">instantiation</span><span class=""> </span><span class="string">&quot;fun&quot;</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="delimiter">(</span><span class="">pt</span><span class="delimiter">,</span><span class=""> </span><span class="">inf_eqvt</span><span class="delimiter">)</span><span class=""> </span><span class="">inf_eqvt</span><span class="">
</span><span class="keyword2">begin</span><span class="">
</span><span class="">
</span><span class="keyword1">instance</span><span class=""> 
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="">standard</span><span class="">
</span><span class="keyword1">unfolding</span><span class=""> </span><span class="">Inf_fun_def</span><span class=""> </span><span class="">INF_def</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">perm_simp</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">refl</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">done</span></span><span class=""> 
</span><span class="">
</span><span class="keyword2">end</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">lfp_eqvt</span><span class=""> </span><span class="delimiter">[</span><span class="">eqvt</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">fixes</span><span class=""> </span><span class="">F</span><span class="delimiter">::</span><span class="string">&quot;(&#39;a &#8658; &#39;b) &#8658; (&#39;a::pt &#8658; &#39;b::{inf_eqvt, le_eqvt})&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;p &#8729; (lfp F) = lfp (p &#8729; F)&quot;</span><span class="">
</span><span class="keyword1">unfolding</span><span class=""> </span><span class="">lfp_def</span><span class="">
</span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">finite_eqvt</span><span class=""> </span><span class="delimiter">[</span><span class="">eqvt</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;p &#8729; finite A = finite (p &#8729; A)&quot;</span><span class="">
</span><span class="keyword1">unfolding</span><span class=""> </span><span class="">finite_def</span><span class="">
</span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">fun_upd_eqvt</span><span class="delimiter">[</span><span class="">eqvt</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;p &#8729; (f(x := y)) = (p &#8729; f)((p &#8729; x) := (p &#8729; y))&quot;</span><span class="">
</span><span class="keyword1">unfolding</span><span class=""> </span><span class="">fun_upd_def</span><span class="">
</span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">comp_eqvt</span><span class=""> </span><span class="delimiter">[</span><span class="">eqvt</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;p &#8729; (f &#8728; g) = (p &#8729; f) &#8728; (p &#8729; g)&quot;</span><span class="">
</span><span class="keyword1">unfolding</span><span class=""> </span><span class="">comp_def</span><span class="">
</span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">
</span><span class="keyword1">subsubsection</span><span class=""> </span><span class="verbatim">{* Equivariance for product operations *}</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">fst_eqvt</span><span class=""> </span><span class="delimiter">[</span><span class="">eqvt</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;p &#8729; (fst x) = fst (p &#8729; x)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">cases</span><span class=""> </span><span class="">x</span><span class="delimiter">)</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">snd_eqvt</span><span class=""> </span><span class="delimiter">[</span><span class="">eqvt</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;p &#8729; (snd x) = snd (p &#8729; x)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">cases</span><span class=""> </span><span class="">x</span><span class="delimiter">)</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">split_eqvt</span><span class=""> </span><span class="delimiter">[</span><span class="">eqvt</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> 
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;p &#8729; (case_prod P x) = case_prod (p &#8729; P) (p &#8729; x)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">split_def</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">
</span><span class="">
</span><span class="keyword1">subsubsection</span><span class=""> </span><span class="verbatim">{* Equivariance for list operations *}</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">append_eqvt</span><span class=""> </span><span class="delimiter">[</span><span class="">eqvt</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;p &#8729; (xs @ ys) = (p &#8729; xs) @ (p &#8729; ys)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">xs</span><span class="delimiter">)</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">rev_eqvt</span><span class=""> </span><span class="delimiter">[</span><span class="">eqvt</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;p &#8729; (rev xs) = rev (p &#8729; xs)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">xs</span><span class="delimiter">)</span><span class=""> </span><span class="delimiter">(</span><span class="">simp_all</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">append_eqvt</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">map_eqvt</span><span class=""> </span><span class="delimiter">[</span><span class="">eqvt</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> 
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;p &#8729; (map f xs) = map (p &#8729; f) (p &#8729; xs)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">xs</span><span class="delimiter">)</span><span class=""> </span><span class="delimiter">(</span><span class="">simp_all</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">removeAll_eqvt</span><span class=""> </span><span class="delimiter">[</span><span class="">eqvt</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;p &#8729; (removeAll x xs) = removeAll (p &#8729; x) (p &#8729; xs)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">xs</span><span class="delimiter">)</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">filter_eqvt</span><span class=""> </span><span class="delimiter">[</span><span class="">eqvt</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;p &#8729; (filter f xs) = filter (p &#8729; f) (p &#8729; xs)&quot;</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">xs</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">simp</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">only</span><span class="delimiter">:</span><span class=""> </span><span class="">filter.simps</span><span class=""> </span><span class="">permute_list.simps</span><span class=""> </span><span class="">if_eqvt</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">only</span><span class="delimiter">:</span><span class=""> </span><span class="">permute_fun_app_eq</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">done</span></span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">distinct_eqvt</span><span class=""> </span><span class="delimiter">[</span><span class="">eqvt</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;p &#8729; (distinct xs) = distinct (p &#8729; xs)&quot;</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">xs</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">permute_bool_def</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">conj_eqvt</span><span class=""> </span><span class="">Not_eqvt</span><span class=""> </span><span class="">mem_eqvt</span><span class=""> </span><span class="">set_eqvt</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">done</span></span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">length_eqvt</span><span class=""> </span><span class="delimiter">[</span><span class="">eqvt</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;p &#8729; (length xs) = length (p &#8729; xs)&quot;</span><span class="">
</span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">xs</span><span class="delimiter">)</span><span class=""> </span><span class="delimiter">(</span><span class="">simp_all</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">permute_pure</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="">
</span><span class="keyword1">subsubsection</span><span class=""> </span><span class="verbatim">{* Equivariance for @{typ &quot;&#39;a option&quot;} *}</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">map_option_eqvt</span><span class="delimiter">[</span><span class="">eqvt</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;p &#8729; (map_option f x) = map_option (p &#8729; f) (p &#8729; x)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">cases</span><span class=""> </span><span class="">x</span><span class="delimiter">)</span><span class=""> </span><span class="delimiter">(</span><span class="">simp_all</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="">
</span><span class="keyword1">subsubsection</span><span class=""> </span><span class="verbatim">{* Equivariance for @{typ &quot;&#39;a fset&quot;} *}</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">in_fset_eqvt</span><span class=""> </span><span class="delimiter">[</span><span class="">eqvt</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;(p &#8729; (x |&#8712;| S)) = ((p &#8729; x) |&#8712;| (p &#8729; S))&quot;</span><span class="">
</span><span class="keyword1">unfolding</span><span class=""> </span><span class="">in_fset</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">union_fset_eqvt</span><span class=""> </span><span class="delimiter">[</span><span class="">eqvt</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;(p &#8729; (S |&#8746;| T)) = ((p &#8729; S) |&#8746;| (p &#8729; T))&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">S</span><span class="delimiter">)</span><span class=""> </span><span class="delimiter">(</span><span class="">simp_all</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">inter_fset_eqvt</span><span class=""> </span><span class="delimiter">[</span><span class="">eqvt</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;(p &#8729; (S |&#8745;| T)) = ((p &#8729; S) |&#8745;| (p &#8729; T))&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">descending</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">list_eq_def</span><span class=""> </span><span class="">inter_list_def</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">simp</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">done</span></span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">subset_fset_eqvt</span><span class=""> </span><span class="delimiter">[</span><span class="">eqvt</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;(p &#8729; (S |&#8838;| T)) = ((p &#8729; S) |&#8838;| (p &#8729; T))&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">descending</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">sub_list_def</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">simp</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">done</span></span><span class="">
</span><span class="">  
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">map_fset_eqvt</span><span class=""> </span><span class="delimiter">[</span><span class="">eqvt</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> 
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;p &#8729; (map_fset f S) = map_fset (p &#8729; f) (p &#8729; S)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">lifting</span><span class=""> </span><span class="">map_eqvt</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">subsubsection</span><span class=""> </span><span class="verbatim">{* Equivariance for @{typ &quot;(&#39;a, &#39;b) finfun&quot;} *}</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">finfun_update_eqvt</span><span class=""> </span><span class="delimiter">[</span><span class="">eqvt</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;(p &#8729; (finfun_update f a b)) = finfun_update (p &#8729; f) (p &#8729; a) (p &#8729; b)&quot;</span><span class="">
</span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">transfer</span><span class="delimiter">)</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">finfun_const_eqvt</span><span class=""> </span><span class="delimiter">[</span><span class="">eqvt</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;(p &#8729; (finfun_const b)) = finfun_const (p &#8729; b)&quot;</span><span class="">
</span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">transfer</span><span class="delimiter">)</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">finfun_apply_eqvt</span><span class=""> </span><span class="delimiter">[</span><span class="">eqvt</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;(p &#8729; (finfun_apply f b)) = finfun_apply (p &#8729; f) (p &#8729; b)&quot;</span><span class="">
</span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">transfer</span><span class="delimiter">)</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="">
</span><span class="keyword1">section</span><span class=""> </span><span class="verbatim">{* Supp, Freshness and Supports *}</span><span class="">
</span><span class="">
</span><span class="keyword1">context</span><span class=""> </span><span class="">pt</span><span class="">
</span><span class="keyword2">begin</span><span class="">
</span><span class="">
</span><span class="keyword1">definition</span><span class="">
</span><span class="">  </span><span class="">supp</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;&#39;a &#8658; atom set&quot;</span><span class="">
</span><span class="keyword2">where</span><span class="">
</span><span class="">  </span><span class="string">&quot;supp x = {a. infinite {b. (a &#8652; b) &#8729; x &#8800; x}}&quot;</span><span class="">
</span><span class="">
</span><span class="keyword1">definition</span><span class="">
</span><span class="">  </span><span class="">fresh</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;atom &#8658; &#39;a &#8658; bool&quot;</span><span class=""> </span><span class="delimiter">(</span><span class="string">&quot;_ &#9839; _&quot;</span><span class=""> </span><span class="delimiter">[</span><span class="">55</span><span class="delimiter">,</span><span class=""> </span><span class="">55</span><span class="delimiter">]</span><span class=""> </span><span class="">55</span><span class="delimiter">)</span><span class="">
</span><span class="keyword2">where</span><span class="">   
</span><span class="">  </span><span class="string">&quot;a &#9839; x &#8801; a &#8713; supp x&quot;</span><span class="">
</span><span class="">
</span><span class="keyword2">end</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">supp_conv_fresh</span><span class="delimiter">:</span><span class=""> 
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;supp x = {a. &#172; a &#9839; x}&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">fresh_def</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">swap_rel_trans</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="string">&quot;sort_of a = sort_of b&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="string">&quot;sort_of b = sort_of c&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="string">&quot;(a &#8652; c) &#8729; x = x&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="string">&quot;(b &#8652; c) &#8729; x = x&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;(a &#8652; b) &#8729; x = x&quot;</span><span class="">
</span><span class="keyword1">proof</span><span class=""> </span><span class="delimiter">(</span><span class="">cases</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword3">assume</span><span class=""> </span><span class="string">&quot;a = b &#8744; c = b&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">with</span><span class=""> </span><span class="">assms</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;(a &#8652; b) &#8729; x = x&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="keyword1">next</span><span class="">
</span><span class="">  </span><span class="keyword3">assume</span><span class=""> </span><span class="">*</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;&#172; (a = b &#8744; c = b)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;((a &#8652; c) + (b &#8652; c) + (a &#8652; c)) &#8729; x = x&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">using</span><span class=""> </span><span class="">assms</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">  </span><span class="keyword1">also</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;(a &#8652; c) + (b &#8652; c) + (a &#8652; c) = (a &#8652; b)&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">using</span><span class=""> </span><span class="">assms</span><span class=""> </span><span class="">*</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">swap_triple</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">finally</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;(a &#8652; b) &#8729; x = x&quot;</span><span class=""> </span><span class="keyword1">.</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">swap_fresh_fresh</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="">a</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;a &#9839; x&quot;</span><span class=""> 
</span><span class="">  </span><span class="keyword2">and</span><span class="">     </span><span class="">b</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;b &#9839; x&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;(a &#8652; b) &#8729; x = x&quot;</span><span class="">
</span><span class="keyword1">proof</span><span class=""> </span><span class="delimiter">(</span><span class="">cases</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword3">assume</span><span class=""> </span><span class="">asm</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;sort_of a = sort_of b&quot;</span><span class=""> 
</span><span class="">  </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;finite {c. (a &#8652; c) &#8729; x &#8800; x}&quot;</span><span class=""> </span><span class="string">&quot;finite {c. (b &#8652; c) &#8729; x &#8800; x}&quot;</span><span class=""> 
</span><span class="">    </span><span class="keyword1">using</span><span class=""> </span><span class="">a</span><span class=""> </span><span class="">b</span><span class=""> </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">fresh_def</span><span class=""> </span><span class="">supp_def</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp_all</span><span class="">
</span><span class="">  </span><span class="keyword1">then</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;finite ({c. (a &#8652; c) &#8729; x &#8800; x} &#8746; {c. (b &#8652; c) &#8729; x &#8800; x})&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">  </span><span class="keyword1">then</span><span class=""> </span><span class="keyword3">obtain</span><span class=""> </span><span class="">c</span><span class=""> 
</span><span class="">    </span><span class="keyword2">where</span><span class=""> </span><span class="string">&quot;(a &#8652; c) &#8729; x = x&quot;</span><span class=""> </span><span class="string">&quot;(b &#8652; c) &#8729; x = x&quot;</span><span class=""> </span><span class="string">&quot;sort_of c = sort_of b&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">obtain_atom</span><span class="delimiter">)</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">then</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;(a &#8652; b) &#8729; x = x&quot;</span><span class=""> </span><span class="keyword1">using</span><span class=""> </span><span class="">asm</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">rule_tac</span><span class=""> </span><span class="">swap_rel_trans</span><span class="delimiter">)</span><span class=""> </span><span class="delimiter">(</span><span class="">simp_all</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1">next</span><span class="">
</span><span class="">  </span><span class="keyword3">assume</span><span class=""> </span><span class="string">&quot;sort_of a &#8800; sort_of b&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">then</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;(a &#8652; b) &#8729; x = x&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="">
</span><span class="keyword1">subsection</span><span class=""> </span><span class="verbatim">{* supp and fresh are equivariant *}</span><span class="">
</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">supp_eqvt</span><span class=""> </span><span class="delimiter">[</span><span class="">eqvt</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;p &#8729; (supp x) = supp (p &#8729; x)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">supp_def</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">fresh_eqvt</span><span class=""> </span><span class="delimiter">[</span><span class="">eqvt</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;p &#8729; (a &#9839; x) = (p &#8729; a) &#9839; (p &#8729; x)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">fresh_def</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">fresh_permute_iff</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;(p &#8729; a) &#9839; (p &#8729; x) &#10231; a &#9839; x&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">only</span><span class="delimiter">:</span><span class=""> </span><span class="">fresh_eqvt</span><span class="delimiter">[</span><span class="">symmetric</span><span class="delimiter">]</span><span class=""> </span><span class="">permute_bool_def</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">fresh_permute_left</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;a &#9839; p &#8729; x &#10231; - p &#8729; a &#9839; x&quot;</span><span class="">
</span><span class="keyword1">proof</span><span class="">
</span><span class="">  </span><span class="keyword3">assume</span><span class=""> </span><span class="string">&quot;a &#9839; p &#8729; x&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">then</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;- p &#8729; a &#9839; - p &#8729; p &#8729; x&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">only</span><span class="delimiter">:</span><span class=""> </span><span class="">fresh_permute_iff</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">then</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;- p &#8729; a &#9839; x&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="keyword1">next</span><span class="">
</span><span class="">  </span><span class="keyword3">assume</span><span class=""> </span><span class="string">&quot;- p &#8729; a &#9839; x&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">then</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;p &#8729; - p &#8729; a &#9839; p &#8729; x&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">only</span><span class="delimiter">:</span><span class=""> </span><span class="">fresh_permute_iff</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">then</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;a &#9839; p &#8729; x&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="">
</span><span class="keyword1">section</span><span class=""> </span><span class="verbatim">{* supports *}</span><span class="">
</span><span class="">
</span><span class="keyword1">definition</span><span class="">
</span><span class="">  </span><span class="">supports</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;atom set &#8658; &#39;a::pt &#8658; bool&quot;</span><span class=""> </span><span class="delimiter">(</span><span class="keyword2">infixl</span><span class=""> </span><span class="string">&quot;supports&quot;</span><span class=""> </span><span class="">80</span><span class="delimiter">)</span><span class="">
</span><span class="keyword2">where</span><span class="">  
</span><span class="">  </span><span class="string">&quot;S supports x &#8801; &#8704;a b. (a &#8713; S &#8743; b &#8713; S &#10230; (a &#8652; b) &#8729; x = x)&quot;</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">supp_is_subset</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">fixes</span><span class=""> </span><span class="">S</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;atom set&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">and</span><span class="">   </span><span class="">x</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;&#39;a::pt&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="">a1</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;S supports x&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">and</span><span class="">     </span><span class="">a2</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;finite S&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;(supp x) &#8838; S&quot;</span><span class="">
</span><span class="keyword1">proof</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">ccontr</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword3">assume</span><span class=""> </span><span class="string">&quot;&#172; (supp x &#8838; S)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">then</span><span class=""> </span><span class="keyword3">obtain</span><span class=""> </span><span class="">a</span><span class=""> </span><span class="keyword2">where</span><span class=""> </span><span class="">b1</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;a &#8712; supp x&quot;</span><span class=""> </span><span class="keyword2">and</span><span class=""> </span><span class="">b2</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;a &#8713; S&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">  </span><span class="keyword1">from</span><span class=""> </span><span class="">a1</span><span class=""> </span><span class="">b2</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;&#8704;b. b &#8713; S &#10230; (a &#8652; b) &#8729; x = x&quot;</span><span class=""> </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">supports_def</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">  </span><span class="keyword1">then</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;{b. (a &#8652; b) &#8729; x &#8800; x} &#8838; S&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">  </span><span class="keyword1">with</span><span class=""> </span><span class="">a2</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;finite {b. (a &#8652; b) &#8729; x &#8800; x}&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">finite_subset</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">then</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;a &#8713; (supp x)&quot;</span><span class=""> </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">supp_def</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">  </span><span class="keyword1">with</span><span class=""> </span><span class="">b1</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="">False</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">supports_finite</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">fixes</span><span class=""> </span><span class="">S</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;atom set&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">and</span><span class="">   </span><span class="">x</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;&#39;a::pt&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="">a1</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;S supports x&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">and</span><span class="">     </span><span class="">a2</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;finite S&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;finite (supp x)&quot;</span><span class="">
</span><span class="keyword1">proof</span><span class=""> </span><span class="">-</span><span class="">
</span><span class="">  </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;(supp x) &#8838; S&quot;</span><span class=""> </span><span class="keyword1">using</span><span class=""> </span><span class="">a1</span><span class=""> </span><span class="">a2</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">supp_is_subset</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">then</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;finite (supp x)&quot;</span><span class=""> </span><span class="keyword1">using</span><span class=""> </span><span class="">a2</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">finite_subset</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">supp_supports</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">fixes</span><span class=""> </span><span class="">x</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;&#39;a::pt&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;(supp x) supports x&quot;</span><span class="">
</span><span class="keyword1">unfolding</span><span class=""> </span><span class="">supports_def</span><span class="">
</span><span class="keyword1">proof</span><span class=""> </span><span class="delimiter">(</span><span class="">intro</span><span class=""> </span><span class="">strip</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword3">fix</span><span class=""> </span><span class="">a</span><span class=""> </span><span class="">b</span><span class="">
</span><span class="">  </span><span class="keyword3">assume</span><span class=""> </span><span class="string">&quot;a &#8713; (supp x) &#8743; b &#8713; (supp x)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">then</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;a &#9839; x&quot;</span><span class=""> </span><span class="keyword2">and</span><span class=""> </span><span class="string">&quot;b &#9839; x&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp_all</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">fresh_def</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">then</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;(a &#8652; b) &#8729; x = x&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">swap_fresh_fresh</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">supports_fresh</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">fixes</span><span class=""> </span><span class="">x</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;&#39;a::pt&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="">a1</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;S supports x&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">and</span><span class="">     </span><span class="">a2</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;finite S&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">and</span><span class="">     </span><span class="">a3</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;a &#8713; S&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;a &#9839; x&quot;</span><span class="">
</span><span class="keyword1">unfolding</span><span class=""> </span><span class="">fresh_def</span><span class="">
</span><span class="keyword1">proof</span><span class=""> </span><span class="">-</span><span class="">
</span><span class="">  </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;(supp x) &#8838; S&quot;</span><span class=""> </span><span class="keyword1">using</span><span class=""> </span><span class="">a1</span><span class=""> </span><span class="">a2</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">supp_is_subset</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">then</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;a &#8713; (supp x)&quot;</span><span class=""> </span><span class="keyword1">using</span><span class=""> </span><span class="">a3</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">supp_is_least_supports</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">fixes</span><span class=""> </span><span class="">S</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;atom set&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">and</span><span class="">   </span><span class="">x</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;&#39;a::pt&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class="">  </span><span class="">a1</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;S supports x&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">and</span><span class="">      </span><span class="">a2</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;finite S&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">and</span><span class="">      </span><span class="">a3</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;&#8896;S&#39;. finite S&#39; &#10233; (S&#39; supports x) &#10233; S &#8838; S&#39;&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;(supp x) = S&quot;</span><span class="">
</span><span class="keyword1">proof</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">equalityI</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;(supp x) &#8838; S&quot;</span><span class=""> </span><span class="keyword1">using</span><span class=""> </span><span class="">a1</span><span class=""> </span><span class="">a2</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">supp_is_subset</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">with</span><span class=""> </span><span class="">a2</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="">fin</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;finite (supp x)&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">rev_finite_subset</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;(supp x) supports x&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">supp_supports</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">with</span><span class=""> </span><span class="">fin</span><span class=""> </span><span class="">a3</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;S &#8838; supp x&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">blast</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">subsetCI</span><span class="delimiter">:</span><span class=""> 
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;(&#8896;x. x &#8712; A &#10233; x &#8713; B &#10233; False) &#10233; A &#8838; B&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">finite_supp_unique</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="">a1</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;S supports x&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="">a2</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;finite S&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="">a3</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;&#8896;a b. &#10214;a &#8712; S; b &#8713; S; sort_of a = sort_of b&#10215; &#10233; (a &#8652; b) &#8729; x &#8800; x&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;(supp x) = S&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">using</span><span class=""> </span><span class="">a1</span><span class=""> </span><span class="">a2</span><span class="">
</span><span class="keyword1">proof</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">supp_is_least_supports</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword3">fix</span><span class=""> </span><span class="">S&#39;</span><span class="">
</span><span class="">  </span><span class="keyword3">assume</span><span class=""> </span><span class="string">&quot;finite S&#39;&quot;</span><span class=""> </span><span class="keyword2">and</span><span class=""> </span><span class="string">&quot;S&#39; supports x&quot;</span><span class="">
</span><span class="">  </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;S &#8838; S&#39;&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">proof</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">subsetCI</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword3">fix</span><span class=""> </span><span class="">a</span><span class="">
</span><span class="">    </span><span class="keyword3">assume</span><span class=""> </span><span class="string">&quot;a &#8712; S&quot;</span><span class=""> </span><span class="keyword2">and</span><span class=""> </span><span class="string">&quot;a &#8713; S&#39;&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;finite (S &#8746; S&#39;)&quot;</span><span class="">
</span><span class="">      </span><span class="keyword1">using</span><span class=""> </span><span class="alt_string">`finite S`</span><span class=""> </span><span class="alt_string">`finite S&#39;`</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">    </span><span class="keyword1">then</span><span class=""> </span><span class="keyword3">obtain</span><span class=""> </span><span class="">b</span><span class=""> </span><span class="keyword2">where</span><span class=""> </span><span class="string">&quot;b &#8713; S &#8746; S&#39;&quot;</span><span class=""> </span><span class="keyword2">and</span><span class=""> </span><span class="string">&quot;sort_of b = sort_of a&quot;</span><span class="">
</span><span class="">      </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">obtain_atom</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1">then</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;b &#8713; S&quot;</span><span class=""> </span><span class="keyword2">and</span><span class=""> </span><span class="string">&quot;b &#8713; S&#39;&quot;</span><span class="">  </span><span class="keyword2">and</span><span class=""> </span><span class="string">&quot;sort_of a = sort_of b&quot;</span><span class="">
</span><span class="">      </span><span class="keyword1">by</span><span class=""> </span><span class="">simp_all</span><span class="">
</span><span class="">    </span><span class="keyword1">then</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;(a &#8652; b) &#8729; x = x&quot;</span><span class="">
</span><span class="">      </span><span class="keyword1">using</span><span class=""> </span><span class="alt_string">`a &#8713; S&#39;`</span><span class=""> </span><span class="alt_string">`S&#39; supports x`</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">supports_def</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1">moreover</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;(a &#8652; b) &#8729; x &#8800; x&quot;</span><span class="">
</span><span class="">      </span><span class="keyword1">using</span><span class=""> </span><span class="alt_string">`a &#8712; S`</span><span class=""> </span><span class="alt_string">`b &#8713; S`</span><span class=""> </span><span class="alt_string">`sort_of a = sort_of b`</span><span class="">
</span><span class="">      </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">a3</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1">ultimately</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;False&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">  </span><span class="keyword1">qed</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="keyword1">section</span><span class=""> </span><span class="verbatim">{* Support w.r.t. relations *}</span><span class="">
</span><span class="">
</span><span class="keyword1">text</span><span class=""> </span><span class="verbatim">{* 
  This definition is used for unquotient types, where
  alpha-equivalence does not coincide with equality.
*}</span><span class="">
</span><span class="">
</span><span class="keyword1">definition</span><span class=""> 
</span><span class="">  </span><span class="string">&quot;supp_rel R x = {a. infinite {b. &#172;(R ((a &#8652; b) &#8729; x) x)}}&quot;</span><span class="">
</span><span class="">
</span><span class="">
</span><span class="">
</span><span class="keyword1">section</span><span class=""> </span><span class="verbatim">{* Finitely-supported types *}</span><span class="">
</span><span class="">
</span><span class="keyword1">class</span><span class=""> </span><span class="">fs</span><span class=""> </span><span class="delimiter">=</span><span class=""> </span><span class="">pt</span><span class=""> </span><span class="delimiter">+</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="">finite_supp</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;finite (supp x)&quot;</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">pure_supp</span><span class="delimiter">:</span><span class=""> 
</span><span class="">  </span><span class="keyword2">fixes</span><span class=""> </span><span class="">x</span><span class="delimiter">::</span><span class="string">&quot;&#39;a::pure&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;supp x = {}&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">supp_def</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">permute_pure</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">pure_fresh</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">fixes</span><span class=""> </span><span class="">x</span><span class="delimiter">::</span><span class="string">&quot;&#39;a::pure&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;a &#9839; x&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">fresh_def</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">pure_supp</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">instance</span><span class=""> </span><span class="">pure</span><span class=""> </span><span class="delimiter">&lt;</span><span class=""> </span><span class="">fs</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="">standard</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">pure_supp</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="">
</span><span class="keyword1">subsection</span><span class="">  </span><span class="verbatim">{* Type @{typ atom} is finitely-supported. *}</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">supp_atom</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;supp a = {a}&quot;</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">finite_supp_unique</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">clarsimp</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">supports_def</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="keyword1"><span class="improper">done</span></span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">fresh_atom</span><span class="delimiter">:</span><span class=""> 
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;a &#9839; b &#10231; a &#8800; b&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">fresh_def</span><span class=""> </span><span class="">supp_atom</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">
</span><span class="keyword1">instance</span><span class=""> </span><span class="">atom</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="">fs</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="">standard</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">supp_atom</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="">
</span><span class="keyword1">section</span><span class=""> </span><span class="verbatim">{* Type @{typ perm} is finitely-supported. *}</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">perm_swap_eq</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;(a &#8652; b) &#8729; p = p &#10231; (p &#8729; (a &#8652; b)) = (a &#8652; b)&quot;</span><span class="">
</span><span class="keyword1">unfolding</span><span class=""> </span><span class="">permute_perm_def</span><span class="">
</span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">metis</span><span class=""> </span><span class="">add_diff_cancel</span><span class=""> </span><span class="">minus_perm_def</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">supports_perm</span><span class="delimiter">:</span><span class=""> 
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;{a. p &#8729; a &#8800; a} supports p&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">supports_def</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">perm_swap_eq</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">swap_eqvt</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">finite_perm_lemma</span><span class="delimiter">:</span><span class=""> 
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;finite {a::atom. p &#8729; a &#8800; a}&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">using</span><span class=""> </span><span class="">finite_Rep_perm</span><span class=""> </span><span class="delimiter">[</span><span class="">of</span><span class=""> </span><span class="">p</span><span class="delimiter">]</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">permute_atom_def</span><span class=""> </span><span class="keyword1">.</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">supp_perm</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;supp p = {a. p &#8729; a &#8800; a}&quot;</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">finite_supp_unique</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">supports_perm</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">finite_perm_lemma</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">perm_swap_eq</span><span class=""> </span><span class="">swap_eqvt</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class="delimiter">:</span><span class=""> </span><span class="">perm_eq_iff</span><span class=""> </span><span class="">swap_atom</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">done</span></span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">fresh_perm</span><span class="delimiter">:</span><span class=""> 
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;a &#9839; p &#10231; p &#8729; a = a&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">fresh_def</span><span class=""> 
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">supp_perm</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">supp_swap</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;supp (a &#8652; b) = (if a = b &#8744; sort_of a &#8800; sort_of b then {} else {a, b})&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class="delimiter">:</span><span class=""> </span><span class="">supp_perm</span><span class=""> </span><span class="">swap_atom</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">fresh_swap</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;a &#9839; (b &#8652; c) &#10231; (sort_of b &#8800; sort_of c) &#8744; b = c &#8744; (a &#9839; b &#8743; a &#9839; c)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">fresh_def</span><span class=""> </span><span class="">supp_swap</span><span class=""> </span><span class="">supp_atom</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">fresh_zero_perm</span><span class="delimiter">:</span><span class=""> 
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;a &#9839; (0::perm)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">fresh_perm</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">supp_zero_perm</span><span class="delimiter">:</span><span class=""> 
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;supp (0::perm) = {}&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">supp_perm</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">fresh_plus_perm</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">fixes</span><span class=""> </span><span class="">p</span><span class=""> </span><span class="">q</span><span class="delimiter">::</span><span class="">perm</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="string">&quot;a &#9839; p&quot;</span><span class=""> </span><span class="string">&quot;a &#9839; q&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;a &#9839; (p + q)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">using</span><span class=""> </span><span class="">assms</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">fresh_def</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class="delimiter">:</span><span class=""> </span><span class="">supp_perm</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">supp_plus_perm</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">fixes</span><span class=""> </span><span class="">p</span><span class=""> </span><span class="">q</span><span class="delimiter">::</span><span class="">perm</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;supp (p + q) &#8838; supp p &#8746; supp q&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class="delimiter">:</span><span class=""> </span><span class="">supp_perm</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">fresh_minus_perm</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">fixes</span><span class=""> </span><span class="">p</span><span class="delimiter">::</span><span class="">perm</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;a &#9839; (- p) &#10231; a &#9839; p&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">fresh_def</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">supp_perm</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">simp</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">metis</span><span class=""> </span><span class="">permute_minus_cancel</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">done</span></span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">supp_minus_perm</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">fixes</span><span class=""> </span><span class="">p</span><span class="delimiter">::</span><span class="">perm</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;supp (- p) = supp p&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">supp_conv_fresh</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">fresh_minus_perm</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">plus_perm_eq</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">fixes</span><span class=""> </span><span class="">p</span><span class=""> </span><span class="">q</span><span class="delimiter">::</span><span class="string">&quot;perm&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="">asm</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;supp p &#8745; supp q = {}&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;p + q = q + p&quot;</span><span class="">
</span><span class="keyword1">unfolding</span><span class=""> </span><span class="">perm_eq_iff</span><span class="">
</span><span class="keyword1">proof</span><span class="">
</span><span class="">  </span><span class="keyword3">fix</span><span class=""> </span><span class="">a</span><span class="delimiter">::</span><span class="string">&quot;atom&quot;</span><span class="">
</span><span class="">  </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;(p + q) &#8729; a = (q + p) &#8729; a&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">proof</span><span class=""> </span><span class="">-</span><span class="">
</span><span class="">    </span><span class="keyword1">{</span><span class=""> </span><span class="keyword3">assume</span><span class=""> </span><span class="string">&quot;a &#8713; supp p&quot;</span><span class=""> </span><span class="string">&quot;a &#8713; supp q&quot;</span><span class="">
</span><span class="">      </span><span class="keyword1">then</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;(p + q) &#8729; a = (q + p) &#8729; a&quot;</span><span class=""> 
</span><span class="">        </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">supp_perm</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1">}</span><span class="">
</span><span class="">    </span><span class="keyword1">moreover</span><span class="">
</span><span class="">    </span><span class="keyword1">{</span><span class=""> </span><span class="keyword3">assume</span><span class=""> </span><span class="">a</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;a &#8712; supp p&quot;</span><span class=""> </span><span class="string">&quot;a &#8713; supp q&quot;</span><span class="">
</span><span class="">      </span><span class="keyword1">then</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;p &#8729; a &#8712; supp p&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">supp_perm</span><span class="delimiter">)</span><span class="">
</span><span class="">      </span><span class="keyword1">then</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;p &#8729; a &#8713; supp q&quot;</span><span class=""> </span><span class="keyword1">using</span><span class=""> </span><span class="">asm</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">      </span><span class="keyword1">with</span><span class=""> </span><span class="">a</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;(p + q) &#8729; a = (q + p) &#8729; a&quot;</span><span class=""> 
</span><span class="">        </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">supp_perm</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1">}</span><span class="">
</span><span class="">    </span><span class="keyword1">moreover</span><span class="">
</span><span class="">    </span><span class="keyword1">{</span><span class=""> </span><span class="keyword3">assume</span><span class=""> </span><span class="">a</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;a &#8713; supp p&quot;</span><span class=""> </span><span class="string">&quot;a &#8712; supp q&quot;</span><span class="">
</span><span class="">      </span><span class="keyword1">then</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;q &#8729; a &#8712; supp q&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">supp_perm</span><span class="delimiter">)</span><span class="">
</span><span class="">      </span><span class="keyword1">then</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;q &#8729; a &#8713; supp p&quot;</span><span class=""> </span><span class="keyword1">using</span><span class=""> </span><span class="">asm</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class=""> 
</span><span class="">      </span><span class="keyword1">with</span><span class=""> </span><span class="">a</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;(p + q) &#8729; a = (q + p) &#8729; a&quot;</span><span class=""> 
</span><span class="">        </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">supp_perm</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1">}</span><span class="">
</span><span class="">    </span><span class="keyword1">ultimately</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;(p + q) &#8729; a = (q + p) &#8729; a&quot;</span><span class=""> 
</span><span class="">      </span><span class="keyword1">using</span><span class=""> </span><span class="">asm</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">blast</span><span class="">
</span><span class="">  </span><span class="keyword1">qed</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">supp_plus_perm_eq</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">fixes</span><span class=""> </span><span class="">p</span><span class=""> </span><span class="">q</span><span class="delimiter">::</span><span class="">perm</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="">asm</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;supp p &#8745; supp q = {}&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;supp (p + q) = supp p &#8746; supp q&quot;</span><span class="">
</span><span class="keyword1">proof</span><span class=""> </span><span class="">-</span><span class="">
</span><span class="">  </span><span class="keyword1">{</span><span class=""> </span><span class="keyword3">fix</span><span class=""> </span><span class="">a</span><span class="delimiter">::</span><span class="string">&quot;atom&quot;</span><span class="">
</span><span class="">    </span><span class="keyword3">assume</span><span class=""> </span><span class="string">&quot;a &#8712; supp p&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">then</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;a &#8713; supp q&quot;</span><span class=""> </span><span class="keyword1">using</span><span class=""> </span><span class="">asm</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">    </span><span class="keyword1">then</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;a &#8712; supp (p + q)&quot;</span><span class=""> </span><span class="keyword1">using</span><span class=""> </span><span class="alt_string">`a &#8712; supp p`</span><span class=""> 
</span><span class="">      </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">supp_perm</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">}</span><span class="">
</span><span class="">  </span><span class="keyword1">moreover</span><span class="">
</span><span class="">  </span><span class="keyword1">{</span><span class=""> </span><span class="keyword3">fix</span><span class=""> </span><span class="">a</span><span class="delimiter">::</span><span class="string">&quot;atom&quot;</span><span class="">
</span><span class="">    </span><span class="keyword3">assume</span><span class=""> </span><span class="string">&quot;a &#8712; supp q&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">then</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;a &#8713; supp p&quot;</span><span class=""> </span><span class="keyword1">using</span><span class=""> </span><span class="">asm</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">    </span><span class="keyword1">then</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;a &#8712; supp (q + p)&quot;</span><span class=""> </span><span class="keyword1">using</span><span class=""> </span><span class="alt_string">`a &#8712; supp q`</span><span class=""> 
</span><span class="">      </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">supp_perm</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1">then</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;a &#8712; supp (p + q)&quot;</span><span class=""> </span><span class="keyword1">using</span><span class=""> </span><span class="">asm</span><span class=""> </span><span class="">plus_perm_eq</span><span class="">
</span><span class="">      </span><span class="keyword1">by</span><span class=""> </span><span class="">metis</span><span class="">
</span><span class="">  </span><span class="keyword1">}</span><span class="">
</span><span class="">  </span><span class="keyword1">ultimately</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;supp p &#8746; supp q &#8838; supp (p + q)&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">by</span><span class=""> </span><span class="">blast</span><span class="">
</span><span class="">  </span><span class="keyword1">then</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;supp (p + q) = supp p &#8746; supp q&quot;</span><span class=""> </span><span class="keyword1">using</span><span class=""> </span><span class="">supp_plus_perm</span><span class="">
</span><span class="">    </span><span class="keyword1">by</span><span class=""> </span><span class="">blast</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">perm_eq_iff2</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">fixes</span><span class=""> </span><span class="">p</span><span class=""> </span><span class="">q</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;perm&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;p = q &#10231; (&#8704;a::atom &#8712; supp p &#8746; supp q. p &#8729; a = q &#8729; a)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">perm_eq_iff</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">auto</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">case_tac</span><span class=""> </span><span class="string">&quot;a &#9839; p &#8743; a &#9839; q&quot;</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">fresh_perm</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">fresh_def</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">done</span></span><span class="">
</span><span class="">
</span><span class="">
</span><span class="keyword1">instance</span><span class=""> </span><span class="">perm</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="">fs</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="">standard</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">supp_perm</span><span class=""> </span><span class="">finite_perm_lemma</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="">
</span><span class="">
</span><span class="keyword1">section</span><span class=""> </span><span class="verbatim">{* Finite Support instances for other types *}</span><span class="">
</span><span class="">
</span><span class="">
</span><span class="keyword1">subsection</span><span class=""> </span><span class="verbatim">{* Type @{typ &quot;&#39;a &#215; &#39;b&quot;} is finitely-supported. *}</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">supp_Pair</span><span class="delimiter">:</span><span class=""> 
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;supp (x, y) = supp x &#8746; supp y&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">supp_def</span><span class=""> </span><span class="">Collect_imp_eq</span><span class=""> </span><span class="">Collect_neg_eq</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">fresh_Pair</span><span class="delimiter">:</span><span class=""> 
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;a &#9839; (x, y) &#10231; a &#9839; x &#8743; a &#9839; y&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">fresh_def</span><span class=""> </span><span class="">supp_Pair</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">supp_Unit</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;supp () = {}&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">supp_def</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">fresh_Unit</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;a &#9839; ()&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">fresh_def</span><span class=""> </span><span class="">supp_Unit</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">instance</span><span class=""> </span><span class="">prod</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="delimiter">(</span><span class="">fs</span><span class="delimiter">,</span><span class=""> </span><span class="">fs</span><span class="delimiter">)</span><span class=""> </span><span class="">fs</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="">standard</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">case_tac</span><span class=""> </span><span class="">x</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">supp_Pair</span><span class=""> </span><span class="">finite_supp</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">done</span></span><span class="">
</span><span class="">
</span><span class="">
</span><span class="keyword1">subsection</span><span class=""> </span><span class="verbatim">{* Type @{typ &quot;&#39;a + &#39;b&quot;} is finitely supported *}</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">supp_Inl</span><span class="delimiter">:</span><span class=""> 
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;supp (Inl x) = supp x&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">supp_def</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">supp_Inr</span><span class="delimiter">:</span><span class=""> 
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;supp (Inr x) = supp x&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">supp_def</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">fresh_Inl</span><span class="delimiter">:</span><span class=""> 
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;a &#9839; Inl x &#10231; a &#9839; x&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">fresh_def</span><span class=""> </span><span class="">supp_Inl</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">fresh_Inr</span><span class="delimiter">:</span><span class=""> 
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;a &#9839; Inr y &#10231; a &#9839; y&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">fresh_def</span><span class=""> </span><span class="">supp_Inr</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">instance</span><span class=""> </span><span class="">sum</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="delimiter">(</span><span class="">fs</span><span class="delimiter">,</span><span class=""> </span><span class="">fs</span><span class="delimiter">)</span><span class=""> </span><span class="">fs</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="">standard</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">case_tac</span><span class=""> </span><span class="">x</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">simp_all</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">supp_Inl</span><span class=""> </span><span class="">supp_Inr</span><span class=""> </span><span class="">finite_supp</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">done</span></span><span class="">
</span><span class="">
</span><span class="">
</span><span class="keyword1">subsection</span><span class=""> </span><span class="verbatim">{* Type @{typ &quot;&#39;a option&quot;} is finitely supported *}</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">supp_None</span><span class="delimiter">:</span><span class=""> 
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;supp None = {}&quot;</span><span class="">
</span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">supp_def</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">supp_Some</span><span class="delimiter">:</span><span class=""> 
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;supp (Some x) = supp x&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">supp_def</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">fresh_None</span><span class="delimiter">:</span><span class=""> 
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;a &#9839; None&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">fresh_def</span><span class=""> </span><span class="">supp_None</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">fresh_Some</span><span class="delimiter">:</span><span class=""> 
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;a &#9839; Some x &#10231; a &#9839; x&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">fresh_def</span><span class=""> </span><span class="">supp_Some</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">instance</span><span class=""> </span><span class="">option</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="delimiter">(</span><span class="">fs</span><span class="delimiter">)</span><span class=""> </span><span class="">fs</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="">standard</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">induct_tac</span><span class=""> </span><span class="">x</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">simp_all</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">supp_None</span><span class=""> </span><span class="">supp_Some</span><span class=""> </span><span class="">finite_supp</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">done</span></span><span class="">
</span><span class="">
</span><span class="">
</span><span class="keyword1">subsubsection</span><span class=""> </span><span class="verbatim">{* Type @{typ &quot;&#39;a list&quot;} is finitely supported *}</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">supp_Nil</span><span class="delimiter">:</span><span class=""> 
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;supp [] = {}&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">supp_def</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">fresh_Nil</span><span class="delimiter">:</span><span class=""> 
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;a &#9839; []&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">fresh_def</span><span class=""> </span><span class="">supp_Nil</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">supp_Cons</span><span class="delimiter">:</span><span class=""> 
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;supp (x # xs) = supp x &#8746; supp xs&quot;</span><span class="">
</span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">supp_def</span><span class=""> </span><span class="">Collect_imp_eq</span><span class=""> </span><span class="">Collect_neg_eq</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">fresh_Cons</span><span class="delimiter">:</span><span class=""> 
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;a &#9839; (x # xs) &#10231; a &#9839; x &#8743; a &#9839; xs&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">fresh_def</span><span class=""> </span><span class="">supp_Cons</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">supp_append</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;supp (xs @ ys) = supp xs &#8746; supp ys&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">xs</span><span class="delimiter">)</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class="delimiter">:</span><span class=""> </span><span class="">supp_Nil</span><span class=""> </span><span class="">supp_Cons</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">fresh_append</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;a &#9839; (xs @ ys) &#10231; a &#9839; xs &#8743; a &#9839; ys&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">xs</span><span class="delimiter">)</span><span class=""> </span><span class="delimiter">(</span><span class="">simp_all</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">fresh_Nil</span><span class=""> </span><span class="">fresh_Cons</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">supp_rev</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;supp (rev xs) = supp xs&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">xs</span><span class="delimiter">)</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class="delimiter">:</span><span class=""> </span><span class="">supp_append</span><span class=""> </span><span class="">supp_Cons</span><span class=""> </span><span class="">supp_Nil</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">fresh_rev</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;a &#9839; rev xs &#10231; a &#9839; xs&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">xs</span><span class="delimiter">)</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class="delimiter">:</span><span class=""> </span><span class="">fresh_append</span><span class=""> </span><span class="">fresh_Cons</span><span class=""> </span><span class="">fresh_Nil</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">supp_removeAll</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">fixes</span><span class=""> </span><span class="">x</span><span class="delimiter">::</span><span class="string">&quot;atom&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;supp (removeAll x xs) = supp xs - {x}&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">xs</span><span class="delimiter">)</span><span class="">
</span><span class="">     </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class="delimiter">:</span><span class=""> </span><span class="">supp_Nil</span><span class=""> </span><span class="">supp_Cons</span><span class=""> </span><span class="">supp_atom</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">supp_of_atom_list</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">fixes</span><span class=""> </span><span class="">as</span><span class="delimiter">::</span><span class="string">&quot;atom list&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;supp as = set as&quot;</span><span class="">
</span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">as</span><span class="delimiter">)</span><span class="">
</span><span class="">   </span><span class="delimiter">(</span><span class="">simp_all</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">supp_Nil</span><span class=""> </span><span class="">supp_Cons</span><span class=""> </span><span class="">supp_atom</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">instance</span><span class=""> </span><span class="">list</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="delimiter">(</span><span class="">fs</span><span class="delimiter">)</span><span class=""> </span><span class="">fs</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="">standard</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">induct_tac</span><span class=""> </span><span class="">x</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">simp_all</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">supp_Nil</span><span class=""> </span><span class="">supp_Cons</span><span class=""> </span><span class="">finite_supp</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">done</span></span><span class="">
</span><span class="">
</span><span class="">
</span><span class="keyword1">section</span><span class=""> </span><span class="verbatim">{* Support and Freshness for Applications *}</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">fresh_conv_MOST</span><span class="delimiter">:</span><span class=""> 
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;a &#9839; x &#10231; (MOST b. (a &#8652; b) &#8729; x = x)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">fresh_def</span><span class=""> </span><span class="">supp_def</span><span class=""> 
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">MOST_iff_cofinite</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">fresh_fun_app</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="string">&quot;a &#9839; f&quot;</span><span class=""> </span><span class="keyword2">and</span><span class=""> </span><span class="string">&quot;a &#9839; x&quot;</span><span class=""> 
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;a &#9839; f x&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">using</span><span class=""> </span><span class="">assms</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">fresh_conv_MOST</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">permute_fun_app_eq</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">elim</span><span class=""> </span><span class="">MOST_rev_mp</span><span class="delimiter">)</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">supp_fun_app</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;supp (f x) &#8838; (supp f) &#8746; (supp x)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">using</span><span class=""> </span><span class="">fresh_fun_app</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">fresh_def</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">
</span><span class="">
</span><span class="keyword1">subsection</span><span class=""> </span><span class="verbatim">{* Equivariance Predicate @{text eqvt} and @{text eqvt_at}*}</span><span class="">
</span><span class="">
</span><span class="keyword1">definition</span><span class="">
</span><span class="">  </span><span class="string">&quot;eqvt f &#8801; &#8704;p. p &#8729; f = f&quot;</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">eqvt_boolI</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">fixes</span><span class=""> </span><span class="">f</span><span class="delimiter">::</span><span class="string">&quot;bool&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;eqvt f&quot;</span><span class="">
</span><span class="keyword1">unfolding</span><span class=""> </span><span class="">eqvt_def</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">permute_bool_def</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="">
</span><span class="keyword1">text</span><span class=""> </span><span class="verbatim">{* equivariance of a function at a given argument *}</span><span class="">
</span><span class="">
</span><span class="keyword1">definition</span><span class="">
</span><span class=""> </span><span class="string">&quot;eqvt_at f x &#8801; &#8704;p. p &#8729; (f x) = f (p &#8729; x)&quot;</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">eqvtI</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;(&#8896;p. p &#8729; f &#8801; f) &#10233; eqvt f&quot;</span><span class="">
</span><span class="keyword1">unfolding</span><span class=""> </span><span class="">eqvt_def</span><span class="">
</span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">eqvt_at_perm</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="string">&quot;eqvt_at f x&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;eqvt_at f (q &#8729; x)&quot;</span><span class="">
</span><span class="keyword1">proof</span><span class=""> </span><span class="">-</span><span class="">
</span><span class="">  </span><span class="keyword1">{</span><span class=""> </span><span class="keyword3">fix</span><span class=""> </span><span class="">p</span><span class="delimiter">::</span><span class="string">&quot;perm&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;p &#8729; (f (q &#8729; x)) = p &#8729; q &#8729; (f x)&quot;</span><span class="">
</span><span class="">      </span><span class="keyword1">using</span><span class=""> </span><span class="">assms</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">eqvt_at_def</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1">also</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;&#8230; = (p + q) &#8729; (f x)&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">    </span><span class="keyword1">also</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;&#8230; = f ((p + q) &#8729; x)&quot;</span><span class="">
</span><span class="">      </span><span class="keyword1">using</span><span class=""> </span><span class="">assms</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">only</span><span class="delimiter">:</span><span class=""> </span><span class="">eqvt_at_def</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1">finally</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;p &#8729; (f (q &#8729; x)) = f (p &#8729; q &#8729; x)&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="keyword1">}</span><span class=""> 
</span><span class="">  </span><span class="keyword1">then</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;eqvt_at f (q &#8729; x)&quot;</span><span class=""> </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">eqvt_at_def</span><span class="">
</span><span class="">    </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">supp_fun_eqvt</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="">a</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;eqvt f&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;supp f = {}&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">using</span><span class=""> </span><span class="">a</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">eqvt_def</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">supp_def</span><span class=""> 
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">fresh_fun_eqvt</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="">a</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;eqvt f&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;a &#9839; f&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">using</span><span class=""> </span><span class="">a</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">fresh_def</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">supp_fun_eqvt</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">fresh_fun_eqvt_app</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="">a</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;eqvt f&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;a &#9839; x &#10233; a &#9839; f x&quot;</span><span class="">
</span><span class="keyword1">proof</span><span class=""> </span><span class="">-</span><span class="">
</span><span class="">  </span><span class="keyword1">from</span><span class=""> </span><span class="">a</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;supp f = {}&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">supp_fun_eqvt</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">then</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;a &#9839; x &#10233; a &#9839; f x&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">fresh_def</span><span class="">
</span><span class="">    </span><span class="keyword1">using</span><span class=""> </span><span class="">supp_fun_app</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">supp_fun_app_eqvt</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="">a</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;eqvt f&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;supp (f x) &#8838; supp x&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">using</span><span class=""> </span><span class="">fresh_fun_eqvt_app</span><span class="delimiter">[</span><span class="">OF</span><span class=""> </span><span class="">a</span><span class="delimiter">]</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">fresh_def</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">supp_eqvt_at</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="">asm</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;eqvt_at f x&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">and</span><span class="">     </span><span class="">fin</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;finite (supp x)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;supp (f x) &#8838; supp x&quot;</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">supp_is_subset</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1">unfolding</span><span class=""> </span><span class="">supports_def</span><span class="">
</span><span class="keyword1">unfolding</span><span class=""> </span><span class="">fresh_def</span><span class="delimiter">[</span><span class="">symmetric</span><span class="delimiter">]</span><span class="">
</span><span class="keyword1">using</span><span class=""> </span><span class="">asm</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">eqvt_at_def</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">swap_fresh_fresh</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">fin</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">done</span></span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">finite_supp_eqvt_at</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="">asm</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;eqvt_at f x&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">and</span><span class="">     </span><span class="">fin</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;finite (supp x)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;finite (supp (f x))&quot;</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">finite_subset</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">supp_eqvt_at</span><span class="delimiter">[</span><span class="">OF</span><span class=""> </span><span class="">asm</span><span class=""> </span><span class="">fin</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">fin</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">done</span></span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">fresh_eqvt_at</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="">asm</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;eqvt_at f x&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">and</span><span class="">     </span><span class="">fin</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;finite (supp x)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">and</span><span class="">     </span><span class="">fresh</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;a &#9839; x&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;a &#9839; f x&quot;</span><span class="">
</span><span class="keyword1">using</span><span class=""> </span><span class="">fresh</span><span class="">
</span><span class="keyword1">unfolding</span><span class=""> </span><span class="">fresh_def</span><span class="">
</span><span class="keyword1">using</span><span class=""> </span><span class="">supp_eqvt_at</span><span class="delimiter">[</span><span class="">OF</span><span class=""> </span><span class="">asm</span><span class=""> </span><span class="">fin</span><span class="delimiter">]</span><span class="">
</span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">
</span><span class="keyword1">text</span><span class=""> </span><span class="verbatim">{* for handling of freshness of functions *}</span><span class="">
</span><span class="">
</span><span class="keyword1">simproc_setup</span><span class=""> </span><span class="">fresh_fun_simproc</span><span class=""> </span><span class="delimiter">(</span><span class="string">&quot;a &#9839; (f::&#39;a::pt &#8658;&#39;b::pt)&quot;</span><span class="delimiter">)</span><span class=""> </span><span class="delimiter">=</span><span class=""> </span><span class="verbatim">{* fn _ =&gt; fn ctxt =&gt; fn ctrm =&gt;
  let 
    val _ $ _ $ f = Thm.term_of ctrm
  in
    case (Term.add_frees f [], Term.add_vars f []) of
      ([], []) =&gt; SOME(@{thm fresh_fun_eqvt[simplified eqvt_def, THEN Eq_TrueI]})
    | (x::_, []) =&gt;
      let
        val argx = Free x
        val absf = absfree x f
        val cty_inst =
          [SOME (Thm.ctyp_of ctxt (fastype_of argx)), SOME (Thm.ctyp_of ctxt (fastype_of f))]
        val ctrm_inst = [NONE, SOME (Thm.cterm_of ctxt absf), SOME (Thm.cterm_of ctxt argx)] 
        val thm = Thm.instantiate&#39; cty_inst ctrm_inst @{thm fresh_fun_app}
      in
        SOME(thm RS @{thm Eq_TrueI}) 
      end  
    | (_, _) =&gt; NONE
  end
*}</span><span class="">
</span><span class="">
</span><span class="keyword1">subsection</span><span class=""> </span><span class="verbatim">{* helper functions for nominal_functions *}</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">THE_defaultI2</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="string">&quot;&#8707;!x. P x&quot;</span><span class=""> </span><span class="string">&quot;&#8896;x. P x &#10233; Q x&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;Q (THE_default d P)&quot;</span><span class="">
</span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">iprover</span><span class=""> </span><span class="">intro</span><span class="delimiter">:</span><span class=""> </span><span class="">assms</span><span class=""> </span><span class="">THE_defaultI&#39;</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">the_default_eqvt</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="">unique</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;&#8707;!x. P x&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;(p &#8729; (THE_default d P)) = (THE_default (p &#8729; d) (p &#8729; P))&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">THE_default1_equality</span><span class=""> </span><span class="delimiter">[</span><span class="">symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">rule_tac</span><span class=""> </span><span class="">p</span><span class="delimiter">=</span><span class="string">&quot;-p&quot;</span><span class=""> </span><span class="keyword2">in</span><span class=""> </span><span class="">permute_boolE</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">ex1_eqvt</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">unique</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">rule_tac</span><span class=""> </span><span class="">p</span><span class="delimiter">=</span><span class="string">&quot;-p&quot;</span><span class=""> </span><span class="keyword2">in</span><span class=""> </span><span class="">permute_boolE</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">subst</span><span class="delimiter">[</span><span class="">OF</span><span class=""> </span><span class="">permute_fun_app_eq</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">simp</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">THE_defaultI&#39;</span><span class="delimiter">[</span><span class="">OF</span><span class=""> </span><span class="">unique</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">done</span></span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">fundef_ex1_eqvt</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">fixes</span><span class=""> </span><span class="">x</span><span class="delimiter">::</span><span class="string">&quot;&#39;a::pt&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="">f_def</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;f == (&#955;x::&#39;a. THE_default (d x) (G x))&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="">eqvt</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;eqvt G&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="">ex1</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;&#8707;!y. G x y&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;(p &#8729; (f x)) = f (p &#8729; x)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">only</span><span class="delimiter">:</span><span class=""> </span><span class="">f_def</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">subst</span><span class=""> </span><span class="">the_default_eqvt</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">ex1</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">THE_default1_equality</span><span class=""> </span><span class="delimiter">[</span><span class="">symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">rule_tac</span><span class=""> </span><span class="">p</span><span class="delimiter">=</span><span class="string">&quot;-p&quot;</span><span class=""> </span><span class="keyword2">in</span><span class=""> </span><span class="">permute_boolE</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">perm_simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">permute_minus_cancel</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">using</span><span class=""> </span><span class="">eqvt</span><span class="delimiter">[</span><span class="">simplified</span><span class=""> </span><span class="">eqvt_def</span><span class="delimiter">]</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">simp</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">ex1</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">THE_defaultI2</span><span class="delimiter">)</span><span class=""> 
</span><span class="">  </span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">rule_tac</span><span class=""> </span><span class="">p</span><span class="delimiter">=</span><span class="string">&quot;-p&quot;</span><span class=""> </span><span class="keyword2">in</span><span class=""> </span><span class="">permute_boolE</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">perm_simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">permute_minus_cancel</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">ex1</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">perm_simp</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">using</span><span class=""> </span><span class="">eqvt</span><span class="delimiter">[</span><span class="">simplified</span><span class=""> </span><span class="">eqvt_def</span><span class="delimiter">]</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">simp</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">done</span></span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">fundef_ex1_eqvt_at</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">fixes</span><span class=""> </span><span class="">x</span><span class="delimiter">::</span><span class="string">&quot;&#39;a::pt&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="">f_def</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;f == (&#955;x::&#39;a. THE_default (d x) (G x))&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="">eqvt</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;eqvt G&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="">ex1</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;&#8707;!y. G x y&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;eqvt_at f x&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">eqvt_at_def</span><span class="">
</span><span class="">  </span><span class="keyword1">using</span><span class=""> </span><span class="">assms</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">intro</span><span class="delimiter">:</span><span class=""> </span><span class="">fundef_ex1_eqvt</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">fundef_ex1_prop</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">fixes</span><span class=""> </span><span class="">x</span><span class="delimiter">::</span><span class="string">&quot;&#39;a::pt&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="">f_def</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;f == (&#955;x::&#39;a. THE_default (d x) (G x))&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="">P_all</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;&#8896;x y. G x y &#10233; P x y&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="">ex1</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;&#8707;!y. G x y&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;P x (f x)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">f_def</span><span class="">
</span><span class="">  </span><span class="keyword1">using</span><span class=""> </span><span class="">ex1</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">erule_tac</span><span class=""> </span><span class="">ex1E</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">THE_defaultI2</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">blast</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">P_all</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">assumption</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">done</span></span><span class="">
</span><span class="">
</span><span class="">
</span><span class="keyword1">section</span><span class=""> </span><span class="verbatim">{* Support of Finite Sets of Finitely Supported Elements *}</span><span class="">
</span><span class="">
</span><span class="keyword1">text</span><span class=""> </span><span class="verbatim">{* support and freshness for atom sets *}</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">supp_finite_atom_set</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">fixes</span><span class=""> </span><span class="">S</span><span class="delimiter">::</span><span class="string">&quot;atom set&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="string">&quot;finite S&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;supp S = S&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">finite_supp_unique</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">supports_def</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">swap_set_not_in</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">assms</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">swap_set_in</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">done</span></span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">supp_cofinite_atom_set</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">fixes</span><span class=""> </span><span class="">S</span><span class="delimiter">::</span><span class="string">&quot;atom set&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="string">&quot;finite (UNIV - S)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;supp S = (UNIV - S)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">finite_supp_unique</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">supports_def</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">swap_set_both_in</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">assms</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">subst</span><span class=""> </span><span class="">swap_commute</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">swap_set_in</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">done</span></span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">fresh_finite_atom_set</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">fixes</span><span class=""> </span><span class="">S</span><span class="delimiter">::</span><span class="string">&quot;atom set&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="string">&quot;finite S&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;a &#9839; S &#10231; a &#8713; S&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">fresh_def</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">supp_finite_atom_set</span><span class="delimiter">[</span><span class="">OF</span><span class=""> </span><span class="">assms</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">fresh_minus_atom_set</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">fixes</span><span class=""> </span><span class="">S</span><span class="delimiter">::</span><span class="string">&quot;atom set&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="string">&quot;finite S&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;a &#9839; S - T &#10231; (a &#8713; T &#10230; a &#9839; S)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">fresh_def</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class="delimiter">:</span><span class=""> </span><span class="">supp_finite_atom_set</span><span class=""> </span><span class="">assms</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">Union_supports_set</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;(&#8899;x &#8712; S. supp x) supports S&quot;</span><span class="">
</span><span class="keyword1">proof</span><span class=""> </span><span class="">-</span><span class="">
</span><span class="">  </span><span class="keyword1">{</span><span class=""> </span><span class="keyword3">fix</span><span class=""> </span><span class="">a</span><span class=""> </span><span class="">b</span><span class="">
</span><span class="">    </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;&#8704;x &#8712; S. (a &#8652; b) &#8729; x = x &#10233; (a &#8652; b) &#8729; S = S&quot;</span><span class="">
</span><span class="">      </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">permute_set_def</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">force</span><span class="">
</span><span class="">  </span><span class="keyword1">}</span><span class="">
</span><span class="">  </span><span class="keyword1">then</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;(&#8899;x &#8712; S. supp x) supports S&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">supports_def</span><span class=""> 
</span><span class="">    </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">fresh_def</span><span class="delimiter">[</span><span class="">symmetric</span><span class="delimiter">]</span><span class=""> </span><span class="">swap_fresh_fresh</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">Union_of_finite_supp_sets</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">fixes</span><span class=""> </span><span class="">S</span><span class="delimiter">::</span><span class="string">&quot;(&#39;a::fs set)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="">fin</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;finite S&quot;</span><span class="">   
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;finite (&#8899;x&#8712;S. supp x)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">using</span><span class=""> </span><span class="">fin</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">induct</span><span class="delimiter">)</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class="delimiter">:</span><span class=""> </span><span class="">finite_supp</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">Union_included_in_supp</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">fixes</span><span class=""> </span><span class="">S</span><span class="delimiter">::</span><span class="string">&quot;(&#39;a::fs set)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="">fin</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;finite S&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;(&#8899;x&#8712;S. supp x) &#8838; supp S&quot;</span><span class="">
</span><span class="keyword1">proof</span><span class=""> </span><span class="">-</span><span class="">
</span><span class="">  </span><span class="keyword1">have</span><span class=""> </span><span class="">eqvt</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;eqvt (&#955;S. &#8899;x &#8712; S. supp x)&quot;</span><span class=""> 
</span><span class="">    </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">eqvt_def</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class=""> 
</span><span class="">  </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;(&#8899;x&#8712;S. supp x) = supp (&#8899;x&#8712;S. supp x)&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">supp_finite_atom_set</span><span class="delimiter">[</span><span class="">symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">Union_of_finite_supp_sets</span><span class="delimiter">[</span><span class="">OF</span><span class=""> </span><span class="">fin</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">also</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;&#8230; &#8838; supp S&quot;</span><span class=""> </span><span class="keyword1">using</span><span class=""> </span><span class="">eqvt</span><span class="">
</span><span class="">    </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">supp_fun_app_eqvt</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">finally</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;(&#8899;x&#8712;S. supp x) &#8838; supp S&quot;</span><span class=""> </span><span class="keyword1">.</span><span class="">  
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">supp_of_finite_sets</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">fixes</span><span class=""> </span><span class="">S</span><span class="delimiter">::</span><span class="string">&quot;(&#39;a::fs set)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="">fin</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;finite S&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;(supp S) = (&#8899;x&#8712;S. supp x)&quot;</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">subset_antisym</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">supp_is_subset</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">Union_supports_set</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">Union_of_finite_supp_sets</span><span class="delimiter">[</span><span class="">OF</span><span class=""> </span><span class="">fin</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">Union_included_in_supp</span><span class="delimiter">[</span><span class="">OF</span><span class=""> </span><span class="">fin</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">done</span></span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">finite_sets_supp</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">fixes</span><span class=""> </span><span class="">S</span><span class="delimiter">::</span><span class="string">&quot;(&#39;a::fs set)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="string">&quot;finite S&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;finite (supp S)&quot;</span><span class="">
</span><span class="keyword1">using</span><span class=""> </span><span class="">assms</span><span class="">
</span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">only</span><span class="delimiter">:</span><span class=""> </span><span class="">supp_of_finite_sets</span><span class=""> </span><span class="">Union_of_finite_supp_sets</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">supp_of_finite_union</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">fixes</span><span class=""> </span><span class="">S</span><span class=""> </span><span class="">T</span><span class="delimiter">::</span><span class="string">&quot;(&#39;a::fs) set&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="">fin1</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;finite S&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">and</span><span class="">     </span><span class="">fin2</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;finite T&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;supp (S &#8746; T) = supp S &#8746; supp T&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">using</span><span class=""> </span><span class="">fin1</span><span class=""> </span><span class="">fin2</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">supp_of_finite_sets</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">fresh_finite_union</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">fixes</span><span class=""> </span><span class="">S</span><span class=""> </span><span class="">T</span><span class="delimiter">::</span><span class="string">&quot;(&#39;a::fs) set&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="">fin1</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;finite S&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">and</span><span class="">     </span><span class="">fin2</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;finite T&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;a &#9839; (S &#8746; T) &#10231; a &#9839; S &#8743; a &#9839; T&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">fresh_def</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">supp_of_finite_union</span><span class="delimiter">[</span><span class="">OF</span><span class=""> </span><span class="">fin1</span><span class=""> </span><span class="">fin2</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">supp_of_finite_insert</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">fixes</span><span class=""> </span><span class="">S</span><span class="delimiter">::</span><span class="string">&quot;(&#39;a::fs) set&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="">fin</span><span class="delimiter">:</span><span class="">  </span><span class="string">&quot;finite S&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;supp (insert x S) = supp x &#8746; supp S&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">using</span><span class=""> </span><span class="">fin</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">supp_of_finite_sets</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">fresh_finite_insert</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">fixes</span><span class=""> </span><span class="">S</span><span class="delimiter">::</span><span class="string">&quot;(&#39;a::fs) set&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="">fin</span><span class="delimiter">:</span><span class="">  </span><span class="string">&quot;finite S&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;a &#9839; (insert x S) &#10231; a &#9839; x &#8743; a &#9839; S&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">using</span><span class=""> </span><span class="">fin</span><span class=""> </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">fresh_def</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">supp_of_finite_insert</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">supp_set_empty</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;supp {} = {}&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">supp_def</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">empty_eqvt</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">fresh_set_empty</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;a &#9839; {}&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">fresh_def</span><span class=""> </span><span class="">supp_set_empty</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">supp_set</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">fixes</span><span class=""> </span><span class="">xs</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;(&#39;a::fs) list&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;supp (set xs) = supp xs&quot;</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">xs</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">supp_set_empty</span><span class=""> </span><span class="">supp_Nil</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">supp_Cons</span><span class=""> </span><span class="">supp_of_finite_insert</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">done</span></span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">fresh_set</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">fixes</span><span class=""> </span><span class="">xs</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;(&#39;a::fs) list&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;a &#9839; (set xs) &#10231; a &#9839; xs&quot;</span><span class="">
</span><span class="keyword1">unfolding</span><span class=""> </span><span class="">fresh_def</span><span class="">
</span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">supp_set</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="">
</span><span class="keyword1">subsection</span><span class=""> </span><span class="verbatim">{* Type @{typ &quot;&#39;a multiset&quot;} is finitely supported *}</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">set_mset_eqvt</span><span class=""> </span><span class="delimiter">[</span><span class="">eqvt</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;p &#8729; (set_mset M) = set_mset (p &#8729; M)&quot;</span><span class="">
</span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">M</span><span class="delimiter">)</span><span class=""> </span><span class="delimiter">(</span><span class="">simp_all</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">insert_eqvt</span><span class=""> </span><span class="">empty_eqvt</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">supp_set_mset</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;supp (set_mset M) &#8838; supp M&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">supp_fun_app_eqvt</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">eqvt_def</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">perm_simp</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">simp</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">done</span></span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">Union_finite_multiset</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">fixes</span><span class=""> </span><span class="">M</span><span class="delimiter">::</span><span class="string">&quot;&#39;a::fs multiset&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;finite (&#8899;{supp x | x. x &#8712;# M})&quot;</span><span class="">
</span><span class="keyword1">proof</span><span class=""> </span><span class="">-</span><span class=""> 
</span><span class="">  </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;finite (&#8899;(supp ` {x. x &#8712;# M}))&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">M</span><span class="delimiter">)</span><span class=""> </span><span class="delimiter">(</span><span class="">simp_all</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">Collect_imp_eq</span><span class=""> </span><span class="">Collect_neg_eq</span><span class=""> </span><span class="">finite_supp</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">then</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;finite (&#8899;{supp x | x. x &#8712;# M})&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">only</span><span class="delimiter">:</span><span class=""> </span><span class="">image_Collect</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">Union_supports_multiset</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;&#8899;{supp x | x. x :# M} supports M&quot;</span><span class="">
</span><span class="keyword1">proof</span><span class=""> </span><span class="">-</span><span class="">
</span><span class="">  </span><span class="keyword1">have</span><span class=""> </span><span class="">sw</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;&#8896;a b. ((&#8896;x. x :# M &#10233; (a &#8652; b) &#8729; x = x) &#10233; (a &#8652; b) &#8729; M = M)&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">permute_multiset_def</span><span class=""> 
</span><span class="">    </span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">M</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">simp_all</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1"><span class="improper">done</span></span><span class="">
</span><span class="">  </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;(&#8899;{supp x | x. x :# M}) supports M&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">supports_def</span><span class="">
</span><span class="">    </span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">clarify</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">sw</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">swap_fresh_fresh</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">simp_all</span><span class=""> </span><span class="">only</span><span class="delimiter">:</span><span class=""> </span><span class="">fresh_def</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">auto</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">metis</span><span class=""> </span><span class="">neq0_conv</span><span class="delimiter">)</span><span class="delimiter">+</span><span class="">
</span><span class="">    </span><span class="keyword1"><span class="improper">done</span></span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">Union_included_multiset</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">fixes</span><span class=""> </span><span class="">M</span><span class="delimiter">::</span><span class="string">&quot;(&#39;a::fs multiset)&quot;</span><span class=""> 
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;(&#8899;{supp x | x. x &#8712;# M}) &#8838; supp M&quot;</span><span class="">
</span><span class="keyword1">proof</span><span class=""> </span><span class="">-</span><span class="">
</span><span class="">  </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;(&#8899;{supp x | x. x &#8712;# M}) = (&#8899;{supp x | x. x &#8712; set_mset M})&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">  </span><span class="keyword1">also</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;... &#8838; (&#8899;x &#8712; set_mset M. supp x)&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">  </span><span class="keyword1">also</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;... = supp (set_mset M)&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">supp_of_finite_sets</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">also</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot; ... &#8838; supp M&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">supp_set_mset</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">finally</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;(&#8899;{supp x | x. x &#8712;# M}) &#8838; supp M&quot;</span><span class=""> </span><span class="keyword1">.</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">supp_of_multisets</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">fixes</span><span class=""> </span><span class="">M</span><span class="delimiter">::</span><span class="string">&quot;(&#39;a::fs multiset)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;(supp M) = (&#8899;{supp x | x. x :# M})&quot;</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">subset_antisym</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">supp_is_subset</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">Union_supports_multiset</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">Union_finite_multiset</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">Union_included_multiset</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">done</span></span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">multisets_supp_finite</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">fixes</span><span class=""> </span><span class="">M</span><span class="delimiter">::</span><span class="string">&quot;(&#39;a::fs multiset)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;finite (supp M)&quot;</span><span class="">
</span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">only</span><span class="delimiter">:</span><span class=""> </span><span class="">supp_of_multisets</span><span class=""> </span><span class="">Union_finite_multiset</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">supp_of_multiset_union</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">fixes</span><span class=""> </span><span class="">M</span><span class=""> </span><span class="">N</span><span class="delimiter">::</span><span class="string">&quot;(&#39;a::fs) multiset&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;supp (M + N) = supp M &#8746; supp N&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class="delimiter">:</span><span class=""> </span><span class="">supp_of_multisets</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">supp_empty_mset</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;supp {#} = {}&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">supp_def</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">
</span><span class="keyword1">instance</span><span class=""> </span><span class="">multiset</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="delimiter">(</span><span class="">fs</span><span class="delimiter">)</span><span class=""> </span><span class="">fs</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="">standard</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">multisets_supp_finite</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">subsection</span><span class=""> </span><span class="verbatim">{* Type @{typ &quot;&#39;a fset&quot;} is finitely supported *}</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">supp_fset</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;supp (fset S) = supp S&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">supp_def</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">fset_eqvt</span><span class=""> </span><span class="">fset_cong</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">supp_empty_fset</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;supp {||} = {}&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">supp_def</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">fresh_empty_fset</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;a &#9839; {||}&quot;</span><span class="">
</span><span class="keyword1">unfolding</span><span class=""> </span><span class="">fresh_def</span><span class="">
</span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">supp_insert_fset</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">fixes</span><span class=""> </span><span class="">x</span><span class="delimiter">::</span><span class="string">&quot;&#39;a::fs&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">and</span><span class="">   </span><span class="">S</span><span class="delimiter">::</span><span class="string">&quot;&#39;a fset&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;supp (insert_fset x S) = supp x &#8746; supp S&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">subst</span><span class=""> </span><span class="">supp_fset</span><span class="delimiter">[</span><span class="">symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">supp_of_finite_insert</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">done</span></span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">fresh_insert_fset</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">fixes</span><span class=""> </span><span class="">x</span><span class="delimiter">::</span><span class="string">&quot;&#39;a::fs&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">and</span><span class="">   </span><span class="">S</span><span class="delimiter">::</span><span class="string">&quot;&#39;a fset&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;a &#9839; insert_fset x S &#10231; a &#9839; x &#8743; a &#9839; S&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">fresh_def</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">fset_finite_supp</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">fixes</span><span class=""> </span><span class="">S</span><span class="delimiter">::</span><span class="string">&quot;(&#39;a::fs) fset&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;finite (supp S)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">S</span><span class="delimiter">)</span><span class=""> </span><span class="delimiter">(</span><span class="">simp_all</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">finite_supp</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">supp_union_fset</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">fixes</span><span class=""> </span><span class="">S</span><span class=""> </span><span class="">T</span><span class="delimiter">::</span><span class="string">&quot;&#39;a::fs fset&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;supp (S |&#8746;| T) = supp S &#8746; supp T&quot;</span><span class="">
</span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">S</span><span class="delimiter">)</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">fresh_union_fset</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">fixes</span><span class=""> </span><span class="">S</span><span class=""> </span><span class="">T</span><span class="delimiter">::</span><span class="string">&quot;&#39;a::fs fset&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;a &#9839; S |&#8746;| T &#10231; a &#9839; S &#8743; a &#9839; T&quot;</span><span class="">
</span><span class="keyword1">unfolding</span><span class=""> </span><span class="">fresh_def</span><span class="">
</span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">supp_union_fset</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">instance</span><span class=""> </span><span class="">fset</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="delimiter">(</span><span class="">fs</span><span class="delimiter">)</span><span class=""> </span><span class="">fs</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="">standard</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">fset_finite_supp</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="">
</span><span class="keyword1">subsection</span><span class=""> </span><span class="verbatim">{* Type @{typ &quot;(&#39;a, &#39;b) finfun&quot;} is finitely supported *}</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">fresh_finfun_const</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;a &#9839; (finfun_const b) &#10231; a &#9839; b&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">fresh_def</span><span class=""> </span><span class="">supp_def</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">fresh_finfun_update</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;&#10214;a &#9839; f; a &#9839; x; a &#9839; y&#10215; &#10233; a &#9839; finfun_update f x y&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">fresh_conv_MOST</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">finfun_update_eqvt</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">elim</span><span class=""> </span><span class="">MOST_rev_mp</span><span class="delimiter">)</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">supp_finfun_const</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;supp (finfun_const b) = supp(b)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">supp_def</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">supp_finfun_update</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;supp (finfun_update f x y) &#8838; supp(f, x, y)&quot;</span><span class="">
</span><span class="keyword1">using</span><span class=""> </span><span class="">fresh_finfun_update</span><span class="">
</span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class="delimiter">:</span><span class=""> </span><span class="">fresh_def</span><span class=""> </span><span class="">supp_Pair</span><span class="delimiter">)</span><span class="">
</span><span class="">    
</span><span class="keyword1">instance</span><span class=""> </span><span class="">finfun</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="delimiter">(</span><span class="">fs</span><span class="delimiter">,</span><span class=""> </span><span class="">fs</span><span class="delimiter">)</span><span class=""> </span><span class="">fs</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="">standard</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">induct_tac</span><span class=""> </span><span class="">x</span><span class=""> </span><span class="">rule</span><span class="delimiter">:</span><span class=""> </span><span class="">finfun_weak_induct</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">supp_finfun_const</span><span class=""> </span><span class="">finite_supp</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">finite_subset</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">supp_finfun_update</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">supp_Pair</span><span class=""> </span><span class="">finite_supp</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">done</span></span><span class="">
</span><span class="">
</span><span class="">
</span><span class="keyword1">section</span><span class=""> </span><span class="verbatim">{* Freshness and Fresh-Star *}</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">fresh_Unit_elim</span><span class="delimiter">:</span><span class=""> 
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;(a &#9839; () &#10233; PROP C) &#8801; PROP C&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">fresh_Unit</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">fresh_Pair_elim</span><span class="delimiter">:</span><span class=""> 
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;(a &#9839; (x, y) &#10233; PROP C) &#8801; (a &#9839; x &#10233; a &#9839; y &#10233; PROP C)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="">rule</span><span class=""> </span><span class="delimiter">(</span><span class="">simp_all</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">fresh_Pair</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="comment">(* this rule needs to be added before the fresh_prodD is *)</span><span class="">
</span><span class="comment">(* added to the simplifier with mksimps                  *)</span><span class=""> 
</span><span class="keyword1">lemma</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;a &#9839; x1 &#10233; a &#9839; x2 &#10233; a &#9839; (x1, x2)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">fresh_Pair</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">fresh_PairD</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;a &#9839; (x, y) &#10233; a &#9839; x&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">and</span><span class="">   </span><span class="string">&quot;a &#9839; (x, y) &#10233; a &#9839; y&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp_all</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">fresh_Pair</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">declaration</span><span class=""> </span><span class="verbatim">{* fn _ =&gt;
let
  val mksimps_pairs = (@{const_name Nominal2_Base.fresh}, @{thms fresh_PairD}) :: mksimps_pairs
in
  Simplifier.map_ss (fn ss =&gt; Simplifier.set_mksimps (mksimps mksimps_pairs) ss)
end
*}</span><span class="">
</span><span class="">
</span><span class="">
</span><span class="keyword1">text</span><span class=""> </span><span class="verbatim">{* The fresh-star generalisation of fresh is used in strong
  induction principles. *}</span><span class="">
</span><span class="">
</span><span class="keyword1">definition</span><span class=""> 
</span><span class="">  </span><span class="">fresh_star</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;atom set &#8658; &#39;a::pt &#8658; bool&quot;</span><span class=""> </span><span class="delimiter">(</span><span class="string">&quot;_ &#9839;* _&quot;</span><span class=""> </span><span class="delimiter">[</span><span class="">80</span><span class="delimiter">,</span><span class="">80</span><span class="delimiter">]</span><span class=""> </span><span class="">80</span><span class="delimiter">)</span><span class="">
</span><span class="keyword2">where</span><span class=""> 
</span><span class="">  </span><span class="string">&quot;as &#9839;* x &#8801; &#8704;a &#8712; as. a &#9839; x&quot;</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">fresh_star_supp_conv</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;supp x &#9839;* y &#10233; supp y &#9839;* x&quot;</span><span class="">
</span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class="delimiter">:</span><span class=""> </span><span class="">fresh_star_def</span><span class=""> </span><span class="">fresh_def</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">fresh_star_perm_set_conv</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">fixes</span><span class=""> </span><span class="">p</span><span class="delimiter">::</span><span class="string">&quot;perm&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="">fresh</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;as &#9839;* p&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">and</span><span class="">     </span><span class="">fin</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;finite as&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;supp p &#9839;* as&quot;</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">fresh_star_supp_conv</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">supp_finite_atom_set</span><span class=""> </span><span class="">fin</span><span class=""> </span><span class="">fresh</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">done</span></span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">fresh_star_atom_set_conv</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="">fresh</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;as &#9839;* bs&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">and</span><span class="">     </span><span class="">fin</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;finite as&quot;</span><span class=""> </span><span class="string">&quot;finite bs&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;bs &#9839;* as&quot;</span><span class="">
</span><span class="keyword1">using</span><span class=""> </span><span class="">fresh</span><span class="">
</span><span class="keyword1">unfolding</span><span class=""> </span><span class="">fresh_star_def</span><span class=""> </span><span class="">fresh_def</span><span class="">
</span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class="delimiter">:</span><span class=""> </span><span class="">supp_finite_atom_set</span><span class=""> </span><span class="">fin</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">atom_fresh_star_disjoint</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="">fin</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;finite bs&quot;</span><span class=""> 
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;as &#9839;* bs &#10231; (as &#8745; bs = {})&quot;</span><span class="">
</span><span class="">
</span><span class="keyword1">unfolding</span><span class=""> </span><span class="">fresh_star_def</span><span class=""> </span><span class="">fresh_def</span><span class="">
</span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class="delimiter">:</span><span class=""> </span><span class="">supp_finite_atom_set</span><span class=""> </span><span class="">fin</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">fresh_star_Pair</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;as &#9839;* (x, y) = (as &#9839;* x &#8743; as &#9839;* y)&quot;</span><span class=""> 
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class="delimiter">:</span><span class=""> </span><span class="">fresh_star_def</span><span class=""> </span><span class="">fresh_Pair</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">fresh_star_list</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;as &#9839;* (xs @ ys) &#10231; as &#9839;* xs &#8743; as &#9839;* ys&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">and</span><span class="">   </span><span class="string">&quot;as &#9839;* (x # xs) &#10231; as &#9839;* x &#8743; as &#9839;* xs&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">and</span><span class="">   </span><span class="string">&quot;as &#9839;* []&quot;</span><span class="">
</span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class="delimiter">:</span><span class=""> </span><span class="">fresh_star_def</span><span class=""> </span><span class="">fresh_Nil</span><span class=""> </span><span class="">fresh_Cons</span><span class=""> </span><span class="">fresh_append</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">fresh_star_set</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">fixes</span><span class=""> </span><span class="">xs</span><span class="delimiter">::</span><span class="string">&quot;(&#39;a::fs) list&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;as &#9839;* set xs &#10231; as &#9839;* xs&quot;</span><span class="">
</span><span class="keyword1">unfolding</span><span class=""> </span><span class="">fresh_star_def</span><span class="">
</span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">fresh_set</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">fresh_star_singleton</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">fixes</span><span class=""> </span><span class="">a</span><span class="delimiter">::</span><span class="string">&quot;atom&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;as &#9839;* {a} &#10231; as &#9839;* a&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">fresh_star_def</span><span class=""> </span><span class="">fresh_finite_insert</span><span class=""> </span><span class="">fresh_set_empty</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">fresh_star_fset</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">fixes</span><span class=""> </span><span class="">xs</span><span class="delimiter">::</span><span class="string">&quot;(&#39;a::fs) list&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;as &#9839;* fset S &#10231; as &#9839;* S&quot;</span><span class="">
</span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">fresh_star_def</span><span class=""> </span><span class="">fresh_def</span><span class="delimiter">)</span><span class=""> 
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">fresh_star_Un</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;(as &#8746; bs) &#9839;* x = (as &#9839;* x &#8743; bs &#9839;* x)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class="delimiter">:</span><span class=""> </span><span class="">fresh_star_def</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">fresh_star_insert</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;(insert a as) &#9839;* x = (a &#9839; x &#8743; as &#9839;* x)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class="delimiter">:</span><span class=""> </span><span class="">fresh_star_def</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">fresh_star_Un_elim</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="string">&quot;((as &#8746; bs) &#9839;* x &#10233; PROP C) &#8801; (as &#9839;* x &#10233; bs &#9839;* x &#10233; PROP C)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">fresh_star_def</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">rule</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">erule</span><span class=""> </span><span class="">meta_mp</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">auto</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">done</span></span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">fresh_star_insert_elim</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="string">&quot;(insert a as &#9839;* x &#10233; PROP C) &#8801; (a &#9839; x &#10233; as &#9839;* x &#10233; PROP C)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">fresh_star_def</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="">rule</span><span class=""> </span><span class="delimiter">(</span><span class="">simp_all</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">fresh_star_def</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">fresh_star_empty_elim</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="string">&quot;({} &#9839;* x &#10233; PROP C) &#8801; PROP C&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">fresh_star_def</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">fresh_star_Unit_elim</span><span class="delimiter">:</span><span class=""> 
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;(a &#9839;* () &#10233; PROP C) &#8801; PROP C&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">fresh_star_def</span><span class=""> </span><span class="">fresh_Unit</span><span class="delimiter">)</span><span class=""> 
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">fresh_star_Pair_elim</span><span class="delimiter">:</span><span class=""> 
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;(a &#9839;* (x, y) &#10233; PROP C) &#8801; (a &#9839;* x &#10233; a &#9839;* y &#10233; PROP C)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class="delimiter">,</span><span class=""> </span><span class="">simp_all</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">fresh_star_Pair</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">fresh_star_zero</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;as &#9839;* (0::perm)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">fresh_star_def</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">fresh_zero_perm</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">fresh_star_plus</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">fixes</span><span class=""> </span><span class="">p</span><span class=""> </span><span class="">q</span><span class="delimiter">::</span><span class="">perm</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;&#10214;a &#9839;* p;  a &#9839;* q&#10215; &#10233; a &#9839;* (p + q)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">fresh_star_def</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">fresh_plus_perm</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">fresh_star_permute_iff</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;(p &#8729; a) &#9839;* (p &#8729; x) &#10231; a &#9839;* x&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">fresh_star_def</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">metis</span><span class=""> </span><span class="">mem_permute_iff</span><span class=""> </span><span class="">permute_minus_cancel</span><span class="delimiter">(</span><span class="">1</span><span class="delimiter">)</span><span class=""> </span><span class="">fresh_permute_iff</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">fresh_star_eqvt</span><span class=""> </span><span class="delimiter">[</span><span class="">eqvt</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;p &#8729; (as &#9839;* x) &#10231; (p &#8729; as) &#9839;* (p &#8729; x)&quot;</span><span class="">
</span><span class="keyword1">unfolding</span><span class=""> </span><span class="">fresh_star_def</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">
</span><span class="">
</span><span class="keyword1">section</span><span class=""> </span><span class="verbatim">{* Induction principle for permutations *}</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">smaller_supp</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="">a</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;a &#8712; supp p&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;supp ((p &#8729; a &#8652; a) + p) &#8834; supp p&quot;</span><span class="">
</span><span class="keyword1">proof</span><span class=""> </span><span class="">-</span><span class="">
</span><span class="">  </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;supp ((p &#8729; a &#8652; a) + p) &#8838; supp p&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">supp_perm</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class="delimiter">:</span><span class=""> </span><span class="">swap_atom</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">moreover</span><span class="">
</span><span class="">  </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;a &#8713; supp ((p &#8729; a &#8652; a) + p)&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">supp_perm</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">then</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;supp ((p &#8729; a &#8652; a) + p) &#8800; supp p&quot;</span><span class=""> </span><span class="keyword1">using</span><span class=""> </span><span class="">a</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">  </span><span class="keyword1">ultimately</span><span class=""> 
</span><span class="">  </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;supp ((p &#8729; a &#8652; a) + p) &#8834; supp p&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">  
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">perm_struct_induct</span><span class="delimiter">[</span><span class="">consumes</span><span class=""> </span><span class="">1</span><span class="delimiter">,</span><span class=""> </span><span class="">case_names</span><span class=""> </span><span class="">zero</span><span class=""> </span><span class="">swap</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="">S</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;supp p &#8838; S&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">and</span><span class=""> </span><span class="">zero</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;P 0&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">and</span><span class=""> </span><span class="">swap</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;&#8896;p a b. &#10214;P p; supp p &#8838; S; a &#8712; S; b &#8712; S; a &#8800; b; sort_of a = sort_of b&#10215; &#10233; P ((a &#8652; b) + p)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;P p&quot;</span><span class="">
</span><span class="keyword1">proof</span><span class=""> </span><span class="">-</span><span class="">
</span><span class="">  </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;finite (supp p)&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">finite_supp</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">then</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;P p&quot;</span><span class=""> </span><span class="keyword1">using</span><span class=""> </span><span class="">S</span><span class="">
</span><span class="">  </span><span class="keyword1">proof</span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">A</span><span class="delimiter">&#8801;</span><span class="string">&quot;supp p&quot;</span><span class=""> </span><span class="">arbitrary</span><span class="delimiter">:</span><span class=""> </span><span class="">p</span><span class=""> </span><span class="">rule</span><span class="delimiter">:</span><span class=""> </span><span class="">finite_psubset_induct</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword3">case</span><span class=""> </span><span class="delimiter">(</span><span class="">psubset</span><span class=""> </span><span class="">p</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1">then</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="">ih</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;&#8896;q. supp q &#8834; supp p &#10233; P q&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">    </span><span class="keyword1">have</span><span class=""> </span><span class="">as</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;supp p &#8838; S&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">fact</span><span class="">
</span><span class="">    </span><span class="keyword1">{</span><span class=""> </span><span class="keyword3">assume</span><span class=""> </span><span class="string">&quot;supp p = {}&quot;</span><span class="">
</span><span class="">      </span><span class="keyword1">then</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;p = 0&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">supp_perm</span><span class=""> </span><span class="">perm_eq_iff</span><span class="delimiter">)</span><span class="">
</span><span class="">      </span><span class="keyword1">then</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;P p&quot;</span><span class=""> </span><span class="keyword1">using</span><span class=""> </span><span class="">zero</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">    </span><span class="keyword1">}</span><span class="">
</span><span class="">    </span><span class="keyword1">moreover</span><span class="">
</span><span class="">    </span><span class="keyword1">{</span><span class=""> </span><span class="keyword3">assume</span><span class=""> </span><span class="string">&quot;supp p &#8800; {}&quot;</span><span class="">
</span><span class="">      </span><span class="keyword1">then</span><span class=""> </span><span class="keyword3">obtain</span><span class=""> </span><span class="">a</span><span class=""> </span><span class="keyword2">where</span><span class=""> </span><span class="">a0</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;a &#8712; supp p&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">blast</span><span class="">
</span><span class="">      </span><span class="keyword1">then</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="">a1</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;p &#8729; a &#8712; S&quot;</span><span class=""> </span><span class="string">&quot;a &#8712; S&quot;</span><span class=""> </span><span class="string">&quot;sort_of (p &#8729; a) = sort_of a&quot;</span><span class=""> </span><span class="string">&quot;p &#8729; a &#8800; a&quot;</span><span class="">
</span><span class="">        </span><span class="keyword1">using</span><span class=""> </span><span class="">as</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class="delimiter">:</span><span class=""> </span><span class="">supp_atom</span><span class=""> </span><span class="">supp_perm</span><span class=""> </span><span class="">swap_atom</span><span class="delimiter">)</span><span class="">
</span><span class="">      </span><span class="keyword1">let</span><span class=""> </span><span class="var">?q</span><span class=""> </span><span class="delimiter">=</span><span class=""> </span><span class="string">&quot;(p &#8729; a &#8652; a) + p&quot;</span><span class="">
</span><span class="">      </span><span class="keyword1">have</span><span class=""> </span><span class="">a2</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;supp ?q &#8834; supp p&quot;</span><span class=""> </span><span class="keyword1">using</span><span class=""> </span><span class="">a0</span><span class=""> </span><span class="">smaller_supp</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">      </span><span class="keyword1">then</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;P ?q&quot;</span><span class=""> </span><span class="keyword1">using</span><span class=""> </span><span class="">ih</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">      </span><span class="keyword1">moreover</span><span class="">
</span><span class="">      </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;supp ?q &#8838; S&quot;</span><span class=""> </span><span class="keyword1">using</span><span class=""> </span><span class="">as</span><span class=""> </span><span class="">a2</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">      </span><span class="keyword1">ultimately</span><span class="">  </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;P ((p &#8729; a &#8652; a) + ?q)&quot;</span><span class=""> </span><span class="keyword1">using</span><span class=""> </span><span class="">as</span><span class=""> </span><span class="">a1</span><span class=""> </span><span class="">swap</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class=""> 
</span><span class="">      </span><span class="keyword1">moreover</span><span class=""> 
</span><span class="">      </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;p = (p &#8729; a &#8652; a) + ?q&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">perm_eq_iff</span><span class="delimiter">)</span><span class="">
</span><span class="">      </span><span class="keyword1">ultimately</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;P p&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">    </span><span class="keyword1">}</span><span class="">
</span><span class="">    </span><span class="keyword1">ultimately</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;P p&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">blast</span><span class="">
</span><span class="">  </span><span class="keyword1">qed</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">perm_simple_struct_induct</span><span class="delimiter">[</span><span class="">case_names</span><span class=""> </span><span class="">zero</span><span class=""> </span><span class="">swap</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="">zero</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;P 0&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">and</span><span class="">     </span><span class="">swap</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;&#8896;p a b. &#10214;P p; a &#8800; b; sort_of a = sort_of b&#10215; &#10233; P ((a &#8652; b) + p)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;P p&quot;</span><span class="">
</span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">rule_tac</span><span class=""> </span><span class="">S</span><span class="delimiter">=</span><span class="string">&quot;supp p&quot;</span><span class=""> </span><span class="keyword2">in</span><span class=""> </span><span class="">perm_struct_induct</span><span class="delimiter">)</span><span class="">
</span><span class="">   </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">intro</span><span class="delimiter">:</span><span class=""> </span><span class="">zero</span><span class=""> </span><span class="">swap</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">perm_struct_induct2</span><span class="delimiter">[</span><span class="">consumes</span><span class=""> </span><span class="">1</span><span class="delimiter">,</span><span class=""> </span><span class="">case_names</span><span class=""> </span><span class="">zero</span><span class=""> </span><span class="">swap</span><span class=""> </span><span class="">plus</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="">S</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;supp p &#8838; S&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="">zero</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;P 0&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="">swap</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;&#8896;a b. &#10214;sort_of a = sort_of b; a &#8800; b; a &#8712; S; b &#8712; S&#10215; &#10233; P (a &#8652; b)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="">plus</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;&#8896;p1 p2. &#10214;P p1; P p2; supp p1 &#8838; S; supp p2 &#8838; S&#10215; &#10233; P (p1 + p2)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;P p&quot;</span><span class="">
</span><span class="keyword1">using</span><span class=""> </span><span class="">S</span><span class="">
</span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">p</span><span class=""> </span><span class="">rule</span><span class="delimiter">:</span><span class=""> </span><span class="">perm_struct_induct</span><span class="delimiter">)</span><span class="">
</span><span class="">   </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">intro</span><span class="delimiter">:</span><span class=""> </span><span class="">zero</span><span class=""> </span><span class="">plus</span><span class=""> </span><span class="">swap</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">supp_swap</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">perm_simple_struct_induct2</span><span class="delimiter">[</span><span class="">case_names</span><span class=""> </span><span class="">zero</span><span class=""> </span><span class="">swap</span><span class=""> </span><span class="">plus</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="">zero</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;P 0&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="">swap</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;&#8896;a b. &#10214;sort_of a = sort_of b; a &#8800; b&#10215; &#10233; P (a &#8652; b)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="">plus</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;&#8896;p1 p2. &#10214;P p1; P p2&#10215; &#10233; P (p1 + p2)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;P p&quot;</span><span class="">
</span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">rule_tac</span><span class=""> </span><span class="">S</span><span class="delimiter">=</span><span class="string">&quot;supp p&quot;</span><span class=""> </span><span class="keyword2">in</span><span class=""> </span><span class="">perm_struct_induct2</span><span class="delimiter">)</span><span class="">
</span><span class="">   </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">intro</span><span class="delimiter">:</span><span class=""> </span><span class="">zero</span><span class=""> </span><span class="">swap</span><span class=""> </span><span class="">plus</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">supp_perm_singleton</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">fixes</span><span class=""> </span><span class="">p</span><span class="delimiter">::</span><span class="string">&quot;perm&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;supp p &#8838; {b} &#10231; p = 0&quot;</span><span class="">
</span><span class="keyword1">proof</span><span class=""> </span><span class="">-</span><span class="">
</span><span class="">  </span><span class="keyword1">{</span><span class=""> </span><span class="keyword3">assume</span><span class=""> </span><span class="string">&quot;supp p &#8838; {b}&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">then</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;p = 0&quot;</span><span class="">
</span><span class="">      </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">p</span><span class=""> </span><span class="">rule</span><span class="delimiter">:</span><span class=""> </span><span class="">perm_struct_induct</span><span class="delimiter">)</span><span class=""> </span><span class="delimiter">(</span><span class="">simp_all</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">}</span><span class="">
</span><span class="">  </span><span class="keyword1">then</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;supp p &#8838; {b} &#10231; p = 0&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class="delimiter">:</span><span class=""> </span><span class="">supp_zero_perm</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">supp_perm_pair</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">fixes</span><span class=""> </span><span class="">p</span><span class="delimiter">::</span><span class="string">&quot;perm&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;supp p &#8838; {a, b} &#10231; p = 0 &#8744; p = (b &#8652; a)&quot;</span><span class="">
</span><span class="keyword1">proof</span><span class=""> </span><span class="">-</span><span class="">
</span><span class="">  </span><span class="keyword1">{</span><span class=""> </span><span class="keyword3">assume</span><span class=""> </span><span class="string">&quot;supp p &#8838; {a, b}&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">then</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;p = 0 &#8744; p = (b &#8652; a)&quot;</span><span class="">
</span><span class="">      </span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">p</span><span class=""> </span><span class="">rule</span><span class="delimiter">:</span><span class=""> </span><span class="">perm_struct_induct</span><span class="delimiter">)</span><span class=""> 
</span><span class="">      </span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class="delimiter">:</span><span class=""> </span><span class="">swap_cancel</span><span class=""> </span><span class="">supp_zero_perm</span><span class=""> </span><span class="">supp_swap</span><span class="delimiter">)</span><span class="">
</span><span class="">      </span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">swap_commute</span><span class="delimiter">)</span><span class="">
</span><span class="">      </span><span class="keyword1"><span class="improper">done</span></span><span class="">
</span><span class="">  </span><span class="keyword1">}</span><span class="">
</span><span class="">  </span><span class="keyword1">then</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;supp p &#8838; {a, b} &#10231; p = 0 &#8744; p = (b &#8652; a)&quot;</span><span class=""> 
</span><span class="">    </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class="delimiter">:</span><span class=""> </span><span class="">supp_zero_perm</span><span class=""> </span><span class="">supp_swap</span><span class=""> </span><span class="">split</span><span class="delimiter">:</span><span class=""> </span><span class="">if_splits</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">supp_perm_eq</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="string">&quot;(supp x) &#9839;* p&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;p &#8729; x = x&quot;</span><span class="">
</span><span class="keyword1">proof</span><span class=""> </span><span class="">-</span><span class="">
</span><span class="">  </span><span class="keyword1">from</span><span class=""> </span><span class="">assms</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;supp p &#8838; {a. a &#9839; x}&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">supp_perm</span><span class=""> </span><span class="">fresh_star_def</span><span class=""> </span><span class="">fresh_def</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">  </span><span class="keyword1">then</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;p &#8729; x = x&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">proof</span><span class=""> </span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">p</span><span class=""> </span><span class="">rule</span><span class="delimiter">:</span><span class=""> </span><span class="">perm_struct_induct</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword3">case</span><span class=""> </span><span class="">zero</span><span class="">
</span><span class="">    </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;0 &#8729; x = x&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">  </span><span class="keyword1">next</span><span class="">
</span><span class="">    </span><span class="keyword3">case</span><span class=""> </span><span class="delimiter">(</span><span class="">swap</span><span class=""> </span><span class="">p</span><span class=""> </span><span class="">a</span><span class=""> </span><span class="">b</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1">then</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;a &#9839; x&quot;</span><span class=""> </span><span class="string">&quot;b &#9839; x&quot;</span><span class=""> </span><span class="string">&quot;p &#8729; x = x&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp_all</span><span class="">
</span><span class="">    </span><span class="keyword1">then</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;((a &#8652; b) + p) &#8729; x = x&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">swap_fresh_fresh</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">qed</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="keyword1">text</span><span class=""> </span><span class="verbatim">{* same lemma as above, but proved with a different induction principle *}</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">supp_perm_eq_test</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="string">&quot;(supp x) &#9839;* p&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;p &#8729; x = x&quot;</span><span class="">
</span><span class="keyword1">proof</span><span class=""> </span><span class="">-</span><span class="">
</span><span class="">  </span><span class="keyword1">from</span><span class=""> </span><span class="">assms</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;supp p &#8838; {a. a &#9839; x}&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">supp_perm</span><span class=""> </span><span class="">fresh_star_def</span><span class=""> </span><span class="">fresh_def</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">  </span><span class="keyword1">then</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;p &#8729; x = x&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">proof</span><span class=""> </span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">p</span><span class=""> </span><span class="">rule</span><span class="delimiter">:</span><span class=""> </span><span class="">perm_struct_induct2</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword3">case</span><span class=""> </span><span class="">zero</span><span class="">
</span><span class="">    </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;0 &#8729; x = x&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">  </span><span class="keyword1">next</span><span class="">
</span><span class="">    </span><span class="keyword3">case</span><span class=""> </span><span class="delimiter">(</span><span class="">swap</span><span class=""> </span><span class="">a</span><span class=""> </span><span class="">b</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1">then</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;a &#9839; x&quot;</span><span class=""> </span><span class="string">&quot;b &#9839; x&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp_all</span><span class="">
</span><span class="">    </span><span class="keyword1">then</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;(a &#8652; b) &#8729; x = x&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">swap_fresh_fresh</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">next</span><span class="">
</span><span class="">    </span><span class="keyword3">case</span><span class=""> </span><span class="delimiter">(</span><span class="">plus</span><span class=""> </span><span class="">p1</span><span class=""> </span><span class="">p2</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;p1 &#8729; x = x&quot;</span><span class=""> </span><span class="string">&quot;p2 &#8729; x = x&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">fact</span><span class="delimiter">+</span><span class="">
</span><span class="">    </span><span class="keyword1">then</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;(p1 + p2) &#8729; x = x&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">  </span><span class="keyword1">qed</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">perm_supp_eq</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="">a</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;(supp p) &#9839;* x&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;p &#8729; x = x&quot;</span><span class="">
</span><span class="keyword1">proof</span><span class=""> </span><span class="">-</span><span class="">
</span><span class="">  </span><span class="keyword1">from</span><span class=""> </span><span class="">assms</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;supp p &#8838; {a. a &#9839; x}&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">supp_perm</span><span class=""> </span><span class="">fresh_star_def</span><span class=""> </span><span class="">fresh_def</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">  </span><span class="keyword1">then</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;p &#8729; x = x&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">proof</span><span class=""> </span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">p</span><span class=""> </span><span class="">rule</span><span class="delimiter">:</span><span class=""> </span><span class="">perm_struct_induct2</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword3">case</span><span class=""> </span><span class="">zero</span><span class="">
</span><span class="">    </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;0 &#8729; x = x&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">  </span><span class="keyword1">next</span><span class="">
</span><span class="">    </span><span class="keyword3">case</span><span class=""> </span><span class="delimiter">(</span><span class="">swap</span><span class=""> </span><span class="">a</span><span class=""> </span><span class="">b</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1">then</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;a &#9839; x&quot;</span><span class=""> </span><span class="string">&quot;b &#9839; x&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp_all</span><span class="">
</span><span class="">    </span><span class="keyword1">then</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;(a &#8652; b) &#8729; x = x&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">swap_fresh_fresh</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">next</span><span class="">
</span><span class="">    </span><span class="keyword3">case</span><span class=""> </span><span class="delimiter">(</span><span class="">plus</span><span class=""> </span><span class="">p1</span><span class=""> </span><span class="">p2</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;p1 &#8729; x = x&quot;</span><span class=""> </span><span class="string">&quot;p2 &#8729; x = x&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">fact</span><span class="delimiter">+</span><span class="">
</span><span class="">    </span><span class="keyword1">then</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;(p1 + p2) &#8729; x = x&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">  </span><span class="keyword1">qed</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">supp_perm_perm_eq</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="">a</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;&#8704;a &#8712; supp x. p &#8729; a = q &#8729; a&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;p &#8729; x = q &#8729; x&quot;</span><span class="">
</span><span class="keyword1">proof</span><span class=""> </span><span class="">-</span><span class="">
</span><span class="">  </span><span class="keyword1">from</span><span class=""> </span><span class="">a</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;&#8704;a &#8712; supp x. (-q + p) &#8729; a = a&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">  </span><span class="keyword1">then</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;&#8704;a &#8712; supp x. a &#8713; supp (-q + p)&quot;</span><span class=""> 
</span><span class="">    </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">supp_perm</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">  </span><span class="keyword1">then</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;supp x &#9839;* (-q + p)&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">fresh_star_def</span><span class=""> </span><span class="">fresh_def</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">  </span><span class="keyword1">then</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;(-q + p) &#8729; x = x&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">only</span><span class="delimiter">:</span><span class=""> </span><span class="">supp_perm_eq</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">then</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;p &#8729; x = q &#8729; x&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">metis</span><span class=""> </span><span class="">permute_minus_cancel</span><span class=""> </span><span class="">permute_plus</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="keyword1">text</span><span class=""> </span><span class="verbatim">{* disagreement set *}</span><span class="">
</span><span class="">
</span><span class="keyword1">definition</span><span class="">
</span><span class="">  </span><span class="">dset</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;perm &#8658; perm &#8658; atom set&quot;</span><span class="">
</span><span class="keyword2">where</span><span class="">
</span><span class="">  </span><span class="string">&quot;dset p q = {a::atom. p &#8729; a &#8800; q &#8729; a}&quot;</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">ds_fresh</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="string">&quot;dset p q &#9839;* x&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;p &#8729; x = q &#8729; x&quot;</span><span class="">
</span><span class="keyword1">using</span><span class=""> </span><span class="">assms</span><span class="">
</span><span class="keyword1">unfolding</span><span class=""> </span><span class="">dset_def</span><span class=""> </span><span class="">fresh_star_def</span><span class=""> </span><span class="">fresh_def</span><span class="">
</span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">intro</span><span class="delimiter">:</span><span class=""> </span><span class="">supp_perm_perm_eq</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">atom_set_perm_eq</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="">a</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;as &#9839;* p&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;p &#8729; as = as&quot;</span><span class="">
</span><span class="keyword1">proof</span><span class=""> </span><span class="">-</span><span class="">
</span><span class="">  </span><span class="keyword1">from</span><span class=""> </span><span class="">a</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;supp p &#8838; {a. a &#8713; as}&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">supp_perm</span><span class=""> </span><span class="">fresh_star_def</span><span class=""> </span><span class="">fresh_def</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">  </span><span class="keyword1">then</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;p &#8729; as = as&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">proof</span><span class=""> </span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">p</span><span class=""> </span><span class="">rule</span><span class="delimiter">:</span><span class=""> </span><span class="">perm_struct_induct</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword3">case</span><span class=""> </span><span class="">zero</span><span class="">
</span><span class="">    </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;0 &#8729; as = as&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">  </span><span class="keyword1">next</span><span class="">
</span><span class="">    </span><span class="keyword3">case</span><span class=""> </span><span class="delimiter">(</span><span class="">swap</span><span class=""> </span><span class="">p</span><span class=""> </span><span class="">a</span><span class=""> </span><span class="">b</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1">then</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;a &#8713; as&quot;</span><span class=""> </span><span class="string">&quot;b &#8713; as&quot;</span><span class=""> </span><span class="string">&quot;p &#8729; as = as&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp_all</span><span class="">
</span><span class="">    </span><span class="keyword1">then</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;((a &#8652; b) + p) &#8729; as = as&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">swap_set_not_in</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">qed</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="keyword1">section</span><span class=""> </span><span class="verbatim">{* Avoiding of atom sets *}</span><span class="">
</span><span class="">
</span><span class="keyword1">text</span><span class=""> </span><span class="verbatim">{* 
  For every set of atoms, there is another set of atoms
  avoiding a finitely supported c and there is a permutation
  which &#39;translates&#39; between both sets.
*}</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">at_set_avoiding_aux</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">fixes</span><span class=""> </span><span class="">Xs</span><span class="delimiter">::</span><span class="string">&quot;atom set&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">and</span><span class="">   </span><span class="">As</span><span class="delimiter">::</span><span class="string">&quot;atom set&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="">b</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;Xs &#8838; As&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">and</span><span class="">     </span><span class="">c</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;finite As&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;&#8707;p. (p &#8729; Xs) &#8745; As = {} &#8743; (supp p) = (Xs &#8746; (p &#8729; Xs))&quot;</span><span class="">
</span><span class="keyword1">proof</span><span class=""> </span><span class="">-</span><span class="">
</span><span class="">  </span><span class="keyword1">from</span><span class=""> </span><span class="">b</span><span class=""> </span><span class="">c</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;finite Xs&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">finite_subset</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">then</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="var">?thesis</span><span class=""> </span><span class="keyword1">using</span><span class=""> </span><span class="">b</span><span class="">
</span><span class="">  </span><span class="keyword1">proof</span><span class=""> </span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">rule</span><span class="delimiter">:</span><span class=""> </span><span class="">finite_subset_induct</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword3">case</span><span class=""> </span><span class="">empty</span><span class="">
</span><span class="">    </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;0 &#8729; {} &#8745; As = {}&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">    </span><span class="keyword1">moreover</span><span class="">
</span><span class="">    </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;supp (0::perm) = {} &#8746; 0 &#8729; {}&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">supp_zero_perm</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1">ultimately</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="var">?case</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">blast</span><span class="">
</span><span class="">  </span><span class="keyword1">next</span><span class="">
</span><span class="">    </span><span class="keyword3">case</span><span class=""> </span><span class="delimiter">(</span><span class="">insert</span><span class=""> </span><span class="">x</span><span class=""> </span><span class="">Xs</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1">then</span><span class=""> </span><span class="keyword3">obtain</span><span class=""> </span><span class="">p</span><span class=""> </span><span class="keyword2">where</span><span class="">
</span><span class="">      </span><span class="">p1</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;(p &#8729; Xs) &#8745; As = {}&quot;</span><span class=""> </span><span class="keyword2">and</span><span class=""> 
</span><span class="">      </span><span class="">p2</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;supp p = (Xs &#8746; (p &#8729; Xs))&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">blast</span><span class="">
</span><span class="">    </span><span class="keyword1">from</span><span class=""> </span><span class="alt_string">`x &#8712; As`</span><span class=""> </span><span class="">p1</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;x &#8713; p &#8729; Xs&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">fast</span><span class="">
</span><span class="">    </span><span class="keyword1">with</span><span class=""> </span><span class="alt_string">`x &#8713; Xs`</span><span class=""> </span><span class="">p2</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;x &#8713; supp p&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">fast</span><span class="">
</span><span class="">    </span><span class="keyword1">hence</span><span class=""> </span><span class="">px</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;p &#8729; x = x&quot;</span><span class=""> </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">supp_perm</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">    </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;finite (As &#8746; p &#8729; Xs &#8746; supp p)&quot;</span><span class="">
</span><span class="">      </span><span class="keyword1">using</span><span class=""> </span><span class="alt_string">`finite As`</span><span class=""> </span><span class="alt_string">`finite Xs`</span><span class="">
</span><span class="">      </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">permute_set_eq_image</span><span class=""> </span><span class="">finite_supp</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1">then</span><span class=""> </span><span class="keyword3">obtain</span><span class=""> </span><span class="">y</span><span class=""> </span><span class="keyword2">where</span><span class=""> </span><span class="string">&quot;y &#8713; (As &#8746; p &#8729; Xs &#8746; supp p)&quot;</span><span class=""> </span><span class="string">&quot;sort_of y = sort_of x&quot;</span><span class="">
</span><span class="">      </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">obtain_atom</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1">hence</span><span class=""> </span><span class="">y</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;y &#8713; As&quot;</span><span class=""> </span><span class="string">&quot;y &#8713; p &#8729; Xs&quot;</span><span class=""> </span><span class="string">&quot;y &#8713; supp p&quot;</span><span class=""> </span><span class="string">&quot;sort_of y = sort_of x&quot;</span><span class="">
</span><span class="">      </span><span class="keyword1">by</span><span class=""> </span><span class="">simp_all</span><span class="">
</span><span class="">    </span><span class="keyword1">hence</span><span class=""> </span><span class="">py</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;p &#8729; y = y&quot;</span><span class=""> </span><span class="string">&quot;x &#8800; y&quot;</span><span class=""> </span><span class="keyword1">using</span><span class=""> </span><span class="alt_string">`x &#8712; As`</span><span class="">
</span><span class="">      </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class="delimiter">:</span><span class=""> </span><span class="">supp_perm</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1">let</span><span class=""> </span><span class="var">?q</span><span class=""> </span><span class="delimiter">=</span><span class=""> </span><span class="string">&quot;(x &#8652; y) + p&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">have</span><span class=""> </span><span class="">q</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;?q &#8729; insert x Xs = insert y (p &#8729; Xs)&quot;</span><span class="">
</span><span class="">      </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">insert_eqvt</span><span class="">
</span><span class="">      </span><span class="keyword1">using</span><span class=""> </span><span class="alt_string">`p &#8729; x = x`</span><span class=""> </span><span class="alt_string">`sort_of y = sort_of x`</span><span class="">
</span><span class="">      </span><span class="keyword1">using</span><span class=""> </span><span class="alt_string">`x &#8713; p &#8729; Xs`</span><span class=""> </span><span class="alt_string">`y &#8713; p &#8729; Xs`</span><span class="">
</span><span class="">      </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">swap_atom</span><span class=""> </span><span class="">swap_set_not_in</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;?q &#8729; insert x Xs &#8745; As = {}&quot;</span><span class="">
</span><span class="">      </span><span class="keyword1">using</span><span class=""> </span><span class="alt_string">`y &#8713; As`</span><span class=""> </span><span class="alt_string">`p &#8729; Xs &#8745; As = {}`</span><span class="">
</span><span class="">      </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">q</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">    </span><span class="keyword1">moreover</span><span class="">
</span><span class="">    </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;supp (x &#8652; y) &#8745; supp p = {}&quot;</span><span class=""> </span><span class="keyword1">using</span><span class=""> </span><span class="">px</span><span class=""> </span><span class="">py</span><span class=""> </span><span class="alt_string">`sort_of y = sort_of x`</span><span class="">
</span><span class="">      </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">supp_swap</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">supp_perm</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1">then</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;supp ?q = (supp (x &#8652; y) &#8746; supp p)&quot;</span><span class=""> 
</span><span class="">      </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">supp_plus_perm_eq</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1">then</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;supp ?q = insert x Xs &#8746; ?q &#8729; insert x Xs&quot;</span><span class="">
</span><span class="">      </span><span class="keyword1">using</span><span class=""> </span><span class="">p2</span><span class=""> </span><span class="alt_string">`sort_of y = sort_of x`</span><span class=""> </span><span class="alt_string">`x &#8800; y`</span><span class=""> </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">q</span><span class=""> </span><span class="">supp_swap</span><span class="">
</span><span class="">      </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">    </span><span class="keyword1">ultimately</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="var">?case</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">blast</span><span class="">
</span><span class="">  </span><span class="keyword1">qed</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">at_set_avoiding</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="">a</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;finite Xs&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">and</span><span class="">     </span><span class="">b</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;finite (supp c)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">obtains</span><span class=""> </span><span class="">p</span><span class="delimiter">::</span><span class="string">&quot;perm&quot;</span><span class=""> </span><span class="keyword2">where</span><span class=""> </span><span class="string">&quot;(p &#8729; Xs)&#9839;*c&quot;</span><span class=""> </span><span class="keyword2">and</span><span class=""> </span><span class="string">&quot;(supp p) = (Xs &#8746; (p &#8729; Xs))&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">using</span><span class=""> </span><span class="">a</span><span class=""> </span><span class="">b</span><span class=""> </span><span class="">at_set_avoiding_aux</span><span class=""> </span><span class="delimiter">[</span><span class="keyword2">where</span><span class=""> </span><span class="">Xs</span><span class="delimiter">=</span><span class="string">&quot;Xs&quot;</span><span class=""> </span><span class="keyword2">and</span><span class=""> </span><span class="">As</span><span class="delimiter">=</span><span class="string">&quot;Xs &#8746; supp c&quot;</span><span class="delimiter">]</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">fresh_star_def</span><span class=""> </span><span class="">fresh_def</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">blast</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">at_set_avoiding1</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="string">&quot;finite xs&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">and</span><span class="">     </span><span class="string">&quot;finite (supp c)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;&#8707;p. (p &#8729; xs) &#9839;* c&quot;</span><span class="">
</span><span class="keyword1">using</span><span class=""> </span><span class="">assms</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">erule_tac</span><span class=""> </span><span class="">c</span><span class="delimiter">=</span><span class="string">&quot;c&quot;</span><span class=""> </span><span class="keyword2">in</span><span class=""> </span><span class="">at_set_avoiding</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">auto</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">done</span></span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">at_set_avoiding2</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="string">&quot;finite xs&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">and</span><span class="">     </span><span class="string">&quot;finite (supp c)&quot;</span><span class=""> </span><span class="string">&quot;finite (supp x)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">and</span><span class="">     </span><span class="string">&quot;xs &#9839;* x&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;&#8707;p. (p &#8729; xs) &#9839;* c &#8743; supp x &#9839;* p&quot;</span><span class="">
</span><span class="keyword1">using</span><span class=""> </span><span class="">assms</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">erule_tac</span><span class=""> </span><span class="">c</span><span class="delimiter">=</span><span class="string">&quot;(c, x)&quot;</span><span class=""> </span><span class="keyword2">in</span><span class=""> </span><span class="">at_set_avoiding</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">supp_Pair</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">rule_tac</span><span class=""> </span><span class="">x</span><span class="delimiter">=</span><span class="string">&quot;p&quot;</span><span class=""> </span><span class="keyword2">in</span><span class=""> </span><span class="">exI</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">fresh_star_Pair</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">fresh_star_supp_conv</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class="delimiter">:</span><span class=""> </span><span class="">fresh_star_def</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">done</span></span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">at_set_avoiding3</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="string">&quot;finite xs&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">and</span><span class="">     </span><span class="string">&quot;finite (supp c)&quot;</span><span class=""> </span><span class="string">&quot;finite (supp x)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">and</span><span class="">     </span><span class="string">&quot;xs &#9839;* x&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;&#8707;p. (p &#8729; xs) &#9839;* c &#8743; supp x &#9839;* p &#8743; supp p = xs &#8746; (p &#8729; xs)&quot;</span><span class="">
</span><span class="keyword1">using</span><span class=""> </span><span class="">assms</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">erule_tac</span><span class=""> </span><span class="">c</span><span class="delimiter">=</span><span class="string">&quot;(c, x)&quot;</span><span class=""> </span><span class="keyword2">in</span><span class=""> </span><span class="">at_set_avoiding</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">supp_Pair</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">rule_tac</span><span class=""> </span><span class="">x</span><span class="delimiter">=</span><span class="string">&quot;p&quot;</span><span class=""> </span><span class="keyword2">in</span><span class=""> </span><span class="">exI</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">fresh_star_Pair</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">fresh_star_supp_conv</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class="delimiter">:</span><span class=""> </span><span class="">fresh_star_def</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">done</span></span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">at_set_avoiding2_atom</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="string">&quot;finite (supp c)&quot;</span><span class=""> </span><span class="string">&quot;finite (supp x)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">and</span><span class="">     </span><span class="">b</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;a &#9839; x&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;&#8707;p. (p &#8729; a) &#9839; c &#8743; supp x &#9839;* p&quot;</span><span class="">
</span><span class="keyword1">proof</span><span class=""> </span><span class="">-</span><span class="">
</span><span class="">  </span><span class="keyword1">have</span><span class=""> </span><span class="">a</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;{a} &#9839;* x&quot;</span><span class=""> </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">fresh_star_def</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">b</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword3">obtain</span><span class=""> </span><span class="">p</span><span class=""> </span><span class="keyword2">where</span><span class=""> </span><span class="">p1</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;(p &#8729; {a}) &#9839;* c&quot;</span><span class=""> </span><span class="keyword2">and</span><span class=""> </span><span class="">p2</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;supp x &#9839;* p&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">using</span><span class=""> </span><span class="">at_set_avoiding2</span><span class="delimiter">[</span><span class="">of</span><span class=""> </span><span class="string">&quot;{a}&quot;</span><span class=""> </span><span class="string">&quot;c&quot;</span><span class=""> </span><span class="string">&quot;x&quot;</span><span class="delimiter">]</span><span class=""> </span><span class="">assms</span><span class=""> </span><span class="">a</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">blast</span><span class="">
</span><span class="">  </span><span class="keyword1">have</span><span class=""> </span><span class="">c</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;(p &#8729; a) &#9839; c&quot;</span><span class=""> </span><span class="keyword1">using</span><span class=""> </span><span class="">p1</span><span class="">
</span><span class="">    </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">fresh_star_def</span><span class=""> </span><span class="">Ball_def</span><span class=""> 
</span><span class="">    </span><span class="keyword1">by</span><span class="delimiter">(</span><span class="">erule_tac</span><span class=""> </span><span class="">x</span><span class="delimiter">=</span><span class="string">&quot;p &#8729; a&quot;</span><span class=""> </span><span class="keyword2">in</span><span class=""> </span><span class="">allE</span><span class="delimiter">)</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">permute_set_def</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">hence</span><span class=""> </span><span class="string">&quot;p &#8729; a &#9839; c &#8743; supp x &#9839;* p&quot;</span><span class=""> </span><span class="keyword1">using</span><span class=""> </span><span class="">p2</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">blast</span><span class="">
</span><span class="">  </span><span class="keyword1">then</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;&#8707;p. (p &#8729; a) &#9839; c &#8743; supp x &#9839;* p&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">blast</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="">
</span><span class="keyword1">section</span><span class=""> </span><span class="verbatim">{* Renaming permutations *}</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">set_renaming_perm</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="">b</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;finite bs&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;&#8707;q. (&#8704;b &#8712; bs. q &#8729; b = p &#8729; b) &#8743; supp q &#8838; bs &#8746; (p &#8729; bs)&quot;</span><span class="">
</span><span class="keyword1">using</span><span class=""> </span><span class="">b</span><span class="">
</span><span class="keyword1">proof</span><span class=""> </span><span class="delimiter">(</span><span class="">induct</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword3">case</span><span class=""> </span><span class="">empty</span><span class="">
</span><span class="">  </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;(&#8704;b &#8712; {}. 0 &#8729; b = p &#8729; b) &#8743; supp (0::perm) &#8838; {} &#8746; p &#8729; {}&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">permute_set_def</span><span class=""> </span><span class="">supp_perm</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">then</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;&#8707;q. (&#8704;b &#8712; {}. q &#8729; b = p &#8729; b) &#8743; supp q &#8838; {} &#8746; p &#8729; {}&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">blast</span><span class="">
</span><span class="keyword1">next</span><span class="">
</span><span class="">  </span><span class="keyword3">case</span><span class=""> </span><span class="delimiter">(</span><span class="">insert</span><span class=""> </span><span class="">a</span><span class=""> </span><span class="">bs</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">then</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot; &#8707;q. (&#8704;b &#8712; bs. q &#8729; b = p &#8729; b) &#8743; supp q &#8838; bs &#8746; p &#8729; bs&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class=""> 
</span><span class="">  </span><span class="keyword1">then</span><span class=""> </span><span class="keyword3">obtain</span><span class=""> </span><span class="">q</span><span class=""> </span><span class="keyword2">where</span><span class=""> </span><span class="">*</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;&#8704;b &#8712; bs. q &#8729; b = p &#8729; b&quot;</span><span class=""> </span><span class="keyword2">and</span><span class=""> </span><span class="">**</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;supp q &#8838; bs &#8746; p &#8729; bs&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">metis</span><span class=""> </span><span class="">empty_subsetI</span><span class=""> </span><span class="">insert</span><span class="delimiter">(</span><span class="">3</span><span class="delimiter">)</span><span class=""> </span><span class="">supp_swap</span><span class="delimiter">)</span><span class=""> 
</span><span class="">  </span><span class="keyword1">{</span><span class=""> </span><span class="keyword3">assume</span><span class=""> </span><span class="">1</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;q &#8729; a = p &#8729; a&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;&#8704;b &#8712; (insert a bs). q &#8729; b = p &#8729; b&quot;</span><span class=""> </span><span class="keyword1">using</span><span class=""> </span><span class="">1</span><span class=""> </span><span class="">*</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">    </span><span class="keyword1">moreover</span><span class=""> 
</span><span class="">    </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;supp q &#8838; insert a bs &#8746; p &#8729; insert a bs&quot;</span><span class=""> 
</span><span class="">      </span><span class="keyword1">using</span><span class=""> </span><span class="">**</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class="delimiter">:</span><span class=""> </span><span class="">insert_eqvt</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1">ultimately</span><span class=""> 
</span><span class="">    </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;&#8707;q. (&#8704;b &#8712; insert a bs. q &#8729; b = p &#8729; b) &#8743; supp q &#8838; insert a bs &#8746; p &#8729; insert a bs&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">blast</span><span class="">
</span><span class="">  </span><span class="keyword1">}</span><span class="">
</span><span class="">  </span><span class="keyword1">moreover</span><span class="">
</span><span class="">  </span><span class="keyword1">{</span><span class=""> </span><span class="keyword3">assume</span><span class=""> </span><span class="">2</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;q &#8729; a &#8800; p &#8729; a&quot;</span><span class="">
</span><span class="">    </span><span class="keyword3">def</span><span class=""> </span><span class="">q&#39;</span><span class=""> </span><span class="delimiter">&#8801;</span><span class=""> </span><span class="string">&quot;((q &#8729; a) &#8652; (p &#8729; a)) + q&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;&#8704;b &#8712; insert a bs. q&#39; &#8729; b = p &#8729; b&quot;</span><span class=""> </span><span class="keyword1">using</span><span class=""> </span><span class="">2</span><span class=""> </span><span class="">*</span><span class=""> </span><span class="alt_string">`a &#8713; bs`</span><span class=""> </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">q&#39;_def</span><span class="">
</span><span class="">      </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class="delimiter">:</span><span class=""> </span><span class="">swap_atom</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1">moreover</span><span class=""> 
</span><span class="">    </span><span class="keyword1">{</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;{q &#8729; a, p &#8729; a} &#8838; insert a bs &#8746; p &#8729; insert a bs&quot;</span><span class="">
</span><span class="">        </span><span class="keyword1">using</span><span class=""> </span><span class="">**</span><span class=""> 
</span><span class="">        </span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class="delimiter">:</span><span class=""> </span><span class="">supp_perm</span><span class=""> </span><span class="">insert_eqvt</span><span class="delimiter">)</span><span class="">
</span><span class="">        </span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">subgoal_tac</span><span class=""> </span><span class="string">&quot;q &#8729; a &#8712; bs &#8746; p &#8729; bs&quot;</span><span class="delimiter">)</span><span class="">
</span><span class="">        </span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">auto</span><span class="delimiter">)</span><span class="delimiter">[</span><span class="">1</span><span class="delimiter">]</span><span class="">
</span><span class="">        </span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">subgoal_tac</span><span class=""> </span><span class="string">&quot;q &#8729; a &#8712; {a. q &#8729; a &#8800; a}&quot;</span><span class="delimiter">)</span><span class="">
</span><span class="">        </span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">blast</span><span class="delimiter">)</span><span class="">
</span><span class="">        </span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">simp</span><span class="delimiter">)</span><span class="">
</span><span class="">        </span><span class="keyword1"><span class="improper">done</span></span><span class="">
</span><span class="">      </span><span class="keyword1">then</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;supp (q &#8729; a &#8652; p &#8729; a) &#8838; insert a bs &#8746; p &#8729; insert a bs&quot;</span><span class=""> 
</span><span class="">        </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">supp_swap</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">      </span><span class="keyword1">moreover</span><span class="">
</span><span class="">      </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;supp q &#8838; insert a bs &#8746; p &#8729; insert a bs&quot;</span><span class=""> 
</span><span class="">        </span><span class="keyword1">using</span><span class=""> </span><span class="">**</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class="delimiter">:</span><span class=""> </span><span class="">insert_eqvt</span><span class="delimiter">)</span><span class="">
</span><span class="">      </span><span class="keyword1">ultimately</span><span class=""> 
</span><span class="">      </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;supp q&#39; &#8838; insert a bs &#8746; p &#8729; insert a bs&quot;</span><span class=""> 
</span><span class="">        </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">q&#39;_def</span><span class=""> </span><span class="keyword1">using</span><span class=""> </span><span class="">supp_plus_perm</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">blast</span><span class="">
</span><span class="">    </span><span class="keyword1">}</span><span class="">
</span><span class="">    </span><span class="keyword1">ultimately</span><span class=""> 
</span><span class="">    </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;&#8707;q. (&#8704;b &#8712; insert a bs. q &#8729; b = p &#8729; b) &#8743; supp q &#8838; insert a bs &#8746; p &#8729; insert a bs&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">blast</span><span class="">
</span><span class="">  </span><span class="keyword1">}</span><span class="">
</span><span class="">  </span><span class="keyword1">ultimately</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;&#8707;q. (&#8704;b &#8712; insert a bs. q &#8729; b = p &#8729; b) &#8743; supp q &#8838; insert a bs &#8746; p &#8729; insert a bs&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">by</span><span class=""> </span><span class="">blast</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">set_renaming_perm2</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;&#8707;q. (&#8704;b &#8712; bs. q &#8729; b = p &#8729; b) &#8743; supp q &#8838; bs &#8746; (p &#8729; bs)&quot;</span><span class="">
</span><span class="keyword1">proof</span><span class=""> </span><span class="">-</span><span class="">
</span><span class="">  </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;finite (bs &#8745; supp p)&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">finite_supp</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">then</span><span class=""> </span><span class="keyword3">obtain</span><span class=""> </span><span class="">q</span><span class=""> 
</span><span class="">    </span><span class="keyword2">where</span><span class=""> </span><span class="">*</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;&#8704;b &#8712; bs &#8745; supp p. q &#8729; b = p &#8729; b&quot;</span><span class=""> </span><span class="keyword2">and</span><span class=""> </span><span class="">**</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;supp q &#8838; (bs &#8745; supp p) &#8746; (p &#8729; (bs &#8745; supp p))&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">using</span><span class=""> </span><span class="">set_renaming_perm</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">blast</span><span class="">
</span><span class="">  </span><span class="keyword1">from</span><span class=""> </span><span class="">**</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;supp q &#8838; bs &#8746; (p &#8729; bs)&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class="delimiter">:</span><span class=""> </span><span class="">inter_eqvt</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">moreover</span><span class="">
</span><span class="">  </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;&#8704;b &#8712; bs - supp p. q &#8729; b = p &#8729; b&quot;</span><span class=""> 
</span><span class="">    </span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">auto</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">subgoal_tac</span><span class=""> </span><span class="string">&quot;b &#8713; supp q&quot;</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">fresh_def</span><span class="delimiter">[</span><span class="">symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">fresh_perm</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">clarify</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">rotate_tac</span><span class=""> </span><span class="">2</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">drule</span><span class=""> </span><span class="">subsetD</span><span class="delimiter">[</span><span class="">OF</span><span class=""> </span><span class="">**</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">inter_eqvt</span><span class=""> </span><span class="">supp_eqvt</span><span class=""> </span><span class="">permute_self</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1"><span class="improper">done</span></span><span class="">
</span><span class="">  </span><span class="keyword1">ultimately</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;(&#8704;b &#8712; bs. q &#8729; b = p &#8729; b) &#8743; supp q &#8838; bs &#8746; (p &#8729; bs)&quot;</span><span class=""> </span><span class="keyword1">using</span><span class=""> </span><span class="">*</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">  </span><span class="keyword1">then</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;&#8707;q. (&#8704;b &#8712; bs. q &#8729; b = p &#8729; b) &#8743; supp q &#8838; bs &#8746; (p &#8729; bs)&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">blast</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">    
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">list_renaming_perm</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;&#8707;q. (&#8704;b &#8712; set bs. q &#8729; b = p &#8729; b) &#8743; supp q &#8838; set bs &#8746; (p &#8729; set bs)&quot;</span><span class="">
</span><span class="keyword1">proof</span><span class=""> </span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">bs</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword3">case</span><span class=""> </span><span class="delimiter">(</span><span class="">Cons</span><span class=""> </span><span class="">a</span><span class=""> </span><span class="">bs</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">then</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot; &#8707;q. (&#8704;b &#8712; set bs. q &#8729; b = p &#8729; b) &#8743; supp q &#8838; set bs &#8746; p &#8729; (set bs)&quot;</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">  </span><span class="keyword1">then</span><span class=""> </span><span class="keyword3">obtain</span><span class=""> </span><span class="">q</span><span class=""> </span><span class="keyword2">where</span><span class=""> </span><span class="">*</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;&#8704;b &#8712; set bs. q &#8729; b = p &#8729; b&quot;</span><span class=""> </span><span class="keyword2">and</span><span class=""> </span><span class="">**</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;supp q &#8838; set bs &#8746; p &#8729; (set bs)&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">blast</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">{</span><span class=""> </span><span class="keyword3">assume</span><span class=""> </span><span class="">1</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;a &#8712; set bs&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;q &#8729; a = p &#8729; a&quot;</span><span class=""> </span><span class="keyword1">using</span><span class=""> </span><span class="">*</span><span class=""> </span><span class="">1</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">bs</span><span class="delimiter">)</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1">then</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;&#8704;b &#8712; set (a # bs). q &#8729; b = p &#8729; b&quot;</span><span class=""> </span><span class="keyword1">using</span><span class=""> </span><span class="">*</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class=""> 
</span><span class="">    </span><span class="keyword1">moreover</span><span class=""> 
</span><span class="">    </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;supp q &#8838; set (a # bs) &#8746; p &#8729; (set (a # bs))&quot;</span><span class=""> </span><span class="keyword1">using</span><span class=""> </span><span class="">**</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class="delimiter">:</span><span class=""> </span><span class="">insert_eqvt</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1">ultimately</span><span class=""> 
</span><span class="">    </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;&#8707;q. (&#8704;b &#8712; set (a # bs). q &#8729; b = p &#8729; b) &#8743; supp q &#8838; set (a # bs) &#8746; p &#8729; (set (a # bs))&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">blast</span><span class="">
</span><span class="">  </span><span class="keyword1">}</span><span class="">
</span><span class="">  </span><span class="keyword1">moreover</span><span class="">
</span><span class="">  </span><span class="keyword1">{</span><span class=""> </span><span class="keyword3">assume</span><span class=""> </span><span class="">2</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;a &#8713; set bs&quot;</span><span class="">
</span><span class="">    </span><span class="keyword3">def</span><span class=""> </span><span class="">q&#39;</span><span class=""> </span><span class="delimiter">&#8801;</span><span class=""> </span><span class="string">&quot;((q &#8729; a) &#8652; (p &#8729; a)) + q&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;&#8704;b &#8712; set (a # bs). q&#39; &#8729; b = p &#8729; b&quot;</span><span class=""> 
</span><span class="">      </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">q&#39;_def</span><span class=""> </span><span class="keyword1">using</span><span class=""> </span><span class="">2</span><span class=""> </span><span class="">*</span><span class=""> </span><span class="alt_string">`a &#8713; set bs`</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class="delimiter">:</span><span class=""> </span><span class="">swap_atom</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1">moreover</span><span class=""> 
</span><span class="">    </span><span class="keyword1">{</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;{q &#8729; a, p &#8729; a} &#8838; set (a # bs) &#8746; p &#8729; (set (a # bs))&quot;</span><span class="">
</span><span class="">        </span><span class="keyword1">using</span><span class=""> </span><span class="">**</span><span class="">
</span><span class="">        </span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class="delimiter">:</span><span class=""> </span><span class="">supp_perm</span><span class=""> </span><span class="">insert_eqvt</span><span class="delimiter">)</span><span class="">
</span><span class="">        </span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">subgoal_tac</span><span class=""> </span><span class="string">&quot;q &#8729; a &#8712; set bs &#8746; p &#8729; set bs&quot;</span><span class="delimiter">)</span><span class="">
</span><span class="">        </span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">auto</span><span class="delimiter">)</span><span class="delimiter">[</span><span class="">1</span><span class="delimiter">]</span><span class="">
</span><span class="">        </span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">subgoal_tac</span><span class=""> </span><span class="string">&quot;q &#8729; a &#8712; {a. q &#8729; a &#8800; a}&quot;</span><span class="delimiter">)</span><span class="">
</span><span class="">        </span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">blast</span><span class="delimiter">)</span><span class="">
</span><span class="">        </span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">simp</span><span class="delimiter">)</span><span class="">
</span><span class="">        </span><span class="keyword1"><span class="improper">done</span></span><span class="">
</span><span class="">      </span><span class="keyword1">then</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;supp (q &#8729; a &#8652; p &#8729; a) &#8838; set (a # bs) &#8746; p &#8729; set (a # bs)&quot;</span><span class=""> 
</span><span class="">        </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">supp_swap</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">      </span><span class="keyword1">moreover</span><span class="">
</span><span class="">      </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;supp q &#8838; set (a # bs) &#8746; p &#8729; (set (a # bs))&quot;</span><span class=""> 
</span><span class="">        </span><span class="keyword1">using</span><span class=""> </span><span class="">**</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class="delimiter">:</span><span class=""> </span><span class="">insert_eqvt</span><span class="delimiter">)</span><span class="">
</span><span class="">      </span><span class="keyword1">ultimately</span><span class=""> 
</span><span class="">      </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;supp q&#39; &#8838; set (a # bs) &#8746; p &#8729; (set (a # bs))&quot;</span><span class=""> 
</span><span class="">        </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">q&#39;_def</span><span class=""> </span><span class="keyword1">using</span><span class=""> </span><span class="">supp_plus_perm</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">blast</span><span class="">
</span><span class="">    </span><span class="keyword1">}</span><span class="">
</span><span class="">    </span><span class="keyword1">ultimately</span><span class=""> 
</span><span class="">    </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;&#8707;q. (&#8704;b &#8712; set (a # bs).  q &#8729; b = p &#8729; b) &#8743; supp q &#8838; set (a # bs) &#8746; p &#8729; (set (a # bs))&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">blast</span><span class="">
</span><span class="">  </span><span class="keyword1">}</span><span class="">
</span><span class="">  </span><span class="keyword1">ultimately</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;&#8707;q. (&#8704;b &#8712; set (a # bs). q &#8729; b = p &#8729; b) &#8743; supp q &#8838; set (a # bs) &#8746; p &#8729; (set (a # bs))&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">by</span><span class=""> </span><span class="">blast</span><span class="">
</span><span class="keyword1">next</span><span class="">
</span><span class=""> </span><span class="keyword3">case</span><span class=""> </span><span class="">Nil</span><span class="">
</span><span class="">  </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;(&#8704;b &#8712; set []. 0 &#8729; b = p &#8729; b) &#8743; supp (0::perm) &#8838; set [] &#8746; p &#8729; set []&quot;</span><span class=""> 
</span><span class="">    </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">supp_zero_perm</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">then</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;&#8707;q. (&#8704;b &#8712; set []. q &#8729; b = p &#8729; b) &#8743; supp q &#8838; set [] &#8746; p &#8729; (set [])&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">blast</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="">
</span><span class="keyword1">section</span><span class=""> </span><span class="verbatim">{* Concrete Atoms Types *}</span><span class="">
</span><span class="">
</span><span class="keyword1">text</span><span class=""> </span><span class="verbatim">{*
  Class @{text at_base} allows types containing multiple sorts of atoms.
  Class @{text at} only allows types with a single sort.
*}</span><span class="">
</span><span class="">
</span><span class="keyword1">class</span><span class=""> </span><span class="">at_base</span><span class=""> </span><span class="delimiter">=</span><span class=""> </span><span class="">pt</span><span class=""> </span><span class="delimiter">+</span><span class="">
</span><span class="">  </span><span class="keyword2">fixes</span><span class=""> </span><span class="">atom</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;&#39;a &#8658; atom&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="">atom_eq_iff</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;atom a = atom b &#10231; a = b&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="">atom_eqvt</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;p &#8729; (atom a) = atom (p &#8729; a)&quot;</span><span class="">
</span><span class="">
</span><span class="keyword1">declare</span><span class=""> </span><span class="">atom_eqvt</span><span class=""> </span><span class="delimiter">[</span><span class="">eqvt</span><span class="delimiter">]</span><span class="">
</span><span class="">
</span><span class="keyword1">class</span><span class=""> </span><span class="">at</span><span class=""> </span><span class="delimiter">=</span><span class=""> </span><span class="">at_base</span><span class=""> </span><span class="delimiter">+</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="">sort_of_atom_eq</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;sort_of (atom a) = sort_of (atom b)&quot;</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">sort_ineq</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="string">&quot;sort_of (atom a) &#8800; sort_of (atom b)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;atom a &#8800; atom b&quot;</span><span class="">
</span><span class="keyword1">using</span><span class=""> </span><span class="">assms</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">metis</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">supp_at_base</span><span class="delimiter">:</span><span class=""> 
</span><span class="">  </span><span class="keyword2">fixes</span><span class=""> </span><span class="">a</span><span class="delimiter">::</span><span class="string">&quot;&#39;a::at_base&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;supp a = {atom a}&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">supp_atom</span><span class=""> </span><span class="delimiter">[</span><span class="">symmetric</span><span class="delimiter">]</span><span class=""> </span><span class="">supp_def</span><span class=""> </span><span class="">atom_eqvt</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">fresh_at_base</span><span class="delimiter">:</span><span class=""> 
</span><span class="">  </span><span class="keyword2">shows</span><span class="">  </span><span class="string">&quot;sort_of a &#8800; sort_of (atom b) &#10233; a &#9839; b&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">and</span><span class=""> </span><span class="string">&quot;a &#9839; b &#10231; a &#8800; atom b&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">fresh_def</span><span class=""> 
</span><span class="">  </span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">simp_all</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">supp_at_base</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">metis</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">done</span></span><span class="">
</span><span class="">
</span><span class="comment">(* solves the freshness only if the inequality can be shown by the
   simproc below *)</span><span class="">  
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">fresh_ineq_at_base</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;a &#8800; atom b &#10233; a &#9839; b&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">fresh_at_base</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">fresh_atom_at_base</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> 
</span><span class="">  </span><span class="keyword2">fixes</span><span class=""> </span><span class="">b</span><span class="delimiter">::</span><span class="string">&quot;&#39;a::at_base&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;a &#9839; atom b &#10231; a &#9839; b&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">fresh_def</span><span class=""> </span><span class="">supp_at_base</span><span class=""> </span><span class="">supp_atom</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">fresh_star_atom_at_base</span><span class="delimiter">:</span><span class=""> 
</span><span class="">  </span><span class="keyword2">fixes</span><span class=""> </span><span class="">b</span><span class="delimiter">::</span><span class="string">&quot;&#39;a::at_base&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;as &#9839;* atom b &#10231; as &#9839;* b&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">fresh_star_def</span><span class=""> </span><span class="">fresh_atom_at_base</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">if_fresh_at_base</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;atom a &#9839; x &#10233; P (if a = x then t else s) = P s&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">and</span><span class="">   </span><span class="string">&quot;atom a &#9839; x &#10233; P (if x = a then t else s) = P s&quot;</span><span class="">
</span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp_all</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">fresh_at_base</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="">
</span><span class="keyword1">simproc_setup</span><span class=""> </span><span class="">fresh_ineq</span><span class=""> </span><span class="delimiter">(</span><span class="string">&quot;x &#8800; (y::&#39;a::at_base)&quot;</span><span class="delimiter">)</span><span class=""> </span><span class="delimiter">=</span><span class=""> </span><span class="verbatim">{* fn _ =&gt; fn ctxt =&gt; fn ctrm =&gt;
  case Thm.term_of ctrm of @{term &quot;HOL.Not&quot;} $ (Const (@{const_name HOL.eq}, _) $ lhs $ rhs) =&gt;
    let  
      fun first_is_neg lhs rhs [] = NONE
        | first_is_neg lhs rhs (thm::thms) =
          (case Thm.prop_of thm of
             _ $ (@{term &quot;HOL.Not&quot;} $ (Const (@{const_name HOL.eq}, _) $ l $ r)) =&gt;
               (if l = lhs andalso r = rhs then SOME(thm)
                else if r = lhs andalso l = rhs then SOME(thm RS @{thm not_sym})
                else first_is_neg lhs rhs thms)  
        | _ =&gt; first_is_neg lhs rhs thms)

      val simp_thms = @{thms fresh_Pair fresh_at_base atom_eq_iff}
      val prems = Simplifier.prems_of ctxt
         |&gt; filter (fn thm =&gt; case Thm.prop_of thm of                    
            _ $ (Const (@{const_name fresh}, ty) $ (_ $ a) $ b) =&gt; 
            (let 
               val atms = a :: HOLogic.strip_tuple b
             in
               member (op=) atms lhs andalso member (op=) atms rhs
             end) 
            | _ =&gt; false)
         |&gt; map (simplify (put_simpset HOL_basic_ss ctxt addsimps simp_thms))
         |&gt; map (HOLogic.conj_elims ctxt)
         |&gt; flat
    in 
      case first_is_neg lhs rhs prems of
        SOME(thm) =&gt; SOME(thm RS @{thm Eq_TrueI})
      | NONE =&gt; NONE
    end
  | _ =&gt; NONE
*}</span><span class="">
</span><span class="">
</span><span class="">
</span><span class="keyword1">instance</span><span class=""> </span><span class="">at_base</span><span class=""> </span><span class="delimiter">&lt;</span><span class=""> </span><span class="">fs</span><span class="">
</span><span class="keyword1">proof</span><span class=""> </span><span class="keyword1">qed</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">supp_at_base</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">at_base_infinite</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;infinite (UNIV :: &#39;a::at_base set)&quot;</span><span class=""> </span><span class="delimiter">(</span><span class="keyword2">is</span><span class=""> </span><span class="string">&quot;infinite ?U&quot;</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1">proof</span><span class="">
</span><span class="">  </span><span class="keyword3">obtain</span><span class=""> </span><span class="">a</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="tfree">&#39;a</span><span class=""> </span><span class="keyword2">where</span><span class=""> </span><span class="string">&quot;True&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">  </span><span class="keyword3">assume</span><span class=""> </span><span class="string">&quot;finite ?U&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">hence</span><span class=""> </span><span class="string">&quot;finite (atom ` ?U)&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">finite_imageI</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">then</span><span class=""> </span><span class="keyword3">obtain</span><span class=""> </span><span class="">b</span><span class=""> </span><span class="keyword2">where</span><span class=""> </span><span class="">b</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;b &#8713; atom ` ?U&quot;</span><span class=""> </span><span class="string">&quot;sort_of b = sort_of (atom a)&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">obtain_atom</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">from</span><span class=""> </span><span class="">b</span><span class="delimiter">(</span><span class="">2</span><span class="delimiter">)</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;b = atom ((atom a &#8652; b) &#8729; a)&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">atom_eqvt</span><span class=""> </span><span class="delimiter">[</span><span class="">symmetric</span><span class="delimiter">]</span><span class="">
</span><span class="">    </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">swap_atom</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">hence</span><span class=""> </span><span class="string">&quot;b &#8712; atom ` ?U&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">  </span><span class="keyword1">with</span><span class=""> </span><span class="">b</span><span class="delimiter">(</span><span class="">1</span><span class="delimiter">)</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;False&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">swap_at_base_simps</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">fixes</span><span class=""> </span><span class="">x</span><span class=""> </span><span class="">y</span><span class="delimiter">::</span><span class="string">&quot;&#39;a::at_base&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;sort_of (atom x) = sort_of (atom y) &#10233; (atom x &#8652; atom y) &#8729; x = y&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">and</span><span class="">   </span><span class="string">&quot;sort_of (atom x) = sort_of (atom y) &#10233; (atom x &#8652; atom y) &#8729; y = x&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">and</span><span class="">   </span><span class="string">&quot;atom x &#8800; a &#10233; atom x &#8800; b &#10233; (a &#8652; b) &#8729; x = x&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">atom_eq_iff</span><span class=""> </span><span class="delimiter">[</span><span class="">symmetric</span><span class="delimiter">]</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">atom_eqvt</span><span class=""> </span><span class="delimiter">[</span><span class="">symmetric</span><span class="delimiter">]</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="">simp_all</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">obtain_at_base</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="">X</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;finite X&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">obtains</span><span class=""> </span><span class="">a</span><span class="delimiter">::</span><span class="string">&quot;&#39;a::at_base&quot;</span><span class=""> </span><span class="keyword2">where</span><span class=""> </span><span class="string">&quot;atom a &#8713; X&quot;</span><span class="">
</span><span class="keyword1">proof</span><span class=""> </span><span class="">-</span><span class="">
</span><span class="">  </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;inj (atom :: &#39;a &#8658; atom)&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">inj_on_def</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">with</span><span class=""> </span><span class="">X</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;finite (atom -` X :: &#39;a set)&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">finite_vimageI</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">with</span><span class=""> </span><span class="">at_base_infinite</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;atom -` X &#8800; (UNIV :: &#39;a set)&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">  </span><span class="keyword1">then</span><span class=""> </span><span class="keyword3">obtain</span><span class=""> </span><span class="">a</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="tfree">&#39;a</span><span class=""> </span><span class="keyword2">where</span><span class=""> </span><span class="string">&quot;atom a &#8713; X&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">  </span><span class="keyword3">thus</span><span class=""> </span><span class="var">?thesis</span><span class=""> </span><span class="keyword1">..</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">obtain_fresh&#39;</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="">fin</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;finite (supp x)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">obtains</span><span class=""> </span><span class="">a</span><span class="delimiter">::</span><span class="string">&quot;&#39;a::at_base&quot;</span><span class=""> </span><span class="keyword2">where</span><span class=""> </span><span class="string">&quot;atom a &#9839; x&quot;</span><span class="">
</span><span class="keyword1">using</span><span class=""> </span><span class="">obtain_at_base</span><span class="delimiter">[</span><span class="keyword2">where</span><span class=""> </span><span class="">X</span><span class="delimiter">=</span><span class="string">&quot;supp x&quot;</span><span class="delimiter">]</span><span class="">
</span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class="delimiter">:</span><span class=""> </span><span class="">fresh_def</span><span class=""> </span><span class="">fin</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">obtain_fresh</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">fixes</span><span class=""> </span><span class="">x</span><span class="delimiter">::</span><span class="string">&quot;&#39;b::fs&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">obtains</span><span class=""> </span><span class="">a</span><span class="delimiter">::</span><span class="string">&quot;&#39;a::at_base&quot;</span><span class=""> </span><span class="keyword2">where</span><span class=""> </span><span class="string">&quot;atom a &#9839; x&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">obtain_fresh&#39;</span><span class="delimiter">)</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class="delimiter">:</span><span class=""> </span><span class="">finite_supp</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">supp_finite_set_at_base</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="">a</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;finite S&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;supp S = atom ` S&quot;</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">supp_of_finite_sets</span><span class="delimiter">[</span><span class="">OF</span><span class=""> </span><span class="">a</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">supp_at_base</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">auto</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">done</span></span><span class="">
</span><span class="">
</span><span class="comment">(* FIXME 
lemma supp_cofinite_set_at_base:
  assumes a: &quot;finite (UNIV - S)&quot;
  shows &quot;supp S = atom ` (UNIV - S)&quot;
apply(rule finite_supp_unique)
*)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">fresh_finite_set_at_base</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">fixes</span><span class=""> </span><span class="">a</span><span class="delimiter">::</span><span class="string">&quot;&#39;a::at_base&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="">a</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;finite S&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;atom a &#9839; S &#10231; a &#8713; S&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">fresh_def</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">supp_finite_set_at_base</span><span class="delimiter">[</span><span class="">OF</span><span class=""> </span><span class="">a</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">subst</span><span class=""> </span><span class="">inj_image_mem_iff</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">inj_on_def</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">apply</span></span><span class="delimiter">(</span><span class="">simp</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">done</span></span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">fresh_at_base_permute_iff</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">fixes</span><span class=""> </span><span class="">a</span><span class="delimiter">::</span><span class="string">&quot;&#39;a::at_base&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;atom (p &#8729; a) &#9839; p &#8729; x &#10231; atom a &#9839; x&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">atom_eqvt</span><span class="delimiter">[</span><span class="">symmetric</span><span class="delimiter">]</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">only</span><span class="delimiter">:</span><span class=""> </span><span class="">fresh_permute_iff</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">fresh_at_base_permI</span><span class="delimiter">:</span><span class=""> 
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;atom a &#9839; p &#10233; p &#8729; a = a&quot;</span><span class="">
</span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">fresh_def</span><span class=""> </span><span class="">supp_perm</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="">
</span><span class="keyword1">section</span><span class=""> </span><span class="verbatim">{* Infrastructure for concrete atom types *}</span><span class="">
</span><span class="">
</span><span class="keyword1">definition</span><span class="">
</span><span class="">  </span><span class="">flip</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;&#39;a::at_base &#8658; &#39;a &#8658; perm&quot;</span><span class=""> </span><span class="delimiter">(</span><span class="string">&quot;&#39;(_ &#8596; _&#39;)&quot;</span><span class="delimiter">)</span><span class="">
</span><span class="keyword2">where</span><span class="">
</span><span class="">  </span><span class="string">&quot;(a &#8596; b) = (atom a &#8652; atom b)&quot;</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">flip_fresh_fresh</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="string">&quot;atom a &#9839; x&quot;</span><span class=""> </span><span class="string">&quot;atom b &#9839; x&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;(a &#8596; b) &#8729; x = x&quot;</span><span class="">
</span><span class="keyword1">using</span><span class=""> </span><span class="">assms</span><span class="">
</span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">flip_def</span><span class=""> </span><span class="">swap_fresh_fresh</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">flip_self</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;(a &#8596; a) = 0&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">flip_def</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">swap_self</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">flip_commute</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;(a &#8596; b) = (b &#8596; a)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">flip_def</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">swap_commute</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">minus_flip</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;- (a &#8596; b) = (a &#8596; b)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">flip_def</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">minus_swap</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">add_flip_cancel</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;(a &#8596; b) + (a &#8596; b) = 0&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">flip_def</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">swap_cancel</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">permute_flip_cancel</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;(a &#8596; b) &#8729; (a &#8596; b) &#8729; x = x&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">permute_plus</span><span class=""> </span><span class="delimiter">[</span><span class="">symmetric</span><span class="delimiter">]</span><span class=""> </span><span class="">add_flip_cancel</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">permute_flip_cancel2</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;(a &#8596; b) &#8729; (b &#8596; a) &#8729; x = x&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">flip_commute</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">flip_eqvt</span><span class=""> </span><span class="delimiter">[</span><span class="">eqvt</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> 
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;p &#8729; (a &#8596; b) = (p &#8729; a &#8596; p &#8729; b)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">flip_def</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">swap_eqvt</span><span class=""> </span><span class="">atom_eqvt</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">flip_at_base_simps</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;sort_of (atom a) = sort_of (atom b) &#10233; (a &#8596; b) &#8729; a = b&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">and</span><span class="">   </span><span class="string">&quot;sort_of (atom a) = sort_of (atom b) &#10233; (a &#8596; b) &#8729; b = a&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">and</span><span class="">   </span><span class="string">&quot;&#10214;a &#8800; c; b &#8800; c&#10215; &#10233; (a &#8596; b) &#8729; c = c&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">and</span><span class="">   </span><span class="string">&quot;sort_of (atom a) &#8800; sort_of (atom b) &#10233; (a &#8596; b) &#8729; x = x&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">flip_def</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">atom_eq_iff</span><span class=""> </span><span class="delimiter">[</span><span class="">symmetric</span><span class="delimiter">]</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">atom_eqvt</span><span class=""> </span><span class="delimiter">[</span><span class="">symmetric</span><span class="delimiter">]</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="">simp_all</span><span class="">
</span><span class="">
</span><span class="keyword1">text</span><span class=""> </span><span class="verbatim">{* the following two lemmas do not hold for at_base, 
  only for single sort atoms from at *}</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">flip_triple</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">fixes</span><span class=""> </span><span class="">a</span><span class=""> </span><span class="">b</span><span class=""> </span><span class="">c</span><span class="delimiter">::</span><span class="string">&quot;&#39;a::at&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="string">&quot;a &#8800; b&quot;</span><span class=""> </span><span class="keyword2">and</span><span class=""> </span><span class="string">&quot;c &#8800; b&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;(a &#8596; c) + (b &#8596; c) + (a &#8596; c) = (a &#8596; b)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">flip_def</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">swap_triple</span><span class="delimiter">)</span><span class=""> </span><span class="delimiter">(</span><span class="">simp_all</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">assms</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">permute_flip_at</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">fixes</span><span class=""> </span><span class="">a</span><span class=""> </span><span class="">b</span><span class=""> </span><span class="">c</span><span class="delimiter">::</span><span class="string">&quot;&#39;a::at&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;(a &#8596; b) &#8729; c = (if c = a then b else if c = b then a else c)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">flip_def</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">atom_eq_iff</span><span class=""> </span><span class="delimiter">[</span><span class="">THEN</span><span class=""> </span><span class="">iffD1</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">subst</span><span class=""> </span><span class="">atom_eqvt</span><span class=""> </span><span class="delimiter">[</span><span class="">symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">swap_atom</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">done</span></span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">flip_at_simps</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">fixes</span><span class=""> </span><span class="">a</span><span class=""> </span><span class="">b</span><span class="delimiter">::</span><span class="string">&quot;&#39;a::at&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;(a &#8596; b) &#8729; a = b&quot;</span><span class=""> 
</span><span class="">  </span><span class="keyword2">and</span><span class="">   </span><span class="string">&quot;(a &#8596; b) &#8729; b = a&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">permute_flip_at</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp_all</span><span class="">
</span><span class="">
</span><span class="">
</span><span class="keyword1">subsection</span><span class=""> </span><span class="verbatim">{* Syntax for coercing at-elements to the atom-type *}</span><span class="">
</span><span class="">
</span><span class="keyword1">syntax</span><span class="">
</span><span class="">  </span><span class="string">&quot;_atom_constrain&quot;</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;logic &#8658; type &#8658; logic&quot;</span><span class=""> </span><span class="delimiter">(</span><span class="string">&quot;_:::_&quot;</span><span class=""> </span><span class="delimiter">[</span><span class="">4</span><span class="delimiter">,</span><span class=""> </span><span class="">0</span><span class="delimiter">]</span><span class=""> </span><span class="">3</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">translations</span><span class="">
</span><span class="">  </span><span class="string">&quot;_atom_constrain a t&quot;</span><span class=""> </span><span class="delimiter">=&gt;</span><span class=""> </span><span class="string">&quot;CONST atom (_constrain a t)&quot;</span><span class="">
</span><span class="">
</span><span class="">
</span><span class="keyword1">subsection</span><span class=""> </span><span class="verbatim">{* A lemma for proving instances of class @{text at}. *}</span><span class="">
</span><span class="">
</span><span class="keyword1">setup</span><span class=""> </span><span class="verbatim">{* Sign.add_const_constraint (@{const_name &quot;permute&quot;}, NONE) *}</span><span class="">
</span><span class="keyword1">setup</span><span class=""> </span><span class="verbatim">{* Sign.add_const_constraint (@{const_name &quot;atom&quot;}, NONE) *}</span><span class="">
</span><span class="">
</span><span class="keyword1">text</span><span class=""> </span><span class="verbatim">{*
  New atom types are defined as subtypes of @{typ atom}.
*}</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">exists_eq_simple_sort</span><span class="delimiter">:</span><span class=""> 
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;&#8707;a. a &#8712; {a. sort_of a = s}&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">rule_tac</span><span class=""> </span><span class="">x</span><span class="delimiter">=</span><span class="string">&quot;Atom s 0&quot;</span><span class=""> </span><span class="keyword2">in</span><span class=""> </span><span class="">exI</span><span class="delimiter">,</span><span class=""> </span><span class="">simp</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">exists_eq_sort</span><span class="delimiter">:</span><span class=""> 
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;&#8707;a. a &#8712; {a. sort_of a &#8712; range sort_fun}&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">rule_tac</span><span class=""> </span><span class="">x</span><span class="delimiter">=</span><span class="string">&quot;Atom (sort_fun x) y&quot;</span><span class=""> </span><span class="keyword2">in</span><span class=""> </span><span class="">exI</span><span class="delimiter">,</span><span class=""> </span><span class="">simp</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">at_base_class</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">fixes</span><span class=""> </span><span class="">sort_fun</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;&#39;b &#8658; atom_sort&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">fixes</span><span class=""> </span><span class="">Rep</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;&#39;a &#8658; atom&quot;</span><span class=""> </span><span class="keyword2">and</span><span class=""> </span><span class="">Abs</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;atom &#8658; &#39;a&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="">type</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;type_definition Rep Abs {a. sort_of a &#8712; range sort_fun}&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="">atom_def</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;&#8896;a. atom a = Rep a&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="">permute_def</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;&#8896;p a. p &#8729; a = Abs (p &#8729; Rep a)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;OFCLASS(&#39;a, at_base_class)&quot;</span><span class="">
</span><span class="keyword1">proof</span><span class="">
</span><span class="">  </span><span class="keyword1">interpret</span><span class=""> </span><span class="">type_definition</span><span class=""> </span><span class="">Rep</span><span class=""> </span><span class="">Abs</span><span class=""> </span><span class="string">&quot;{a. sort_of a &#8712; range sort_fun}&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">type</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">have</span><span class=""> </span><span class="">sort_of_Rep</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;&#8896;a. sort_of (Rep a) &#8712; range sort_fun&quot;</span><span class=""> </span><span class="keyword1">using</span><span class=""> </span><span class="">Rep</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">  </span><span class="keyword3">fix</span><span class=""> </span><span class="">a</span><span class=""> </span><span class="">b</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="tfree">&#39;a</span><span class=""> </span><span class="keyword2">and</span><span class=""> </span><span class="">p</span><span class=""> </span><span class="">p1</span><span class=""> </span><span class="">p2</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="">perm</span><span class="">
</span><span class="">  </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;0 &#8729; a = a&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">permute_def</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">Rep_inverse</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;(p1 + p2) &#8729; a = p1 &#8729; p2 &#8729; a&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">permute_def</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">Abs_inverse</span><span class=""> </span><span class="">sort_of_Rep</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;atom a = atom b &#10231; a = b&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">atom_def</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">Rep_inject</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;p &#8729; atom a = atom (p &#8729; a)&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">permute_def</span><span class=""> </span><span class="">atom_def</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">Abs_inverse</span><span class=""> </span><span class="">sort_of_Rep</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="comment">(*
lemma at_class:
  fixes s :: atom_sort
  fixes Rep :: &quot;&#39;a &#8658; atom&quot; and Abs :: &quot;atom &#8658; &#39;a&quot;
  assumes type: &quot;type_definition Rep Abs {a. sort_of a &#8712; range (&#955;x::unit. s)}&quot;
  assumes atom_def: &quot;&#8896;a. atom a = Rep a&quot;
  assumes permute_def: &quot;&#8896;p a. p &#8729; a = Abs (p &#8729; Rep a)&quot;
  shows &quot;OFCLASS(&#39;a, at_class)&quot;
proof
  interpret type_definition Rep Abs &quot;{a. sort_of a &#8712; range (&#955;x::unit. s)}&quot; by (rule type)
  have sort_of_Rep: &quot;&#8896;a. sort_of (Rep a) = s&quot; using Rep by (simp add: image_def)
  fix a b :: &#39;a and p p1 p2 :: perm
  show &quot;0 &#8729; a = a&quot;
    unfolding permute_def by (simp add: Rep_inverse)
  show &quot;(p1 + p2) &#8729; a = p1 &#8729; p2 &#8729; a&quot;
    unfolding permute_def by (simp add: Abs_inverse sort_of_Rep)
  show &quot;sort_of (atom a) = sort_of (atom b)&quot;
    unfolding atom_def by (simp add: sort_of_Rep)
  show &quot;atom a = atom b &#10231; a = b&quot;
    unfolding atom_def by (simp add: Rep_inject)
  show &quot;p &#8729; atom a = atom (p &#8729; a)&quot;
    unfolding permute_def atom_def by (simp add: Abs_inverse sort_of_Rep)
qed
*)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">at_class</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">fixes</span><span class=""> </span><span class="">s</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="">atom_sort</span><span class="">
</span><span class="">  </span><span class="keyword2">fixes</span><span class=""> </span><span class="">Rep</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;&#39;a &#8658; atom&quot;</span><span class=""> </span><span class="keyword2">and</span><span class=""> </span><span class="">Abs</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;atom &#8658; &#39;a&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="">type</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;type_definition Rep Abs {a. sort_of a = s}&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="">atom_def</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;&#8896;a. atom a = Rep a&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="">permute_def</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;&#8896;p a. p &#8729; a = Abs (p &#8729; Rep a)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;OFCLASS(&#39;a, at_class)&quot;</span><span class="">
</span><span class="keyword1">proof</span><span class="">
</span><span class="">  </span><span class="keyword1">interpret</span><span class=""> </span><span class="">type_definition</span><span class=""> </span><span class="">Rep</span><span class=""> </span><span class="">Abs</span><span class=""> </span><span class="string">&quot;{a. sort_of a = s}&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">type</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">have</span><span class=""> </span><span class="">sort_of_Rep</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;&#8896;a. sort_of (Rep a) = s&quot;</span><span class=""> </span><span class="keyword1">using</span><span class=""> </span><span class="">Rep</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">image_def</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword3">fix</span><span class=""> </span><span class="">a</span><span class=""> </span><span class="">b</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="tfree">&#39;a</span><span class=""> </span><span class="keyword2">and</span><span class=""> </span><span class="">p</span><span class=""> </span><span class="">p1</span><span class=""> </span><span class="">p2</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="">perm</span><span class="">
</span><span class="">  </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;0 &#8729; a = a&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">permute_def</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">Rep_inverse</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;(p1 + p2) &#8729; a = p1 &#8729; p2 &#8729; a&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">permute_def</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">Abs_inverse</span><span class=""> </span><span class="">sort_of_Rep</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;sort_of (atom a) = sort_of (atom b)&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">atom_def</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">sort_of_Rep</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;atom a = atom b &#10231; a = b&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">atom_def</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">Rep_inject</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;p &#8729; atom a = atom (p &#8729; a)&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">permute_def</span><span class=""> </span><span class="">atom_def</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">Abs_inverse</span><span class=""> </span><span class="">sort_of_Rep</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">at_class_sort</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">fixes</span><span class=""> </span><span class="">s</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="">atom_sort</span><span class="">
</span><span class="">  </span><span class="keyword2">fixes</span><span class=""> </span><span class="">Rep</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;&#39;a &#8658; atom&quot;</span><span class=""> </span><span class="keyword2">and</span><span class=""> </span><span class="">Abs</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;atom &#8658; &#39;a&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">fixes</span><span class=""> </span><span class="">a</span><span class="delimiter">::</span><span class="string">&quot;&#39;a&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="">type</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;type_definition Rep Abs {a. sort_of a = s}&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="">atom_def</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;&#8896;a. atom a = Rep a&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;sort_of (atom a) = s&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">using</span><span class=""> </span><span class="">atom_def</span><span class=""> </span><span class="">type</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">type_definition_def</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">
</span><span class="">
</span><span class="keyword1">setup</span><span class=""> </span><span class="verbatim">{* Sign.add_const_constraint
  (@{const_name &quot;permute&quot;}, SOME @{typ &quot;perm &#8658; &#39;a::pt &#8658; &#39;a&quot;}) *}</span><span class="">
</span><span class="keyword1">setup</span><span class=""> </span><span class="verbatim">{* Sign.add_const_constraint
  (@{const_name &quot;atom&quot;}, SOME @{typ &quot;&#39;a::at_base &#8658; atom&quot;}) *}</span><span class="">
</span><span class="">
</span><span class="">
</span><span class="keyword1">section</span><span class=""> </span><span class="verbatim">{* Library functions for the nominal infrastructure *}</span><span class="">
</span><span class="">
</span><span class="keyword1">ML_file</span><span class=""> </span><span class="string">&quot;nominal_library.ML&quot;</span><span class="">
</span><span class="">
</span><span class="">
</span><span class="keyword1">section</span><span class=""> </span><span class="verbatim">{* The freshness lemma according to Andy Pitts *}</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">freshness_lemma</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">fixes</span><span class=""> </span><span class="">h</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;&#39;a::at &#8658; &#39;b::pt&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="">a</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;&#8707;a. atom a &#9839; (h, h a)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class="">  </span><span class="string">&quot;&#8707;x. &#8704;a. atom a &#9839; h &#10230; h a = x&quot;</span><span class="">
</span><span class="keyword1">proof</span><span class=""> </span><span class="">-</span><span class="">
</span><span class="">  </span><span class="keyword1">from</span><span class=""> </span><span class="">a</span><span class=""> </span><span class="keyword3">obtain</span><span class=""> </span><span class="">b</span><span class=""> </span><span class="keyword2">where</span><span class=""> </span><span class="">a1</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;atom b &#9839; h&quot;</span><span class=""> </span><span class="keyword2">and</span><span class=""> </span><span class="">a2</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;atom b &#9839; h b&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class="delimiter">:</span><span class=""> </span><span class="">fresh_Pair</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;&#8707;x. &#8704;a. atom a &#9839; h &#10230; h a = x&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">proof</span><span class=""> </span><span class="delimiter">(</span><span class="">intro</span><span class=""> </span><span class="">exI</span><span class=""> </span><span class="">allI</span><span class=""> </span><span class="">impI</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword3">fix</span><span class=""> </span><span class="">a</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="tfree">&#39;a</span><span class="">
</span><span class="">    </span><span class="keyword3">assume</span><span class=""> </span><span class="">a3</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;atom a &#9839; h&quot;</span><span class="">
</span><span class="">    </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;h a = h b&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">proof</span><span class=""> </span><span class="delimiter">(</span><span class="">cases</span><span class=""> </span><span class="string">&quot;a = b&quot;</span><span class="delimiter">)</span><span class="">
</span><span class="">      </span><span class="keyword3">assume</span><span class=""> </span><span class="string">&quot;a = b&quot;</span><span class="">
</span><span class="">      </span><span class="keyword3">thus</span><span class=""> </span><span class="string">&quot;h a = h b&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">    </span><span class="keyword1">next</span><span class="">
</span><span class="">      </span><span class="keyword3">assume</span><span class=""> </span><span class="string">&quot;a &#8800; b&quot;</span><span class="">
</span><span class="">      </span><span class="keyword1">hence</span><span class=""> </span><span class="string">&quot;atom a &#9839; b&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">fresh_at_base</span><span class="delimiter">)</span><span class="">
</span><span class="">      </span><span class="keyword1">with</span><span class=""> </span><span class="">a3</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;atom a &#9839; h b&quot;</span><span class=""> 
</span><span class="">        </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">fresh_fun_app</span><span class="delimiter">)</span><span class="">
</span><span class="">      </span><span class="keyword1">with</span><span class=""> </span><span class="">a2</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="">d1</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;(atom b &#8652; atom a) &#8729; (h b) = (h b)&quot;</span><span class="">
</span><span class="">        </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">swap_fresh_fresh</span><span class="delimiter">)</span><span class="">
</span><span class="">      </span><span class="keyword1">from</span><span class=""> </span><span class="">a1</span><span class=""> </span><span class="">a3</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="">d2</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;(atom b &#8652; atom a) &#8729; h = h&quot;</span><span class="">
</span><span class="">        </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">swap_fresh_fresh</span><span class="delimiter">)</span><span class="">
</span><span class="">      </span><span class="keyword1">from</span><span class=""> </span><span class="">d1</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;h b = (atom b &#8652; atom a) &#8729; (h b)&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">      </span><span class="keyword1">also</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;&#8230; = ((atom b &#8652; atom a) &#8729; h) ((atom b &#8652; atom a) &#8729; b)&quot;</span><span class="">
</span><span class="">        </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">permute_fun_app_eq</span><span class="delimiter">)</span><span class="">
</span><span class="">      </span><span class="keyword1">also</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;&#8230; = h a&quot;</span><span class="">
</span><span class="">        </span><span class="keyword1">using</span><span class=""> </span><span class="">d2</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">      </span><span class="keyword1">finally</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;h a = h b&quot;</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">    </span><span class="keyword1">qed</span><span class="">
</span><span class="">  </span><span class="keyword1">qed</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">freshness_lemma_unique</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">fixes</span><span class=""> </span><span class="">h</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;&#39;a::at &#8658; &#39;b::pt&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="">a</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;&#8707;a. atom a &#9839; (h, h a)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;&#8707;!x. &#8704;a. atom a &#9839; h &#10230; h a = x&quot;</span><span class="">
</span><span class="keyword1">proof</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">ex_ex1I</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">from</span><span class=""> </span><span class="">a</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;&#8707;x. &#8704;a. atom a &#9839; h &#10230; h a = x&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">freshness_lemma</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1">next</span><span class="">
</span><span class="">  </span><span class="keyword3">fix</span><span class=""> </span><span class="">x</span><span class=""> </span><span class="">y</span><span class="">
</span><span class="">  </span><span class="keyword3">assume</span><span class=""> </span><span class="">x</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;&#8704;a. atom a &#9839; h &#10230; h a = x&quot;</span><span class="">
</span><span class="">  </span><span class="keyword3">assume</span><span class=""> </span><span class="">y</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;&#8704;a. atom a &#9839; h &#10230; h a = y&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">from</span><span class=""> </span><span class="">a</span><span class=""> </span><span class="">x</span><span class=""> </span><span class="">y</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;x = y&quot;</span><span class=""> 
</span><span class="">    </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class="delimiter">:</span><span class=""> </span><span class="">fresh_Pair</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="keyword1">text</span><span class=""> </span><span class="verbatim">{* packaging the freshness lemma into a function *}</span><span class="">
</span><span class="">
</span><span class="keyword1">definition</span><span class="">
</span><span class="">  </span><span class="">Fresh</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;(&#39;a::at &#8658; &#39;b::pt) &#8658; &#39;b&quot;</span><span class="">
</span><span class="keyword2">where</span><span class="">
</span><span class="">  </span><span class="string">&quot;Fresh h = (THE x. &#8704;a. atom a &#9839; h &#10230; h a = x)&quot;</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">Fresh_apply</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">fixes</span><span class=""> </span><span class="">h</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;&#39;a::at &#8658; &#39;b::pt&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="">a</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;&#8707;a. atom a &#9839; (h, h a)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="">b</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;atom a &#9839; h&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;Fresh h = h a&quot;</span><span class="">
</span><span class="keyword1">unfolding</span><span class=""> </span><span class="">Fresh_def</span><span class="">
</span><span class="keyword1">proof</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">the_equality</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;&#8704;a&#39;. atom a&#39; &#9839; h &#10230; h a&#39; = h a&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">proof</span><span class=""> </span><span class="delimiter">(</span><span class="">intro</span><span class=""> </span><span class="">strip</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword3">fix</span><span class=""> </span><span class="">a&#39;</span><span class="delimiter">::</span><span class=""> </span><span class="tfree">&#39;a</span><span class="">
</span><span class="">    </span><span class="keyword3">assume</span><span class=""> </span><span class="">c</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;atom a&#39; &#9839; h&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">from</span><span class=""> </span><span class="">a</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;&#8707;x. &#8704;a. atom a &#9839; h &#10230; h a = x&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">freshness_lemma</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1">with</span><span class=""> </span><span class="">b</span><span class=""> </span><span class="">c</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;h a&#39; = h a&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">  </span><span class="keyword1">qed</span><span class="">
</span><span class="keyword1">next</span><span class="">
</span><span class="">  </span><span class="keyword3">fix</span><span class=""> </span><span class="">fr</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="tfree">&#39;b</span><span class="">
</span><span class="">  </span><span class="keyword3">assume</span><span class=""> </span><span class="string">&quot;&#8704;a. atom a &#9839; h &#10230; h a = fr&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">with</span><span class=""> </span><span class="">b</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;fr = h a&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">Fresh_apply&#39;</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">fixes</span><span class=""> </span><span class="">h</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;&#39;a::at &#8658; &#39;b::pt&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="">a</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;atom a &#9839; h&quot;</span><span class=""> </span><span class="string">&quot;atom a &#9839; h a&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;Fresh h = h a&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">Fresh_apply</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class="delimiter">:</span><span class=""> </span><span class="">fresh_Pair</span><span class=""> </span><span class="">intro</span><span class="delimiter">:</span><span class=""> </span><span class="">a</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">done</span></span><span class="">
</span><span class="">
</span><span class="keyword1">simproc_setup</span><span class=""> </span><span class="">Fresh_simproc</span><span class=""> </span><span class="delimiter">(</span><span class="string">&quot;Fresh (h::&#39;a::at &#8658; &#39;b::pt)&quot;</span><span class="delimiter">)</span><span class=""> </span><span class="delimiter">=</span><span class=""> </span><span class="verbatim">{* fn _ =&gt; fn ctxt =&gt; fn ctrm =&gt;
  let
     val _ $ h = Thm.term_of ctrm

     val cfresh = @{const_name fresh}
     val catom  = @{const_name atom}

     val atoms = Simplifier.prems_of ctxt
      |&gt; map_filter (fn thm =&gt; case Thm.prop_of thm of                    
           _ $ (Const (cfresh, _) $ (Const (catom, _) $ atm) $ _) =&gt; SOME (atm) | _ =&gt; NONE)
      |&gt; distinct (op=)
     
     fun get_thm atm = 
       let
         val goal1 = HOLogic.mk_Trueprop (mk_fresh (mk_atom atm) h)
         val goal2 = HOLogic.mk_Trueprop (mk_fresh (mk_atom atm) (h $ atm))
 
         val thm1 = Goal.prove ctxt [] [] goal1 (K (asm_simp_tac ctxt 1)) 
         val thm2 = Goal.prove ctxt [] [] goal2 (K (asm_simp_tac ctxt 1)) 
       in
         SOME (@{thm Fresh_apply&#39;} OF [thm1, thm2] RS eq_reflection)
       end handle ERROR _ =&gt; NONE
  in
    get_first get_thm atoms
  end
*}</span><span class="">
</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">Fresh_eqvt</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">fixes</span><span class=""> </span><span class="">h</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;&#39;a::at &#8658; &#39;b::pt&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="">a</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;&#8707;a. atom a &#9839; (h, h a)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;p &#8729; (Fresh h) = Fresh (p &#8729; h)&quot;</span><span class="">
</span><span class="keyword1">proof</span><span class=""> </span><span class="">-</span><span class="">
</span><span class="">  </span><span class="keyword1">from</span><span class=""> </span><span class="">a</span><span class=""> </span><span class="keyword3">obtain</span><span class=""> </span><span class="">a</span><span class="delimiter">::</span><span class="string">&quot;&#39;a::at&quot;</span><span class=""> </span><span class="keyword2">where</span><span class=""> </span><span class="">fr</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;atom a &#9839; h&quot;</span><span class=""> </span><span class="string">&quot;atom a &#9839; h a&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">metis</span><span class=""> </span><span class="">fresh_Pair</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">then</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="">fr_p</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;atom (p &#8729; a) &#9839; (p &#8729; h)&quot;</span><span class=""> </span><span class="string">&quot;atom (p &#8729; a) &#9839; (p &#8729; h) (p &#8729; a)&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">metis</span><span class=""> </span><span class="">atom_eqvt</span><span class=""> </span><span class="">fresh_permute_iff</span><span class=""> </span><span class="">eqvt_apply</span><span class="delimiter">)</span><span class="delimiter">+</span><span class="">
</span><span class="">  </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;p &#8729; (Fresh h) = p &#8729; (h a)&quot;</span><span class=""> </span><span class="keyword1">using</span><span class=""> </span><span class="">fr</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">  </span><span class="keyword1">also</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;... = (p &#8729; h) (p &#8729; a)&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">  </span><span class="keyword1">also</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;... = Fresh (p &#8729; h)&quot;</span><span class=""> </span><span class="keyword1">using</span><span class=""> </span><span class="">fr_p</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">  </span><span class="keyword1">finally</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;p &#8729; (Fresh h) = Fresh (p &#8729; h)&quot;</span><span class=""> </span><span class="keyword1">.</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">Fresh_supports</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">fixes</span><span class=""> </span><span class="">h</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;&#39;a::at &#8658; &#39;b::pt&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="">a</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;&#8707;a. atom a &#9839; (h, h a)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;(supp h) supports (Fresh h)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">supports_def</span><span class=""> </span><span class="">fresh_def</span><span class=""> </span><span class="delimiter">[</span><span class="">symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">Fresh_eqvt</span><span class=""> </span><span class="delimiter">[</span><span class="">OF</span><span class=""> </span><span class="">a</span><span class="delimiter">]</span><span class=""> </span><span class="">swap_fresh_fresh</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">done</span></span><span class="">
</span><span class="">
</span><span class="keyword1">notation</span><span class=""> </span><span class="">Fresh</span><span class=""> </span><span class="delimiter">(</span><span class="keyword2">binder</span><span class=""> </span><span class="string">&quot;FRESH &quot;</span><span class=""> </span><span class="">10</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">FRESH_f_iff</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">fixes</span><span class=""> </span><span class="">P</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;&#39;a::at &#8658; &#39;b::pure&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">fixes</span><span class=""> </span><span class="">f</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;&#39;b &#8658; &#39;c::pure&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="">P</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;finite (supp P)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;(FRESH x. f (P x)) = f (FRESH x. P x)&quot;</span><span class="">
</span><span class="keyword1">proof</span><span class=""> </span><span class="">-</span><span class="">
</span><span class="">  </span><span class="keyword3">obtain</span><span class=""> </span><span class="">a</span><span class="delimiter">::</span><span class="tfree">&#39;a</span><span class=""> </span><span class="keyword2">where</span><span class=""> </span><span class="string">&quot;atom a &#9839; P&quot;</span><span class=""> </span><span class="keyword1">using</span><span class=""> </span><span class="">P</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">obtain_fresh&#39;</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">then</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="string">&quot;(FRESH x. f (P x)) = f (FRESH x. P x)&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">pure_fresh</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">FRESH_binop_iff</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">fixes</span><span class=""> </span><span class="">P</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;&#39;a::at &#8658; &#39;b::pure&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">fixes</span><span class=""> </span><span class="">Q</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;&#39;a::at &#8658; &#39;c::pure&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">fixes</span><span class=""> </span><span class="">binop</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;&#39;b &#8658; &#39;c &#8658; &#39;d::pure&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="">P</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;finite (supp P)&quot;</span><span class=""> 
</span><span class="">  </span><span class="keyword2">and</span><span class="">     </span><span class="">Q</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;finite (supp Q)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;(FRESH x. binop (P x) (Q x)) = binop (FRESH x. P x) (FRESH x. Q x)&quot;</span><span class="">
</span><span class="keyword1">proof</span><span class=""> </span><span class="">-</span><span class="">
</span><span class="">  </span><span class="keyword1">from</span><span class=""> </span><span class="">assms</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;finite (supp (P, Q))&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">supp_Pair</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">then</span><span class=""> </span><span class="keyword3">obtain</span><span class=""> </span><span class="">a</span><span class="delimiter">::</span><span class="tfree">&#39;a</span><span class=""> </span><span class="keyword2">where</span><span class=""> </span><span class="string">&quot;atom a &#9839; (P, Q)&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">obtain_fresh&#39;</span><span class="delimiter">)</span><span class=""> 
</span><span class="">  </span><span class="keyword1">then</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="var">?thesis</span><span class="">
</span><span class="">    </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">pure_fresh</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">FRESH_conj_iff</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">fixes</span><span class=""> </span><span class="">P</span><span class=""> </span><span class="">Q</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;&#39;a::at &#8658; bool&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="">P</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;finite (supp P)&quot;</span><span class=""> </span><span class="keyword2">and</span><span class=""> </span><span class="">Q</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;finite (supp Q)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;(FRESH x. P x &#8743; Q x) &#10231; (FRESH x. P x) &#8743; (FRESH x. Q x)&quot;</span><span class="">
</span><span class="keyword1">using</span><span class=""> </span><span class="">P</span><span class=""> </span><span class="">Q</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">FRESH_binop_iff</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">FRESH_disj_iff</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">fixes</span><span class=""> </span><span class="">P</span><span class=""> </span><span class="">Q</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;&#39;a::at &#8658; bool&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="">P</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;finite (supp P)&quot;</span><span class=""> </span><span class="keyword2">and</span><span class=""> </span><span class="">Q</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;finite (supp Q)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;(FRESH x. P x &#8744; Q x) &#10231; (FRESH x. P x) &#8744; (FRESH x. Q x)&quot;</span><span class="">
</span><span class="keyword1">using</span><span class=""> </span><span class="">P</span><span class=""> </span><span class="">Q</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">FRESH_binop_iff</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="">
</span><span class="keyword1">section</span><span class=""> </span><span class="verbatim">{* Automation for creating concrete atom types *}</span><span class="">
</span><span class="">
</span><span class="keyword1">text</span><span class=""> </span><span class="verbatim">{* At the moment only single-sort concrete atoms are supported. *}</span><span class="">
</span><span class="">
</span><span class="keyword1">ML_file</span><span class=""> </span><span class="string">&quot;nominal_atoms.ML&quot;</span><span class="">
</span><span class="">
</span><span class="">
</span><span class="keyword1">section</span><span class=""> </span><span class="verbatim">{* Automatic equivariance procedure for inductive definitions *}</span><span class="">
</span><span class="">
</span><span class="keyword1">ML_file</span><span class=""> </span><span class="string">&quot;nominal_eqvt.ML&quot;</span><span class="">
</span><span class="">
</span><span class="keyword2">end</span><span class="">
</span></pre>

</div>
</body>
</html>
