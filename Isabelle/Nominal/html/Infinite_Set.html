<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>Theory Infinite_Set (Isabelle2016: February 2016)</title>
<link media="all" rel="stylesheet" type="text/css" href="isabelle.css"/>
</head>

<body>
<div class="head"><h1>Theory Infinite_Set</h1>

<span class="command">theory</span> <span class="name">Infinite_Set</span><br/>
<span class="keyword">imports</span> <a href="../../HOL/HOL/Main.html"><span class="name">Main</span></a><br/>

</div>
<div class="source">
<pre class="source"><span class="comment">(*  Title:      HOL/Library/Infinite_Set.thy
    Author:     Stephan Merz
*)</span><span class="">
</span><span class="">
</span><span class="keyword1">section</span><span class=""> </span><span class="cartouche">&#8249;Infinite Sets and Related Concepts&#8250;</span><span class="">
</span><span class="">
</span><span class="keyword1">theory</span><span class=""> </span><span class="">Infinite_Set</span><span class="">
</span><span class="keyword2">imports</span><span class=""> </span><span class="">Main</span><span class="">
</span><span class="keyword2">begin</span><span class="">
</span><span class="">
</span><span class="keyword1">text</span><span class=""> </span><span class="cartouche">&#8249;The set of natural numbers is infinite.&#8250;</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">infinite_nat_iff_unbounded_le</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;infinite (S::nat set) &#10231; (&#8704;m. &#8707;n&#8805;m. n &#8712; S)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">using</span><span class=""> </span><span class="">frequently_cofinite</span><span class="delimiter">[</span><span class="">of</span><span class=""> </span><span class="string">&quot;&#955;x. x &#8712; S&quot;</span><span class="delimiter">]</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">cofinite_eq_sequentially</span><span class=""> </span><span class="">frequently_def</span><span class=""> </span><span class="">eventually_sequentially</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">infinite_nat_iff_unbounded</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;infinite (S::nat set) &#10231; (&#8704;m. &#8707;n&gt;m. n &#8712; S)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">using</span><span class=""> </span><span class="">frequently_cofinite</span><span class="delimiter">[</span><span class="">of</span><span class=""> </span><span class="string">&quot;&#955;x. x &#8712; S&quot;</span><span class="delimiter">]</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">cofinite_eq_sequentially</span><span class=""> </span><span class="">frequently_def</span><span class=""> </span><span class="">eventually_at_top_dense</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">finite_nat_iff_bounded</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;finite (S::nat set) &#10231; (&#8707;k. S &#8838; {..&lt;k})&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">using</span><span class=""> </span><span class="">infinite_nat_iff_unbounded_le</span><span class="delimiter">[</span><span class="">of</span><span class=""> </span><span class="">S</span><span class="delimiter">]</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">subset_eq</span><span class="delimiter">)</span><span class=""> </span><span class="delimiter">(</span><span class="">metis</span><span class=""> </span><span class="">not_le</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">finite_nat_iff_bounded_le</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;finite (S::nat set) &#10231; (&#8707;k. S &#8838; {.. k})&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">using</span><span class=""> </span><span class="">infinite_nat_iff_unbounded</span><span class="delimiter">[</span><span class="">of</span><span class=""> </span><span class="">S</span><span class="delimiter">]</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">subset_eq</span><span class="delimiter">)</span><span class=""> </span><span class="delimiter">(</span><span class="">metis</span><span class=""> </span><span class="">not_le</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">finite_nat_bounded</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;finite (S::nat set) &#10233; &#8707;k. S &#8838; {..&lt;k}&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">finite_nat_iff_bounded</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="">
</span><span class="keyword1">text</span><span class=""> </span><span class="cartouche">&#8249;
  For a set of natural numbers to be infinite, it is enough to know
  that for any number larger than some &#8249;k&#8250;, there is some larger
  number that is an element of the set.
&#8250;</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">unbounded_k_infinite</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;&#8704;m&gt;k. &#8707;n&gt;m. n &#8712; S &#10233; infinite (S::nat set)&quot;</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">clarsimp</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">finite_nat_set_iff_bounded</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">drule_tac</span><span class=""> </span><span class="">x</span><span class="delimiter">=</span><span class="string">&quot;Suc (max m k)&quot;</span><span class=""> </span><span class="keyword2">in</span><span class=""> </span><span class="">spec</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1">using</span><span class=""> </span><span class="">less_Suc_eq</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">fastforce</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">nat_not_finite</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;finite (UNIV::nat set) &#10233; R&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">range_inj_infinite</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="string">&quot;inj (f::nat &#8658; &#39;a) &#10233; infinite (range f)&quot;</span><span class="">
</span><span class="keyword1">proof</span><span class="">
</span><span class="">  </span><span class="keyword3">assume</span><span class=""> </span><span class="string">&quot;finite (range f)&quot;</span><span class=""> </span><span class="keyword2">and</span><span class=""> </span><span class="string">&quot;inj f&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">then</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;finite (UNIV::nat set)&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">finite_imageD</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">then</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="">False</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="keyword1">text</span><span class=""> </span><span class="cartouche">&#8249;The set of integers is also infinite.&#8250;</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">infinite_int_iff_infinite_nat_abs</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;infinite (S::int set) &#10231; infinite ((nat o abs) ` S)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class="delimiter">:</span><span class=""> </span><span class="">transfer_nat_int_set_relations</span><span class=""> </span><span class="">o_def</span><span class=""> </span><span class="">image_comp</span><span class=""> </span><span class="">dest</span><span class="delimiter">:</span><span class=""> </span><span class="">finite_image_absD</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">proposition</span><span class=""> </span><span class="">infinite_int_iff_unbounded_le</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;infinite (S::int set) &#10231; (&#8704;m. &#8707;n. &#166;n&#166; &#8805; m &#8743; n &#8712; S)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">infinite_int_iff_infinite_nat_abs</span><span class=""> </span><span class="">infinite_nat_iff_unbounded_le</span><span class=""> </span><span class="">o_def</span><span class=""> </span><span class="">image_def</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">metis</span><span class=""> </span><span class="">abs_ge_zero</span><span class=""> </span><span class="">nat_le_eq_zle</span><span class=""> </span><span class="">le_nat_iff</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">done</span></span><span class="">
</span><span class="">
</span><span class="keyword1">proposition</span><span class=""> </span><span class="">infinite_int_iff_unbounded</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;infinite (S::int set) &#10231; (&#8704;m. &#8707;n. &#166;n&#166; &gt; m &#8743; n &#8712; S)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">infinite_int_iff_infinite_nat_abs</span><span class=""> </span><span class="">infinite_nat_iff_unbounded</span><span class=""> </span><span class="">o_def</span><span class=""> </span><span class="">image_def</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">metis</span><span class=""> </span><span class="delimiter">(</span><span class="">full_types</span><span class="delimiter">)</span><span class=""> </span><span class="">nat_le_iff</span><span class=""> </span><span class="">nat_mono</span><span class=""> </span><span class="">not_le</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">done</span></span><span class="">
</span><span class="">
</span><span class="keyword1">proposition</span><span class=""> </span><span class="">finite_int_iff_bounded</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;finite (S::int set) &#10231; (&#8707;k. abs ` S &#8838; {..&lt;k})&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">using</span><span class=""> </span><span class="">infinite_int_iff_unbounded_le</span><span class="delimiter">[</span><span class="">of</span><span class=""> </span><span class="">S</span><span class="delimiter">]</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">subset_eq</span><span class="delimiter">)</span><span class=""> </span><span class="delimiter">(</span><span class="">metis</span><span class=""> </span><span class="">not_le</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">proposition</span><span class=""> </span><span class="">finite_int_iff_bounded_le</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;finite (S::int set) &#10231; (&#8707;k. abs ` S &#8838; {.. k})&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">using</span><span class=""> </span><span class="">infinite_int_iff_unbounded</span><span class="delimiter">[</span><span class="">of</span><span class=""> </span><span class="">S</span><span class="delimiter">]</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">subset_eq</span><span class="delimiter">)</span><span class=""> </span><span class="delimiter">(</span><span class="">metis</span><span class=""> </span><span class="">not_le</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">subsection</span><span class=""> </span><span class="string">&quot;Infinitely Many and Almost All&quot;</span><span class="">
</span><span class="">
</span><span class="keyword1">text</span><span class=""> </span><span class="cartouche">&#8249;
  We often need to reason about the existence of infinitely many
  (resp., all but finitely many) objects satisfying some predicate, so
  we introduce corresponding binders and their proof rules.
&#8250;</span><span class="">
</span><span class="">
</span><span class="comment">(* The following two lemmas are available as filter-rules, but not in the simp-set *)</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">not_INFM</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;&#172; (INFM x. P x) &#10231; (MOST x. &#172; P x)&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">fact</span><span class=""> </span><span class="">not_frequently</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">not_MOST</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;&#172; (MOST x. P x) &#10231; (INFM x. &#172; P x)&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">fact</span><span class=""> </span><span class="">not_eventually</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">INFM_const</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;(INFM x::&#39;a. P) &#10231; P &#8743; infinite (UNIV::&#39;a set)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">frequently_const_iff</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">MOST_const</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;(MOST x::&#39;a. P) &#10231; P &#8744; finite (UNIV::&#39;a set)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">eventually_const_iff</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">INFM_imp_distrib</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;(INFM x. P x &#10230; Q x) &#10231; ((MOST x. P x) &#10230; (INFM x. Q x))&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">only</span><span class="delimiter">:</span><span class=""> </span><span class="">imp_conv_disj</span><span class=""> </span><span class="">frequently_disj_iff</span><span class=""> </span><span class="">not_eventually</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">MOST_imp_iff</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;MOST x. P x &#10233; (MOST x. P x &#10230; Q x) &#10231; (MOST x. Q x)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">intro</span><span class="delimiter">:</span><span class=""> </span><span class="">eventually_rev_mp</span><span class=""> </span><span class="">eventually_mono</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">INFM_conjI</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;INFM x. P x &#10233; MOST x. Q x &#10233; INFM x. P x &#8743; Q x&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">frequently_rev_mp</span><span class="delimiter">[</span><span class="">of</span><span class=""> </span><span class="">P</span><span class="delimiter">]</span><span class="delimiter">)</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">elim</span><span class="delimiter">:</span><span class=""> </span><span class="">eventually_mono</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">text</span><span class=""> </span><span class="cartouche">&#8249;Properties of quantifiers with injective functions.&#8250;</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">INFM_inj</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;INFM x. P (f x) &#10233; inj f &#10233; INFM x. P x&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">using</span><span class=""> </span><span class="">finite_vimageI</span><span class="delimiter">[</span><span class="">of</span><span class=""> </span><span class="string">&quot;{x. P x}&quot;</span><span class=""> </span><span class="">f</span><span class="delimiter">]</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class="delimiter">:</span><span class=""> </span><span class="">frequently_cofinite</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">MOST_inj</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;MOST x. P x &#10233; inj f &#10233; MOST x. P (f x)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">using</span><span class=""> </span><span class="">finite_vimageI</span><span class="delimiter">[</span><span class="">of</span><span class=""> </span><span class="string">&quot;{x. &#172; P x}&quot;</span><span class=""> </span><span class="">f</span><span class="delimiter">]</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class="delimiter">:</span><span class=""> </span><span class="">eventually_cofinite</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">text</span><span class=""> </span><span class="cartouche">&#8249;Properties of quantifiers with singletons.&#8250;</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">not_INFM_eq</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="string">&quot;&#172; (INFM x. x = a)&quot;</span><span class="">
</span><span class="">  </span><span class="string">&quot;&#172; (INFM x. a = x)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">frequently_cofinite</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp_all</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">MOST_neq</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="string">&quot;MOST x. x &#8800; a&quot;</span><span class="">
</span><span class="">  </span><span class="string">&quot;MOST x. a &#8800; x&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">eventually_cofinite</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp_all</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">INFM_neq</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="string">&quot;(INFM x::&#39;a. x &#8800; a) &#10231; infinite (UNIV::&#39;a set)&quot;</span><span class="">
</span><span class="">  </span><span class="string">&quot;(INFM x::&#39;a. a &#8800; x) &#10231; infinite (UNIV::&#39;a set)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">frequently_cofinite</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp_all</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">MOST_eq</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="string">&quot;(MOST x::&#39;a. x = a) &#10231; finite (UNIV::&#39;a set)&quot;</span><span class="">
</span><span class="">  </span><span class="string">&quot;(MOST x::&#39;a. a = x) &#10231; finite (UNIV::&#39;a set)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">eventually_cofinite</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp_all</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">MOST_eq_imp</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="string">&quot;MOST x. x = a &#10230; P x&quot;</span><span class="">
</span><span class="">  </span><span class="string">&quot;MOST x. a = x &#10230; P x&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">eventually_cofinite</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp_all</span><span class="">
</span><span class="">
</span><span class="keyword1">text</span><span class=""> </span><span class="cartouche">&#8249;Properties of quantifiers over the naturals.&#8250;</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">MOST_nat</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;(&#8704;<span class="hidden">&#8681;</span><sub>&#8734;</sub>n. P (n::nat)) &#10231; (&#8707;m. &#8704;n&gt;m. P n)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">eventually_cofinite</span><span class=""> </span><span class="">finite_nat_iff_bounded_le</span><span class=""> </span><span class="">subset_eq</span><span class=""> </span><span class="">not_le</span><span class="delimiter">[</span><span class="">symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">MOST_nat_le</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;(&#8704;<span class="hidden">&#8681;</span><sub>&#8734;</sub>n. P (n::nat)) &#10231; (&#8707;m. &#8704;n&#8805;m. P n)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">eventually_cofinite</span><span class=""> </span><span class="">finite_nat_iff_bounded</span><span class=""> </span><span class="">subset_eq</span><span class=""> </span><span class="">not_le</span><span class="delimiter">[</span><span class="">symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">INFM_nat</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;(&#8707;<span class="hidden">&#8681;</span><sub>&#8734;</sub>n. P (n::nat)) &#10231; (&#8704;m. &#8707;n&gt;m. P n)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">frequently_cofinite</span><span class=""> </span><span class="">infinite_nat_iff_unbounded</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">INFM_nat_le</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;(&#8707;<span class="hidden">&#8681;</span><sub>&#8734;</sub>n. P (n::nat)) &#10231; (&#8704;m. &#8707;n&#8805;m. P n)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">frequently_cofinite</span><span class=""> </span><span class="">infinite_nat_iff_unbounded_le</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">MOST_INFM</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;infinite (UNIV::&#39;a set) &#10233; MOST x::&#39;a. P x &#10233; INFM x::&#39;a. P x&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">eventually_frequently</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">MOST_Suc_iff</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;(MOST n. P (Suc n)) &#10231; (MOST n. P n)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">cofinite_eq_sequentially</span><span class=""> </span><span class="">eventually_sequentially_Suc</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="">MOST_SucI</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;MOST n. P n &#10233; MOST n. P (Suc n)&quot;</span><span class="">
</span><span class="">    </span><span class="keyword2">and</span><span class=""> </span><span class="">MOST_SucD</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;MOST n. P (Suc n) &#10233; MOST n. P n&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp_all</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">MOST_Suc_iff</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">MOST_ge_nat</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;MOST n::nat. m &#8804; n&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">cofinite_eq_sequentially</span><span class=""> </span><span class="">eventually_ge_at_top</span><span class="delimiter">)</span><span class="">
</span><span class="">
</span><span class="comment">(* legacy names *)</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">Inf_many_def</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;Inf_many P &#10231; infinite {x. P x}&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">fact</span><span class=""> </span><span class="">frequently_cofinite</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">Alm_all_def</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;Alm_all P &#10231; &#172; (INFM x. &#172; P x)&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">INFM_iff_infinite</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;(INFM x. P x) &#10231; infinite {x. P x}&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">fact</span><span class=""> </span><span class="">frequently_cofinite</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">MOST_iff_cofinite</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;(MOST x. P x) &#10231; finite {x. &#172; P x}&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">fact</span><span class=""> </span><span class="">eventually_cofinite</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">INFM_EX</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;(&#8707;<span class="hidden">&#8681;</span><sub>&#8734;</sub>x. P x) &#10233; (&#8707;x. P x)&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">fact</span><span class=""> </span><span class="">frequently_ex</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">ALL_MOST</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;&#8704;x. P x &#10233; &#8704;<span class="hidden">&#8681;</span><sub>&#8734;</sub>x. P x&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">fact</span><span class=""> </span><span class="">always_eventually</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">INFM_mono</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;&#8707;<span class="hidden">&#8681;</span><sub>&#8734;</sub>x. P x &#10233; (&#8896;x. P x &#10233; Q x) &#10233; &#8707;<span class="hidden">&#8681;</span><sub>&#8734;</sub>x. Q x&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">fact</span><span class=""> </span><span class="">frequently_elim1</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">MOST_mono</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;&#8704;<span class="hidden">&#8681;</span><sub>&#8734;</sub>x. P x &#10233; (&#8896;x. P x &#10233; Q x) &#10233; &#8704;<span class="hidden">&#8681;</span><sub>&#8734;</sub>x. Q x&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">fact</span><span class=""> </span><span class="">eventually_mono</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">INFM_disj_distrib</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;(&#8707;<span class="hidden">&#8681;</span><sub>&#8734;</sub>x. P x &#8744; Q x) &#10231; (&#8707;<span class="hidden">&#8681;</span><sub>&#8734;</sub>x. P x) &#8744; (&#8707;<span class="hidden">&#8681;</span><sub>&#8734;</sub>x. Q x)&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">fact</span><span class=""> </span><span class="">frequently_disj_iff</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">MOST_rev_mp</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;&#8704;<span class="hidden">&#8681;</span><sub>&#8734;</sub>x. P x &#10233; &#8704;<span class="hidden">&#8681;</span><sub>&#8734;</sub>x. P x &#10230; Q x &#10233; &#8704;<span class="hidden">&#8681;</span><sub>&#8734;</sub>x. Q x&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">fact</span><span class=""> </span><span class="">eventually_rev_mp</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">MOST_conj_distrib</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;(&#8704;<span class="hidden">&#8681;</span><sub>&#8734;</sub>x. P x &#8743; Q x) &#10231; (&#8704;<span class="hidden">&#8681;</span><sub>&#8734;</sub>x. P x) &#8743; (&#8704;<span class="hidden">&#8681;</span><sub>&#8734;</sub>x. Q x)&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">fact</span><span class=""> </span><span class="">eventually_conj_iff</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">MOST_conjI</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;MOST x. P x &#10233; MOST x. Q x &#10233; MOST x. P x &#8743; Q x&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">fact</span><span class=""> </span><span class="">eventually_conj</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">INFM_finite_Bex_distrib</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;finite A &#10233; (INFM y. &#8707;x&#8712;A. P x y) &#10231; (&#8707;x&#8712;A. INFM y. P x y)&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">fact</span><span class=""> </span><span class="">frequently_bex_finite_distrib</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">MOST_finite_Ball_distrib</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;finite A &#10233; (MOST y. &#8704;x&#8712;A. P x y) &#10231; (&#8704;x&#8712;A. MOST y. P x y)&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">fact</span><span class=""> </span><span class="">eventually_ball_finite_distrib</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">INFM_E</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;INFM x. P x &#10233; (&#8896;x. P x &#10233; thesis) &#10233; thesis&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">fact</span><span class=""> </span><span class="">frequentlyE</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">MOST_I</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;(&#8896;x. P x) &#10233; MOST x. P x&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">eventuallyI</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1">lemmas</span><span class=""> </span><span class="">MOST_iff_finiteNeg</span><span class=""> </span><span class="delimiter">=</span><span class=""> </span><span class="">MOST_iff_cofinite</span><span class="">
</span><span class="">
</span><span class="keyword1">subsection</span><span class=""> </span><span class="string">&quot;Enumeration of an Infinite Set&quot;</span><span class="">
</span><span class="">
</span><span class="keyword1">text</span><span class=""> </span><span class="cartouche">&#8249;
  The set&#39;s element type must be wellordered (e.g. the natural numbers).
&#8250;</span><span class="">
</span><span class="">
</span><span class="keyword1">text</span><span class=""> </span><span class="cartouche">&#8249;
  Could be generalized to
    @{term &quot;enumerate&#39; S n = (SOME t. t &#8712; s &#8743; finite {s&#8712;S. s &lt; t} &#8743; card {s&#8712;S. s &lt; t} = n)&quot;}.
&#8250;</span><span class="">
</span><span class="">
</span><span class="keyword1">primrec</span><span class=""> </span><span class="delimiter">(</span><span class="keyword2">in</span><span class=""> </span><span class="">wellorder</span><span class="delimiter">)</span><span class=""> </span><span class="">enumerate</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;&#39;a set &#8658; nat &#8658; &#39;a&quot;</span><span class="">
</span><span class="keyword2">where</span><span class="">
</span><span class="">  </span><span class="">enumerate_0</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;enumerate S 0 = (LEAST n. n &#8712; S)&quot;</span><span class="">
</span><span class="delimiter">|</span><span class=""> </span><span class="">enumerate_Suc</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;enumerate S (Suc n) = enumerate (S - {LEAST n. n &#8712; S}) n&quot;</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">enumerate_Suc&#39;</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;enumerate S (Suc n) = enumerate (S - {enumerate S 0}) n&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">enumerate_in_set</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;infinite S &#10233; enumerate S n &#8712; S&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">n</span><span class=""> </span><span class="">arbitrary</span><span class="delimiter">:</span><span class=""> </span><span class="">S</span><span class="delimiter">)</span><span class="">
</span><span class="">   </span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">fastforce</span><span class=""> </span><span class="">intro</span><span class="delimiter">:</span><span class=""> </span><span class="">LeastI</span><span class=""> </span><span class="">dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span class=""> </span><span class="">infinite_imp_nonempty</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">metis</span><span class=""> </span><span class="">DiffE</span><span class=""> </span><span class="">infinite_remove</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">done</span></span><span class="">
</span><span class="">
</span><span class="keyword1">declare</span><span class=""> </span><span class="">enumerate_0</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class=""> </span><span class="">del</span><span class="delimiter">]</span><span class=""> </span><span class="">enumerate_Suc</span><span class=""> </span><span class="delimiter">[</span><span class="">simp</span><span class=""> </span><span class="">del</span><span class="delimiter">]</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">enumerate_step</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;infinite S &#10233; enumerate S n &lt; enumerate S (Suc n)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">n</span><span class=""> </span><span class="">arbitrary</span><span class="delimiter">:</span><span class=""> </span><span class="">S</span><span class="delimiter">)</span><span class="">
</span><span class="">   </span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">rule</span><span class=""> </span><span class="">order_le_neq_trans</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">enumerate_0</span><span class=""> </span><span class="">Least_le</span><span class=""> </span><span class="">enumerate_in_set</span><span class="delimiter">)</span><span class="">
</span><span class="">   </span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">only</span><span class="delimiter">:</span><span class=""> </span><span class="">enumerate_Suc&#39;</span><span class="delimiter">)</span><span class="">
</span><span class="">   </span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">subgoal_tac</span><span class=""> </span><span class="string">&quot;enumerate (S - {enumerate S 0}) 0 &#8712; S - {enumerate S 0}&quot;</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">blast</span><span class=""> </span><span class="">intro</span><span class="delimiter">:</span><span class=""> </span><span class="">sym</span><span class="delimiter">)</span><span class="">
</span><span class="">   </span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">enumerate_in_set</span><span class=""> </span><span class="">del</span><span class="delimiter">:</span><span class=""> </span><span class="">Diff_iff</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">simp</span><span class=""> </span><span class="">add</span><span class="delimiter">:</span><span class=""> </span><span class="">enumerate_Suc&#39;</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">done</span></span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">enumerate_mono</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;m &lt; n &#10233; infinite S &#10233; enumerate S m &lt; enumerate S n&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">erule</span><span class=""> </span><span class="">less_Suc_induct</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">intro</span><span class="delimiter">:</span><span class=""> </span><span class="">enumerate_step</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1"><span class="improper">done</span></span><span class="">
</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">le_enumerate</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="">S</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;infinite S&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;n &#8804; enumerate S n&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">using</span><span class=""> </span><span class="">S</span><span class="">
</span><span class="keyword1">proof</span><span class=""> </span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">n</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword3">case</span><span class=""> </span><span class="">0</span><span class="">
</span><span class="">  </span><span class="keyword1">then</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="var">?case</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="keyword1">next</span><span class="">
</span><span class="">  </span><span class="keyword3">case</span><span class=""> </span><span class="delimiter">(</span><span class="">Suc</span><span class=""> </span><span class="">n</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">then</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;n &#8804; enumerate S n&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">  </span><span class="keyword1">also</span><span class=""> </span><span class="keyword1">note</span><span class=""> </span><span class="">enumerate_mono</span><span class="delimiter">[</span><span class="">of</span><span class=""> </span><span class="">n</span><span class=""> </span><span class="string">&quot;Suc n&quot;</span><span class="delimiter">,</span><span class=""> </span><span class="">OF</span><span class=""> </span><span class="">_</span><span class=""> </span><span class="cartouche">&#8249;infinite S&#8250;</span><span class="delimiter">]</span><span class="">
</span><span class="">  </span><span class="keyword1">finally</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="var">?case</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">enumerate_Suc&#39;&#39;</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">fixes</span><span class=""> </span><span class="">S</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;&#39;a::wellorder set&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="string">&quot;infinite S&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;enumerate S (Suc n) = (LEAST s. s &#8712; S &#8743; enumerate S n &lt; s)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword1">using</span><span class=""> </span><span class="">assms</span><span class="">
</span><span class="keyword1">proof</span><span class=""> </span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">n</span><span class=""> </span><span class="">arbitrary</span><span class="delimiter">:</span><span class=""> </span><span class="">S</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword3">case</span><span class=""> </span><span class="">0</span><span class="">
</span><span class="">  </span><span class="keyword1">then</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;&#8704;s &#8712; S. enumerate S 0 &#8804; s&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class="delimiter">:</span><span class=""> </span><span class="">enumerate.simps</span><span class=""> </span><span class="">intro</span><span class="delimiter">:</span><span class=""> </span><span class="">Least_le</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">then</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="var">?case</span><span class="">
</span><span class="">    </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">enumerate_Suc&#39;</span><span class=""> </span><span class="">enumerate_0</span><span class="delimiter">[</span><span class="">of</span><span class=""> </span><span class="string">&quot;S - {enumerate S 0}&quot;</span><span class="delimiter">]</span><span class="">
</span><span class="">    </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">intro</span><span class=""> </span><span class="">arg_cong</span><span class="delimiter">[</span><span class="keyword2">where</span><span class=""> </span><span class="">f</span><span class=""> </span><span class="delimiter">=</span><span class=""> </span><span class="">Least</span><span class="delimiter">]</span><span class=""> </span><span class="">ext</span><span class="delimiter">)</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="keyword1">next</span><span class="">
</span><span class="">  </span><span class="keyword3">case</span><span class=""> </span><span class="delimiter">(</span><span class="">Suc</span><span class=""> </span><span class="">n</span><span class=""> </span><span class="">S</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword3">show</span><span class=""> </span><span class="var">?case</span><span class="">
</span><span class="">    </span><span class="keyword1">using</span><span class=""> </span><span class="">enumerate_mono</span><span class="delimiter">[</span><span class="">OF</span><span class=""> </span><span class="">zero_less_Suc</span><span class=""> </span><span class="cartouche">&#8249;infinite S&#8250;</span><span class="delimiter">,</span><span class=""> </span><span class="">of</span><span class=""> </span><span class="">n</span><span class="delimiter">]</span><span class=""> </span><span class="cartouche">&#8249;infinite S&#8250;</span><span class="">
</span><span class="">    </span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">subst</span><span class=""> </span><span class="delimiter">(</span><span class="">1</span><span class=""> </span><span class="">2</span><span class="delimiter">)</span><span class=""> </span><span class="">enumerate_Suc&#39;</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">subst</span><span class=""> </span><span class="">Suc</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1">using</span><span class=""> </span><span class="cartouche">&#8249;infinite S&#8250;</span><span class="">
</span><span class="">    </span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="">simp</span><span class="">
</span><span class="">    </span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">intro</span><span class=""> </span><span class="">arg_cong</span><span class="delimiter">[</span><span class="keyword2">where</span><span class=""> </span><span class="">f</span><span class=""> </span><span class="delimiter">=</span><span class=""> </span><span class="">Least</span><span class="delimiter">]</span><span class=""> </span><span class="">ext</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1"><span class="improper">apply</span></span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class="delimiter">:</span><span class=""> </span><span class="">enumerate_Suc&#39;</span><span class="delimiter">[</span><span class="">symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1"><span class="improper">done</span></span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">enumerate_Ex</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="">S</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;infinite (S::nat set)&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;s &#8712; S &#10233; &#8707;n. enumerate S n = s&quot;</span><span class="">
</span><span class="keyword1">proof</span><span class=""> </span><span class="delimiter">(</span><span class="">induct</span><span class=""> </span><span class="">s</span><span class=""> </span><span class="">rule</span><span class="delimiter">:</span><span class=""> </span><span class="">less_induct</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword3">case</span><span class=""> </span><span class="delimiter">(</span><span class="">less</span><span class=""> </span><span class="">s</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword3">show</span><span class=""> </span><span class="var">?case</span><span class="">
</span><span class="">  </span><span class="keyword1">proof</span><span class=""> </span><span class="">cases</span><span class="">
</span><span class="">    </span><span class="keyword1">let</span><span class=""> </span><span class="var">?y</span><span class=""> </span><span class="delimiter">=</span><span class=""> </span><span class="string">&quot;Max {s&#39;&#8712;S. s&#39; &lt; s}&quot;</span><span class="">
</span><span class="">    </span><span class="keyword3">assume</span><span class=""> </span><span class="string">&quot;&#8707;y&#8712;S. y &lt; s&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">then</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="">y</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;&#8896;x. ?y &lt; x &#10231; (&#8704;s&#39;&#8712;S. s&#39; &lt; s &#10230; s&#39; &lt; x)&quot;</span><span class="">
</span><span class="">      </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">subst</span><span class=""> </span><span class="">Max_less_iff</span><span class="delimiter">)</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">    </span><span class="keyword1">then</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="">y_in</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;?y &#8712; {s&#39;&#8712;S. s&#39; &lt; s}&quot;</span><span class="">
</span><span class="">      </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">intro</span><span class=""> </span><span class="">Max_in</span><span class="delimiter">)</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">    </span><span class="keyword1">with</span><span class=""> </span><span class="">less.hyps</span><span class="delimiter">[</span><span class="">of</span><span class=""> </span><span class="var">?y</span><span class="delimiter">]</span><span class=""> </span><span class="keyword3">obtain</span><span class=""> </span><span class="">n</span><span class=""> </span><span class="keyword2">where</span><span class=""> </span><span class="string">&quot;enumerate S n = ?y&quot;</span><span class="">
</span><span class="">      </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">    </span><span class="keyword1">with</span><span class=""> </span><span class="">S</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;enumerate S (Suc n) = s&quot;</span><span class="">
</span><span class="">      </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class="delimiter">:</span><span class=""> </span><span class="">y</span><span class=""> </span><span class="">less</span><span class=""> </span><span class="">enumerate_Suc&#39;&#39;</span><span class=""> </span><span class="">intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span class=""> </span><span class="">Least_equality</span><span class="delimiter">)</span><span class="">
</span><span class="">    </span><span class="keyword1">then</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="var">?case</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">  </span><span class="keyword1">next</span><span class="">
</span><span class="">    </span><span class="keyword3">assume</span><span class=""> </span><span class="">*</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;&#172; (&#8707;y&#8712;S. y &lt; s)&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">then</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;&#8704;t&#8712;S. s &#8804; t&quot;</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">    </span><span class="keyword1">with</span><span class=""> </span><span class="cartouche">&#8249;s &#8712; S&#8250;</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="var">?thesis</span><span class="">
</span><span class="">      </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span class=""> </span><span class="">exI</span><span class="delimiter">[</span><span class="">of</span><span class=""> </span><span class="">_</span><span class=""> </span><span class="">0</span><span class="delimiter">]</span><span class=""> </span><span class="">Least_equality</span><span class=""> </span><span class="">simp</span><span class="delimiter">:</span><span class=""> </span><span class="">enumerate_0</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">qed</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="keyword1">lemma</span><span class=""> </span><span class="">bij_enumerate</span><span class="delimiter">:</span><span class="">
</span><span class="">  </span><span class="keyword2">fixes</span><span class=""> </span><span class="">S</span><span class=""> </span><span class="delimiter">::</span><span class=""> </span><span class="string">&quot;nat set&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">assumes</span><span class=""> </span><span class="">S</span><span class="delimiter">:</span><span class=""> </span><span class="string">&quot;infinite S&quot;</span><span class="">
</span><span class="">  </span><span class="keyword2">shows</span><span class=""> </span><span class="string">&quot;bij_betw (enumerate S) UNIV S&quot;</span><span class="">
</span><span class="keyword1">proof</span><span class=""> </span><span class="">-</span><span class="">
</span><span class="">  </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;&#8896;n m. n &#8800; m &#10233; enumerate S n &#8800; enumerate S m&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">using</span><span class=""> </span><span class="">enumerate_mono</span><span class="delimiter">[</span><span class="">OF</span><span class=""> </span><span class="">_</span><span class=""> </span><span class="cartouche">&#8249;infinite S&#8250;</span><span class="delimiter">]</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class="delimiter">:</span><span class=""> </span><span class="">neq_iff</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">then</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;inj (enumerate S)&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">simp</span><span class="delimiter">:</span><span class=""> </span><span class="">inj_on_def</span><span class="delimiter">)</span><span class="">
</span><span class="">  </span><span class="keyword1">moreover</span><span class=""> </span><span class="keyword1">have</span><span class=""> </span><span class="string">&quot;&#8704;s &#8712; S. &#8707;i. enumerate S i = s&quot;</span><span class="">
</span><span class="">    </span><span class="keyword1">using</span><span class=""> </span><span class="">enumerate_Ex</span><span class="delimiter">[</span><span class="">OF</span><span class=""> </span><span class="">S</span><span class="delimiter">]</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="">auto</span><span class="">
</span><span class="">  </span><span class="keyword1">moreover</span><span class=""> </span><span class="keyword1">note</span><span class=""> </span><span class="cartouche">&#8249;infinite S&#8250;</span><span class="">
</span><span class="">  </span><span class="keyword1">ultimately</span><span class=""> </span><span class="keyword3">show</span><span class=""> </span><span class="var">?thesis</span><span class="">
</span><span class="">    </span><span class="keyword1">unfolding</span><span class=""> </span><span class="">bij_betw_def</span><span class=""> </span><span class="keyword1">by</span><span class=""> </span><span class="delimiter">(</span><span class="">auto</span><span class=""> </span><span class="">intro</span><span class="delimiter">:</span><span class=""> </span><span class="">enumerate_in_set</span><span class="delimiter">)</span><span class="">
</span><span class="keyword1">qed</span><span class="">
</span><span class="">
</span><span class="keyword2">end</span><span class="">
</span><span class="">
</span></pre>

</div>
</body>
</html>
